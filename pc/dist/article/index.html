<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Nuxt.js project" name="description" data-hid="description"><title data-n-head="true">pc</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="https://unpkg.com/element-ui/lib/theme-chalk/index.css" rel="stylesheet" data-n-head="true"><link href="//at.alicdn.com/t/font_313716_nxy3880fotc07ldi.css" rel="stylesheet" data-n-head="true"><script src="~assets/isMobile.js" data-n-head="true"></script><link href="/_nuxt/manifest.fbc6bd9770885bc7a818.js" rel="preload" as="script"><link href="/_nuxt/vendor.cb6db4276c8094660c7c.js" rel="preload" as="script"><link href="/_nuxt/app.a588a7cc70431adbc41f.js" rel="preload" as="script"><link href="/_nuxt/layouts_default.57c9bebbe8d2e3396b4a.js" rel="preload" as="script"><link href="/_nuxt/pages_article_index.23c3cff31bc7808389c3.js" rel="preload" as="script"><link href="/_nuxt/pages_index.e8b7ff76295ac7703caf.js" rel="prefetch"><link href="/_nuxt/pages_movies_index.fcb4d7a81ba1474f7c46.js" rel="prefetch"><style data-vue-ssr-id="99cd3170:0">.textover2{display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2;overflow:hidden}.textover1{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.clearfix:after{content:"";height:0;display:block;overflow:hidden;clear:both}.fl{float:left}.fr{float:right}</style><style data-vue-ssr-id="9bc2a232:0">html{font-size:12px;font-family:-apple-system,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Helvetica Neue,Arial,sans-serif;word-break:break-word;text-rendering:optimizeLegibility;color:#333;background-color:#f4f5f5}.book-section-view{background:#fff;padding:10px;-webkit-box-sizing:border-box;box-sizing:border-box}.book-section-view .entry-content,.column-view .entry-content,.entry-public-view .entry-content{word-break:break-word;line-height:27.24px;line-height:2.27rem;font-weight:400;font-size:16px}.book-section-view .entry-content::-webkit-scrollbar,.column-view .entry-content::-webkit-scrollbar,.entry-public-view .entry-content::-webkit-scrollbar{display:none}.book-section-view .entry-content h1,.column-view .entry-content h1,.entry-public-view .entry-content h1{margin:15.6px 0;margin:1.3rem 0;line-height:1.2}.book-section-view .entry-content p,.column-view .entry-content p,.entry-public-view .entry-content p{line-height:27.24px;line-height:2.27rem}.book-section-view .entry-content hr,.column-view .entry-content hr,.entry-public-view .entry-content hr{border-top:1px solid #ddd;border-bottom:none;border-left:none;border-right:none;margin-top:32.4px;margin-top:2.7rem;margin-bottom:32.4px;margin-bottom:2.7rem}.book-section-view .entry-content embed,.book-section-view .entry-content iframe,.book-section-view .entry-content img:not(.equation),.book-section-view .entry-content video,.column-view .entry-content embed,.column-view .entry-content iframe,.column-view .entry-content img:not(.equation),.column-view .entry-content video,.entry-public-view .entry-content embed,.entry-public-view .entry-content iframe,.entry-public-view .entry-content img:not(.equation),.entry-public-view .entry-content video{max-width:100%!important;margin:0!important}.book-section-view .entry-content img.lazyload,.column-view .entry-content img.lazyload,.entry-public-view .entry-content img.lazyload{visibility:hidden}.book-section-view .entry-content img.inited,.column-view .entry-content img.inited,.entry-public-view .entry-content img.inited{background-color:#f8f9fa;background-position:50%;background-repeat:no-repeat;visibility:visible}.book-section-view .entry-content img.loaded,.column-view .entry-content img.loaded,.entry-public-view .entry-content img.loaded{background-image:none;background-color:transparent}.book-section-view .entry-content img.error,.column-view .entry-content img.error,.entry-public-view .entry-content img.error{background-image:url(https://gold-cdn.xitu.io/v3/static/img/image-error.3338abe.png)}.book-section-view .entry-content img.equation,.column-view .entry-content img.equation,.entry-public-view .entry-content img.equation{margin:0 .1em;max-width:100%;vertical-align:text-bottom}.book-section-view .entry-content img:not(.equation),.column-view .entry-content img:not(.equation),.entry-public-view .entry-content img:not(.equation){cursor:-webkit-zoom-in;cursor:zoom-in}.book-section-view .entry-content figure,.column-view .entry-content figure,.entry-public-view .entry-content figure{margin:32.4px auto;margin:2.7rem auto;text-align:center}.book-section-view .entry-content figure figcaption,.column-view .entry-content figure figcaption,.entry-public-view .entry-content figure figcaption{text-align:center;font-size:12px;font-size:1rem;line-height:32.4px;line-height:2.7rem;color:#909090}.book-section-view .entry-content pre,.column-view .entry-content pre,.entry-public-view .entry-content pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;line-height:23.16px;line-height:1.93rem;overflow:auto}.book-section-view .entry-content code,.column-view .entry-content code,.entry-public-view .entry-content code{font-family:Menlo,Monaco,Consolas,Courier New,monospace;font-size:12px;font-size:1rem;padding:3.12px .53em;padding:.26rem .53em;word-break:break-word;color:#4e5980;background-color:#f8f8f8;border-radius:2px;overflow-x:auto}.book-section-view .entry-content pre>code,.column-view .entry-content pre>code,.entry-public-view .entry-content pre>code{font-size:12px;font-size:1rem;padding:8.04px 15.6px;padding:.67rem 1.3rem;margin:0;word-break:normal;display:block;color:#333}.book-section-view .entry-content a,.column-view .entry-content a,.entry-public-view .entry-content a{color:#259}.book-section-view .entry-content a:active,.book-section-view .entry-content a:hover,.column-view .entry-content a:active,.column-view .entry-content a:hover,.entry-public-view .entry-content a:active,.entry-public-view .entry-content a:hover{color:#275b8c}.book-section-view .entry-content table,.column-view .entry-content table,.entry-public-view .entry-content table{display:inline-block;font-size:12px;font-size:1rem;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.book-section-view .entry-content thead,.column-view .entry-content thead,.entry-public-view .entry-content thead{background:#f6f6f6;color:#000;text-align:left}.book-section-view .entry-content tr:nth-child(2n),.column-view .entry-content tr:nth-child(2n),.entry-public-view .entry-content tr:nth-child(2n){background-color:#fcfcfc}.book-section-view .entry-content td,.book-section-view .entry-content th,.column-view .entry-content td,.column-view .entry-content th,.entry-public-view .entry-content td,.entry-public-view .entry-content th{padding:12px 7.199px;padding:1rem .6rem;line-height:24px;line-height:2rem}.book-section-view .entry-content td,.column-view .entry-content td,.entry-public-view .entry-content td{min-width:120px;min-width:10rem}.book-section-view .entry-content blockquote,.column-view .entry-content blockquote,.entry-public-view .entry-content blockquote{margin:1em 0;border-left:4px solid #ddd;padding:0 15.6px;padding:0 1.3rem;color:#666}.book-section-view .entry-content blockquote>p,.column-view .entry-content blockquote>p,.entry-public-view .entry-content blockquote>p{margin:7.199px 0;margin:.6rem 0}.book-section-view .entry-content ol,.book-section-view .entry-content ul,.column-view .entry-content ol,.column-view .entry-content ul,.entry-public-view .entry-content ol,.entry-public-view .entry-content ul{padding-left:32.4px;padding-left:2.7rem}.book-section-view .entry-content ol li,.book-section-view .entry-content ul li,.column-view .entry-content ol li,.column-view .entry-content ul li,.entry-public-view .entry-content ol li,.entry-public-view .entry-content ul li{margin-bottom:7.199px;margin-bottom:.6rem;list-style:inherit}.book-section-view .entry-content ol ol,.book-section-view .entry-content ol ul,.book-section-view .entry-content ul ol,.book-section-view .entry-content ul ul,.column-view .entry-content ol ol,.column-view .entry-content ol ul,.column-view .entry-content ul ol,.column-view .entry-content ul ul,.entry-public-view .entry-content ol ol,.entry-public-view .entry-content ol ul,.entry-public-view .entry-content ul ol,.entry-public-view .entry-content ul ul{margin-top:3.24px;margin-top:.27rem}.book-section-view .entry-content pre>code.hljs,.column-view .entry-content pre>code.hljs,.entry-public-view .entry-content pre>code.hljs{overflow-x:auto;-webkit-overflow-scrolling:touch;color:#333;background:#f8f8f8}.book-section-view .entry-content .hljs-comment,.book-section-view .entry-content .hljs-quote,.column-view .entry-content .hljs-comment,.column-view .entry-content .hljs-quote,.entry-public-view .entry-content .hljs-comment,.entry-public-view .entry-content .hljs-quote{color:#998}.book-section-view .entry-content .hljs-keyword,.book-section-view .entry-content .hljs-selector-tag,.book-section-view .entry-content .hljs-subst,.column-view .entry-content .hljs-keyword,.column-view .entry-content .hljs-selector-tag,.column-view .entry-content .hljs-subst,.entry-public-view .entry-content .hljs-keyword,.entry-public-view .entry-content .hljs-selector-tag,.entry-public-view .entry-content .hljs-subst{color:#333;font-weight:700}.book-section-view .entry-content .hljs-literal,.book-section-view .entry-content .hljs-number,.book-section-view .entry-content .hljs-tag .hljs-attr,.book-section-view .entry-content .hljs-template-variable,.book-section-view .entry-content .hljs-variable,.column-view .entry-content .hljs-literal,.column-view .entry-content .hljs-number,.column-view .entry-content .hljs-tag .hljs-attr,.column-view .entry-content .hljs-template-variable,.column-view .entry-content .hljs-variable,.entry-public-view .entry-content .hljs-literal,.entry-public-view .entry-content .hljs-number,.entry-public-view .entry-content .hljs-tag .hljs-attr,.entry-public-view .entry-content .hljs-template-variable,.entry-public-view .entry-content .hljs-variable{color:teal}.book-section-view .entry-content .hljs-doctag,.book-section-view .entry-content .hljs-string,.column-view .entry-content .hljs-doctag,.column-view .entry-content .hljs-string,.entry-public-view .entry-content .hljs-doctag,.entry-public-view .entry-content .hljs-string{color:#d14}.book-section-view .entry-content .hljs-section,.book-section-view .entry-content .hljs-selector-id,.book-section-view .entry-content .hljs-title,.column-view .entry-content .hljs-section,.column-view .entry-content .hljs-selector-id,.column-view .entry-content .hljs-title,.entry-public-view .entry-content .hljs-section,.entry-public-view .entry-content .hljs-selector-id,.entry-public-view .entry-content .hljs-title{color:#900;font-weight:700}.book-section-view .entry-content .hljs-subst,.column-view .entry-content .hljs-subst,.entry-public-view .entry-content .hljs-subst{font-weight:400}.book-section-view .entry-content .hljs-class .hljs-title,.book-section-view .entry-content .hljs-type,.column-view .entry-content .hljs-class .hljs-title,.column-view .entry-content .hljs-type,.entry-public-view .entry-content .hljs-class .hljs-title,.entry-public-view .entry-content .hljs-type{color:#458;font-weight:700}.book-section-view .entry-content .hljs-attribute,.book-section-view .entry-content .hljs-name,.book-section-view .entry-content .hljs-tag,.column-view .entry-content .hljs-attribute,.column-view .entry-content .hljs-name,.column-view .entry-content .hljs-tag,.entry-public-view .entry-content .hljs-attribute,.entry-public-view .entry-content .hljs-name,.entry-public-view .entry-content .hljs-tag{color:navy;font-weight:400}.book-section-view .entry-content .hljs-link,.book-section-view .entry-content .hljs-regexp,.column-view .entry-content .hljs-link,.column-view .entry-content .hljs-regexp,.entry-public-view .entry-content .hljs-link,.entry-public-view .entry-content .hljs-regexp{color:#009926}.book-section-view .entry-content .hljs-bullet,.book-section-view .entry-content .hljs-symbol,.column-view .entry-content .hljs-bullet,.column-view .entry-content .hljs-symbol,.entry-public-view .entry-content .hljs-bullet,.entry-public-view .entry-content .hljs-symbol{color:#990073}.book-section-view .entry-content .hljs-built_in,.book-section-view .entry-content .hljs-builtin-name,.column-view .entry-content .hljs-built_in,.column-view .entry-content .hljs-builtin-name,.entry-public-view .entry-content .hljs-built_in,.entry-public-view .entry-content .hljs-builtin-name{color:#0086b3}.book-section-view .entry-content .hljs-meta,.column-view .entry-content .hljs-meta,.entry-public-view .entry-content .hljs-meta{color:#999;font-weight:700}.book-section-view .entry-content .hljs-deletion,.column-view .entry-content .hljs-deletion,.entry-public-view .entry-content .hljs-deletion{background:#fdd}.book-section-view .entry-content .hljs-addition,.column-view .entry-content .hljs-addition,.entry-public-view .entry-content .hljs-addition{background:#dfd}.book-section-view .entry-content .hljs-emphasis,.column-view .entry-content .hljs-emphasis,.entry-public-view .entry-content .hljs-emphasis{font-style:italic}.book-section-view .entry-content .hljs-strong,.column-view .entry-content .hljs-strong,.entry-public-view .entry-content .hljs-strong{font-weight:700}</style><style data-vue-ssr-id="3938fa5d:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;-webkit-transition:width .2s,opacity .4s;transition:width .2s,opacity .4s;opacity:1;background-color:#efc14e;z-index:999999}</style><style data-vue-ssr-id="715a535a:0">.icon-expand{float:left;height:60px;width:60px;overflow:hidden;cursor:pointer;text-align:left}.icon-expand i{font-size:24px}.el-menu-vertical-demo:not(.el-menu--collapse){width:200px;text-align:left}.el-menu-vertical-demo.el-menu--collapse,.el-menu-vertical-demo:not(.el-menu--collapse){position:relative;border-right:none;min-height:100vh;padding-top:60px;-webkit-box-shadow:2px 0 6px rgba(0,21,41,.35);box-shadow:2px 0 6px rgba(0,21,41,.35)}.el-menu{border-right:none;z-index:10}.el-footer,.el-header{background-color:#fff;color:#333;text-align:center;line-height:60px;-webkit-box-shadow:0 1px 4px rgba(0,21,41,.08);box-shadow:0 1px 4px rgba(0,21,41,.08);position:relative}.el-main{background-color:#f0f2f5;color:#333;text-align:left;height:100%;min-height:100vh}body>.el-container{margin-bottom:40px}</style><style data-vue-ssr-id="040b034a:0">html{font-family:Source Sans Pro,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:16px;word-spacing:1px;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}*,:after,:before,html{-webkit-box-sizing:border-box;box-sizing:border-box}*,:after,:before{margin:0}.button--green{display:inline-block;border-radius:4px;border:1px solid #3b8070;color:#3b8070;text-decoration:none;padding:10px 30px}.button--green:hover{color:#fff;background-color:#3b8070}.button--grey{display:inline-block;border-radius:4px;border:1px solid #35495e;color:#35495e;text-decoration:none;padding:10px 30px;margin-left:15px}.button--grey:hover{color:#fff;background-color:#35495e}</style><style data-vue-ssr-id="0cf7cc61:0">.card-box{width:100%;float:left;margin:5px;height:388px;overflow:hidden}.img-box{height:294px;overflow:hidden}.image{height:100%;width:100%;-o-object-fit:cover;object-fit:cover}.author-info{border-top:1px solid #eee;padding:8px}.author-info .author-icon{height:20px;width:20px;border-radius:50%;display:inline-block;overflow:hidden}.author-info .author-icon img{width:100%}.author-info .author-name{font-size:14px;vertical-align:top}.author-info .create-time{font-size:12px;color:#999;vertical-align:super}.tags-wrapper{width:100%;overflow:hidden}.detail-tag{background:#eee;padding:4px 6px;display:inline-block;margin-bottom:10px;margin-right:6px;white-space:nowrap}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3b8070;opacity:0"></div><div id="__layout"><div class="hello"><section class="el-container"><ul class="el-menu el-menu-vertical-demo" role="menubar" style="background-color:#545c64"><li class="el-submenu" role="menuitem" aria-haspopup="true"><div class="el-submenu__title" style="padding-left:20px;color:#fff;background-color:#545c64"><div><i class="el-icon-location"></i><span slot="title">充电</span></div><i class="el-submenu__icon-arrow el-icon-arrow-down"></i></div><ul class="el-menu el-menu--inline" role="menu" style="background-color:#545c64;display:none"><li class="el-menu-item-group"><div class="el-menu-item-group__title" style="padding-left:40px"><span>学习</span></div><ul><li class="el-menu-item is-active" role="menuitem" style="padding-left:40px;color:#ffd04b;background-color:#545c64" tabindex="-1">文章列表</ul><li class="el-menu-item-group"><div class="el-menu-item-group__title" style="padding-left:40px"><span>娱乐</span></div><ul><li class="el-menu-item" role="menuitem" style="padding-left:40px;color:#fff;background-color:#545c64" tabindex="-1">电影预告</ul></ul></ul><section class="el-container is-vertical"><header class="el-header" style="height:60px"><span class="icon-expand"><i class="iconfont icon-xuanxiang"></i></span></header><main class="el-main"><div><div class="el-card"><!----><div class="el-card__body"><div><div class="el-table el-table--fit el-table--enable-row-hover el-table--enable-row-transition" style="width:100%"><div class="hidden-columns"><div></div><div></div><div></div><div></div></div><div class="el-table__header-wrapper"><table cellspacing="0" cellpadding="0" border="0" class="el-table__header"><colgroup><thead><tr></thead></table></div><div class="el-table__body-wrapper is-scrolling-none"><table cellspacing="0" cellpadding="0" border="0" class="el-table__body"><colgroup><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"><tr class="el-table__row"></tr><!----></table><!----><!----></div><!----><!----><!----><!----><div class="el-table__column-resize-proxy" style="display:none"></div></div><div class="el-pagination is-background"><button type="button" class="btn-prev disabled"><i class="el-icon el-icon-arrow-left"></i></button><ul class="el-pager"><li class="number active">1</li><!----><li class="number">2<li class="number">3<li class="number">4<li class="number">5<li class="number">6</li><!----><li class="number">7</ul><button type="button" class="btn-next"><i class="el-icon el-icon-arrow-right"></i></button></div></div></div></div><div class="el-dialog__wrapper" style="display:none"><div class="el-dialog" style="width:50%;margin-top:15vh"><div class="el-dialog__header"><span class="el-dialog__title"></span><button type="button" aria-label="Close" class="el-dialog__headerbtn"><i class="el-dialog__close el-icon el-icon-close"></i></button></div><!----><!----></div></div></div></main></section></section></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{data:[{tags:["PHP","iOS","Android","前端","后端"],meta:{updateAt:"2018-02-09T05:06:21.632Z",createAt:"2018-02-09T05:06:21.632Z"},_id:"5a7d2c4da7d59115dcd1f2df",id:"59cb4f49f265da0658153c9a",title:"注册、登录和 token 的安全之道",avatar:"https://avatars.githubusercontent.com/u/20643362?v=3",author:"薛定諤",create_time:"2017 年 09 月 27 日",content:'<div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container"><p>最近想要做一个小项目，由于前后都是一个人，在登录和注册的接口上就被卡住了，因此想登录、注册、口令之间的关系，使用 PHP 实现登录注册模块，和访问口令。</p>\n<p>出于安全的考虑，首先定下三项原则：</p>\n<ol>\n<li>在传输中，不允许明文传输用户隐私数据；</li>\n<li>在本地，不允许明文保存用户隐私数据；</li>\n<li>在服务器，不允许明文保存用户隐私数据；</li>\n</ol>\n<p>在网络来说，我们知道不论 POST 请求和 GET 请求都会被抓包，在没有使用 HTTPS 的情况下，抓包我们是防不住的，如果明文传输用户隐私，那后果就不说了。</p>\n<p>本地和服务器也是如此，比如 iOS 设备，如果存储在本地，越狱之后通过设备 Finder 之类的功能，也能轻易找到我们存储在本地的用户隐私。</p>\n<blockquote>\n<p>使用 Keychain 在本地也有保存，但不在沙盒，暂且忽略。</p>\n</blockquote>\n<p>上面讲到，用户隐私数据总归可以被拿到的，如何保证被拿到之后不会被用来做坏事？</p>\n<h2 id="-" data-id="heading-0">加密</h2>\n<p>将用户的隐私数据加密，那么就算被拿到，也无法被拿来使用。在这里呢，我们先不谈加密，而是先纠正一个误区，有些朋友会认为 Base64 可以加密，甚至有 Base64 加密的说法。</p>\n<p>Base64 主要不是加密，它主要的用途是把二进制数据序列转化为 ASCII 字符序列，用以数据传输。二进制数据是什么呢？计算机上存储的所有数据，都是二进制数据。</p>\n<p>Base64 最常见的应用场景是 URL，因为 URL 只能是特定的一些 ASCII 字符。这时需要用到 Base64 编码，当然这也只是对二进制数据本身的编码，编码后的数据里面可能包含 <code>+/=</code> 等符号，真正放到 URL 里面时候，还需要URL-Encoding，变成 <code>%XX</code> 模式，以消除这些符号的歧义。其次就是将图片转为 Base64 的字符串。</p>\n<p><strong>因此，Base64 只是一种编码方式，而不是加密方式。</strong></p>\n<p>好了，现在回到我们的主题，先说登录和注册之间的关系，这 3 个模块需要做什么事情呢？</p>\n<ul>\n<li>注册：将用户输入的隐私数据，发送给服务器，服务器进行保存；</li>\n<li>登录：将用户输入的隐私数据，发送给服务器，服务器进行比对，确认是否有权限登录；</li>\n<li>token：确保用户在登录中；</li>\n</ul>\n<p>我们把用户输入的隐私数据再具象一些，比如账号和密码，结合我们上面提到的安全原则，那么分解开来，实际我们要做以下几件事：</p>\n<ul>\n<li>服务器-注册接口：接收客户端传来的账号和密码，将其保存在数据库中；</li>\n<li>服务器-登录接口：接收客户端传来的账号和密码，与数据库比对，完全命中则登录成功，否则登录失败；<ul>\n<li>登录成功后，生成或更新 token 和过期时间，保存在数据库， token 返回给客户端；</li>\n<li>服务器定期清除 token；</li>\n</ul>\n</li>\n<li>客户端-注册模块：向服务器注册接口发送账号和密码；</li>\n<li>客户端-登录模块：向服务器登录接口发送账号和密码；<ul>\n<li>登录成功后，保存 token 到本地；</li>\n<li>退出登录后，清除 token；</li>\n</ul>\n</li>\n<li>发送的账号和密码需要加密；</li>\n<li>数据库中需要保存的是加密后的账号和密码；</li>\n<li>请求敏感数据时，将客户端传来的 token 和服务器验证，不通过则提示客户端登录；</li>\n</ul>\n<p>上面逻辑理清楚后，相信对于大家来说并不难实现，以下是服务器注册接口做的事情：</p>\n<pre><code class="hljs php"><span class="hljs-comment">/*获取 get 请求传递的参数*/</span>\n$account = $_GET[<span class="hljs-string">\'account\'</span>];\n$password = $_GET[<span class="hljs-string">\'password\'</span>];\n\n<span class="hljs-comment">/*创建数据连接*/</span>\n$db = <span class="hljs-keyword">new</span> DataBase();\n\n<span class="hljs-comment">/*检查用户名是否存在*/</span>\n$is_exist = $db-&gt;check_user_exist($account);\n\n<span class="hljs-keyword">if</span> ($is_exist) {\n    <span class="hljs-keyword">echo</span> return_value(<span class="hljs-number">10001</span>, <span class="hljs-keyword">false</span>);\n}\n<span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">/*检查用户名是否添加成功*/</span>\n    $result = $db-&gt;add_user($account, $password);\n    <span class="hljs-keyword">if</span> ($result) {\n        <span class="hljs-keyword">echo</span> return_value(<span class="hljs-number">0</span>, <span class="hljs-keyword">true</span>);\n    }\n    <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">echo</span> return_value(<span class="hljs-number">20001</span>, <span class="hljs-keyword">false</span>);\n    }\n}</code></pre><p>现在是服务器登录接口做的事情：</p>\n<pre><code class="hljs php"><span class="hljs-comment">/*获取 get 请求传递的参数*/</span>\n$account = $_GET[<span class="hljs-string">\'account\'</span>];\n$password = $_GET[<span class="hljs-string">\'password\'</span>];\n\n<span class="hljs-comment">/*创建数据连接*/</span>\n$db = <span class="hljs-keyword">new</span> DataBase();\n\n<span class="hljs-comment">/*是否命中用户名和密码*/</span>\n$should_login = $db-&gt;should_login($account, $password);\n\n<span class="hljs-keyword">if</span> ($should_login) {\n    <span class="hljs-comment">/*更新 token*/</span>\n    $token = $db-&gt;insert_token($account);\n    <span class="hljs-keyword">if</span> ($token == <span class="hljs-string">\'\'</span>) {\n        <span class="hljs-keyword">echo</span> response(<span class="hljs-number">40001</span>, <span class="hljs-keyword">false</span>);\n    }\n    <span class="hljs-keyword">else</span> {\n        $data = [<span class="hljs-string">\'token\'</span> =&gt; $token];\n        <span class="hljs-keyword">echo</span> response(<span class="hljs-number">0</span>, $data);\n    }\n}\n<span class="hljs-keyword">else</span> {\n    <span class="hljs-keyword">echo</span> response(<span class="hljs-number">30001</span>, <span class="hljs-keyword">false</span>);\n}</code></pre><p>剩下的无非是加密算法的不同，我最常用的是 md5，那么我们经过 md5 加密以后，其实还是不太安全，为什么呢？因为 md5 本身就不安全。虽然 md5 是不可逆的 hash 算法，反向算出来虽然困难，但是如果反向查询，密码设置的简单，也很容易被攻破。</p>\n<p>比如我们使用 md5 加密一个密码 <code>123456</code>，对应的 md5 是 <code>e10adc3949ba59abbe56e057f20f883e</code>，找到一个 md5 解密的网站，比如 <a href="https://link.juejin.im?target=http%3A%2F%2Fcmd5.com%2F%EF%BC%8C%E5%BE%88%E5%AE%B9%E6%98%93%E5%B0%B1%E8%A2%AB%E7%A0%B4%E8%A7%A3%E4%BA%86%E5%AF%86%E7%A0%81%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%E5%91%A2%EF%BC%9F" target="_blank" rel="nofollow noopener noreferrer">cmd5.com/，很容易就被破解了密码…</a></p>\n<h2 id="-" data-id="heading-1">加盐</h2>\n<p>工作一段时间的同学对这个名词应该不会陌生，这种方式算是给用户的隐私数据加上密了，其实就是一段隐私数据加一段乱码再进行 md5，用代码表示大致是这样：</p>\n<pre><code class="hljs python">// 伪代码\nsalt = <span class="hljs-string">\'#^&amp;%**(^&amp;(&amp;*)_)_(*&amp;^&amp;#$%GVHKBJ(*^&amp;*%^%&amp;^&amp;\'</span>\npassword = <span class="hljs-string">\'123456\'</span>\npost_body = salt + password\n<span class="hljs-keyword">print</span> post_body.md5()\n// ffb34d898f6573a1cf14fdc34d3343c0</code></pre><p>现在，密码看起来挺靠谱的了，但是，我们知道加盐这种方式是比较早期的处理方式了，既然现在没有在大范围使用了，就说明单纯加盐还是存在缺陷的。</p>\n<h3 id="-" data-id="heading-2">有泄露的可能</h3>\n<p>现在我们在客户端对密码做了 md5 加盐，服务器保存的也是加密后的内容，但是，盐是写在了客户端的源代码中，一旦对源代码进行反编译，找到 <code>salt</code> 这个字符串，那么加盐的做法也就形同虚设了。</p>\n<p>反编译源代码的代价也很高，一般对于安全性能要求不高的话，也够用了，但是，对于一些涉及资金之类的 App  来说，仅仅加盐还是不够的。</p>\n<p>比如离职的技术同学不是很开心，又或者有人想花钱买这串字符等等，盐一旦被泄露，就是一场灾难，这也是盐最大的缺陷。</p>\n<h3 id="-" data-id="heading-3">依赖性太强</h3>\n<p>盐一旦被设定，那么再做修改的话就非常困难了，因为服务器存储的全部是加盐后的数据，如果换盐，那么这些数据全部都需要改动。<strong>但是可怕的不在于此，如果将服务器的数据改动后，旧版本的用户再访问又都不可以了，因为他们用的是之前的盐。</strong></p>\n<h2 id="hmac" data-id="heading-4">HMAC</h2>\n<p>目前最常见的方式，应该就是 HMAC 了，HMAC 算法主要应用于身份验证，与加盐的不同点在于，盐被移到了服务器，服务器返回什么，就用什么作为盐。</p>\n<p>这么做有什么好处呢？ 如果我们在登录的过程中，黑客截获了我们发送的数据，他也只能得到 HMAC 加密过后的结果，由于不知道密钥，根本不可能获取到用户密码，从而保证了安全性。</p>\n<p>但是还有一个问题，前面我们讲到，<strong>盐被获取以后很危险，如果从服务器获取盐，也会被抓包，那还不如写在源代码里面呢，至少被反编译还困难点，那如果解决这个隐患呢</strong>？</p>\n<p>那就是，在用户注册时就生成和获取这个秘钥，以代码示例：</p>\n<p>现在我们发送一个请求：</p>\n<pre><code class="hljs bash">GET http://localhost:8888/capsule/register.php?account=joy&amp;password=789</code></pre><p>服务器收到请求后，做了下面的事情：</p>\n<pre><code class="hljs php"><span class="hljs-comment">/*获取 get 请求传递的参数*/</span>\n$account = $_GET[<span class="hljs-string">\'account\'</span>];\n$password = $_GET[<span class="hljs-string">\'password\'</span>];  <span class="hljs-comment">//123456</span>\n\n<span class="hljs-comment">/*创建数据连接*/</span>\n$db = <span class="hljs-keyword">new</span> DataBase();\n\n<span class="hljs-comment">/*制作一个随机的盐*/</span>\n$salt = salt();\n\n<span class="hljs-comment">/*检查用户名是否存在*/</span>\n$is_exist = $db-&gt;check_user_exist($account);\n\n<span class="hljs-keyword">if</span> ($is_exist) {\n    <span class="hljs-keyword">echo</span> response(<span class="hljs-number">10001</span>, <span class="hljs-keyword">false</span>);\n}\n<span class="hljs-keyword">else</span> {\n\n    <span class="hljs-comment">/*将密码进行 hmac 加密*/</span>\n    $password = str_hmac($password,  $salt);\n\n    <span class="hljs-comment">/*检查用户名是否添加成功*/</span>\n    $result = $db-&gt;add_user($account, $password);\n\n    <span class="hljs-keyword">if</span> ($result) {\n        $data = [<span class="hljs-string">\'salt\'</span>=&gt;$salt];\n        <span class="hljs-keyword">echo</span> response(<span class="hljs-number">0</span>, $data);\n        <span class="hljs-comment">//echo response(0, true);</span>\n    }\n    <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">echo</span> response(<span class="hljs-number">20001</span>, <span class="hljs-keyword">false</span>);\n    }\n}</code></pre><p>服务器现在保存的是：</p>\n<pre><code class="hljs bash">account: joy\npassword: 05575c24576</code></pre><p>客户端拿到的结果是：</p>\n<pre><code class="hljs json">{\n  <span class="hljs-attr">"rc"</span>: <span class="hljs-number">0</span>,\n  <span class="hljs-attr">"data"</span>: {\n    <span class="hljs-attr">"salt"</span>: <span class="hljs-string">"5633905fdc65b6c57be8698b1f0e884948c05d7f"</span>\n  },\n  <span class="hljs-attr">"errorInfo"</span>: <span class="hljs-string">""</span>\n}</code></pre><p>那么客户端接下来应该做什么呢？把 <code>salt</code> 做本地的持久化，登录时将用户输入的密码做一次同样的 hmac，那么就能通过服务器的 <code>password: 05575c24576</code> 校验了，发起登录请求：</p>\n<pre><code class="hljs bash">GET http://localhost:8888/capsule/login.php?account=joy&amp;password=789 \n// fail\nGET http://localhost:8888/capsule/login.php?account=joy&amp;password=05575c24576 \n// success</code></pre><p>现在我们解决了依赖性太强的问题，盐我们可以随意的更改，甚至可以是随机的，每个用户都不一样。这样单个用户的安全性虽然没有加强，但是整个平台的安全性缺大大提升了，很少有人会针对一个用户搞事情。但是细心的同学应该可以想到，现在的盐，也就是秘钥是保存在本地的，如果用户的秘钥丢失，比如换手机了，那么岂不是<strong>有正确的密码，也无法登陆了吗</strong>？</p>\n<p>针对这个问题，核心就是用户没有了秘钥，那么在用户登陆的时候，逻辑就需要变一下。</p>\n<pre><code class="hljs swift"><span class="hljs-comment">// 伪代码</span>\n<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">login</span><span class="hljs-params">(account, password)</span></span> {\n    <span class="hljs-comment">//如果有盐</span>\n    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> salt = getSalt() {\n        <span class="hljs-comment">//将密码进行 hmac，请求登陆接口</span>\n        network.login(account, password.hmac(salt))\n    }\n    <span class="hljs-keyword">else</span> {\n        <span class="hljs-comment">//请求 getSalt 接口，请求参数为账户+应用标识</span>\n        network.getSalt(account + bundleId, { salt <span class="hljs-keyword">in</span>\n            <span class="hljs-comment">//将盐保存在本地，再次调用自身。</span>\n            savaSalt(salt)\n            login(account, password)\n        })\n    }\n}</code></pre><p>那么可想而知，我们的注册接口现在也需要新加一个 <code>bundleId</code> 的请求参数，然后用 <code>account + bundleId</code> 作为 key，来保存 <code>salt</code>：</p>\n<pre><code class="hljs php"><span class="hljs-comment">/*获取 get 请求传递的参数*/</span>\n$account = $_GET[<span class="hljs-string">\'account\'</span>];\n$password = $_GET[<span class="hljs-string">\'password\'</span>];  <span class="hljs-comment">//123456</span>\n$bundle_id = $_GET[<span class="hljs-string">\'bundleId\'</span>];\n\n<span class="hljs-comment">/*创建数据连接*/</span>\n$db = <span class="hljs-keyword">new</span> DataBase();\n\n<span class="hljs-comment">/*制作一个随机的盐*/</span>\n$salt = salt();\n\n<span class="hljs-comment">/*检查用户名是否存在*/</span>\n$is_exist = $db-&gt;check_user_exist($account);\n\n<span class="hljs-keyword">if</span> ($is_exist) {\n    <span class="hljs-keyword">echo</span> response(<span class="hljs-number">10001</span>, <span class="hljs-keyword">false</span>);\n}\n<span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">/*将密码进行 hmac 加密*/</span>\n    $password = str_hmac($password,  $salt);\n\n    <span class="hljs-comment">/*检查用户名是否添加成功*/</span>\n    $result = $db-&gt;add_user($account, $password);\n\n    <span class="hljs-keyword">if</span> ($result) {\n\n        <span class="hljs-comment">/*检查秘钥是否保存成功*/</span>\n        $save_salt = $db-&gt;save_salt($salt, $account, $bundle_id);\n\n        <span class="hljs-keyword">if</span> ($save_salt) {\n            $data = [<span class="hljs-string">\'salt\'</span>=&gt;$salt];\n            <span class="hljs-keyword">echo</span> response(<span class="hljs-number">0</span>, $data);\n        }\n        <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">echo</span> response(<span class="hljs-number">20001</span>, <span class="hljs-keyword">false</span>);\n        }\n    }\n    <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">echo</span> response(<span class="hljs-number">20001</span>, <span class="hljs-keyword">false</span>);\n    }\n}</code></pre><p>同时我们需要创建一个获取 <code>salt</code> 的接口：</p>\n<pre><code class="hljs php"><span class="hljs-comment">/*获取 get 请求传递的参数*/</span>\n$account = $_GET[<span class="hljs-string">\'account\'</span>];\n$bundle_id = $_GET[<span class="hljs-string">\'bundleId\'</span>];\n\n<span class="hljs-comment">/*创建数据连接*/</span>\n$db = <span class="hljs-keyword">new</span> DataBase();\n\n<span class="hljs-comment">/*获取秘钥*/</span>\n$salt = $db-&gt;get_salt($account, $bundle_id);\n\n<span class="hljs-keyword">if</span> ($salt == <span class="hljs-string">\'\'</span>) {\n    <span class="hljs-keyword">echo</span> response(<span class="hljs-number">40001</span>, <span class="hljs-keyword">false</span>);\n}\n<span class="hljs-keyword">else</span> {\n    $data = [<span class="hljs-string">\'salt\'</span>=&gt;$salt];\n    <span class="hljs-keyword">echo</span> response(<span class="hljs-number">0</span>, $data);\n}</code></pre><p>写到这里，就可以给大家介绍一个比较好玩的东西了。</p>\n<h3 id="-" data-id="heading-5">设备锁</h3>\n<p>一些 App 具有设备锁的功能，比如 QQ，这个功能是将账号与设备进行绑定，如果其他人知道了用户的账号和密码，但是设备不符，同样无法登录，怎样实现呢？</p>\n<p>就是用户开启设备锁之后，如果设备中没有 <code>salt</code>，那么就不再请求 <code>getSalt</code> 接口，而是转为其他验证方式，通过之后，才可以请求 <code>getSalt</code>。</p>\n<h3 id="-" data-id="heading-6">提升单个用户的安全性</h3>\n<p>现在这个 App 相对来说比较安全了，上面说到，因为每个用户的 <code>salt</code> 都不一样，破解单个用户的利益不大，所以，对于平台来说安全性已经比较高了，但凡是都有例外，如果这个破坏者就是铁了心要搞事情，就针对一个用户，现在这个方案，还有哪些问题存在呢？</p>\n<ol>\n<li>注册时返回的 <code>salt</code> 被抓包时有可能会泄露；</li>\n<li>更换设备后，获取的 <code>salt</code> 被抓包时有可能会泄露；</li>\n<li>保存在本地的 <code>salt</code> ，有可能通过文件路径获取到；</li>\n<li><p>抓包的人就算不知道密码，通过 hmac 加密后的字符，也可以进行登录；</p>\n<p>怎么处理呢？首先我们需要清楚的是，之所以会被破解，是拿到了我们加密时的因子，或者叫种子，这个种子服务器和客户端都必须要有，如果没有的话，两者就无法进行通信了，但是我们也不能在客户端将种子写死，在服务器给客户端种子时，总会有可能被获取。</p>\n</li>\n</ol>\n<p>我们要设计一种思路，需要有一个种子，服务器和客户端之间无需通讯，但是都可以被理解的种子。</p>\n<p>同时我们需要这个种子是动态的，每次加密的结果都不一样，那么就算抓到了加密后的密码，这个密码也随之失效了。</p>\n<p><strong>所以，我们需要一个无需服务器和客户端通讯的，动态的种子，时间。</strong></p>\n<h2 id="hmac-" data-id="heading-7">HMAC+时间</h2>\n<p>这个动态的种子是如何使用的呢？</p>\n<ol>\n<li>客户端发送注册请求，服务器返回 <code>salt</code>，保存 hmac 后的密码；</li>\n<li>客户端保存 <code>salt</code>；</li>\n<li>客户端发送登录请求，参数为 hmac 后的密码，加上当前的时间；</li>\n<li>服务器收到登录请求，将数据库中的密码，加上当前的时间，进行比对；</li>\n</ol>\n<p>客户端代码：</p>\n<pre><code class="hljs javascript"><span class="hljs-comment">// 秘钥</span>\n<span class="hljs-keyword">const</span> salt = <span class="hljs-string">\'\'</span>\n<span class="hljs-comment">// 当前时间，精确到分钟</span>\n<span class="hljs-keyword">const</span> currentTime = <span class="hljs-string">\'201709171204\'</span>\n<span class="hljs-comment">// 用户输入的密码</span>\n<span class="hljs-keyword">let</span> password = <span class="hljs-string">\'123456\'</span>\n<span class="hljs-comment">// (hmac+currentTime).md5</span>\npassword = (password.hmac(salt) + currentTime).md5()\nnetwork(<span class="hljs-string">\'login\'</span>, {<span class="hljs-attr">method</span>: <span class="hljs-string">\'GET\'</span>, <span class="hljs-attr">params</span>: {<span class="hljs-attr">password</span>:password}})</code></pre><p>服务器代码：</p>\n<pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">should_login</span><span class="hljs-params">($account, $password)</span>\n</span>{\n    $account = mysqli_real_escape_string(<span class="hljs-keyword">$this</span>-&gt;connection ,$account);\n    $password = mysqli_real_escape_string(<span class="hljs-keyword">$this</span>-&gt;connection, $password);\n    $user = <span class="hljs-keyword">$this</span>-&gt;get_user($account);\n    <span class="hljs-keyword">if</span> ($user == <span class="hljs-keyword">null</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;\n    }\n    $password_local = $user[<span class="hljs-string">\'password\'</span>];\n    <span class="hljs-keyword">if</span> ($password_local == <span class="hljs-string">\'\'</span>) {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;\n    }\n    $password_local = md5($password_local.current_time());\n    <span class="hljs-keyword">if</span> ($password_local == $password) {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;\n    }\n    <span class="hljs-keyword">else</span> {\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;\n    }\n}</code></pre><p>但是现在还有一点问题，那就是对时间的容错上，如果客户端发送的时候是 <code>201709171204</code>，服务器响应时却已经到了 <code>201709171205</code> 了，那么这样势必是不能通过的，这种情况，只需要服务器把当前的时间减去一分钟，再校验一次，符合其中之一就可以。</p>\n<p>聪明的你应该可以想到，这也就是<strong>验证码 5 分钟内有效期的实现</strong>。</p>\n<p>现在这个 App，就算注册时拿到了 <code>salt</code>，也很难在 1 分钟内反推出密码，同时，抓包的密码一分钟后也就失效了，对于单个用户的安全性，也有了进一步的提升。</p>\n</div>',__v:0},{tags:["Vue.js","前端"],meta:{updateAt:"2018-02-09T05:06:21.632Z",createAt:"2018-02-09T05:06:21.632Z"},_id:"5a7d2c4da7d59115dcd1f2de",id:"596c7af1f265da6c251906c0",title:"Vue 2.3、2.4 知识点小结",avatar:"https://user-gold-cdn.xitu.io/2017/5/8/8f921da3774a31d840cff839fd4283b8?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1",author:"三毛丶",create_time:"2017 年 07 月 21 日",content:'<div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container"><blockquote>\n<p>原文连接 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fblog%2Fissues%2F15" target="_blank" rel="nofollow noopener noreferrer">blog</a> ， 本文不涉及 SSR.</p>\n</blockquote>\n<p>2.3 参考 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Freleases%2Ftag%2Fv2.3.0" target="_blank" rel="nofollow noopener noreferrer">github.com/vuejs/vue/r…</a><br>2.4 参考 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Freleases%2Ftag%2Fv2.4.0" target="_blank" rel="nofollow noopener noreferrer">github.com/vuejs/vue/r…</a><br>实例 demo 地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fvue-demo" target="_blank" rel="nofollow noopener noreferrer">github.com/jkchao/vue-…</a></p>\n<hr>\n<h1 id="2-3" data-id="heading-0">2.3</h1>\n<ul>\n<li><p><code>style</code> 多重值；</p>\n<pre><code class="hljs javascript">    &lt;div :style=<span class="hljs-string">"{ display: [\'-webkit-box\', \'-ms-flexbox\', \'flex\'] }"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>  这会渲染数组中最后一个被浏览器支持的值。</p>\n</li>\n<li><p>新增<code>.passive</code> 修饰符 (<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fvue-demo%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fdemo1.vue" target="_blank" rel="nofollow noopener noreferrer">demo1</a>) ； .passive 修饰符表示事件永远不会调用 preventDefault() ，主要为解决滚动和触摸事件的卡顿而出现，关于 passive 更多信息请移步 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FEventTarget%2FaddEventListener" target="_blank" rel="nofollow noopener noreferrer">MDN</a> 。</p>\n</li>\n</ul>\n<ul>\n<li><p>重新引入 <code>.sync</code> 修饰符  (<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fvue-demo%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fdemo2.vue" target="_blank" rel="nofollow noopener noreferrer">demo2</a>)；提供对于 prop 的双向绑定。</p>\n<pre><code class="hljs javascript">    &lt;child :bar.sync=<span class="hljs-string">"foo"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span></code></pre><p>  其实是个语法糖</p>\n<pre><code class="hljs javascript">    &lt;child :bar=<span class="hljs-string">"foo"</span> @update:bar=<span class="hljs-string">"e =&gt; foo = e"</span>&gt;</code></pre><p>  此时需要在子组件中显示触发事件：</p>\n<pre><code class="hljs javascript">    <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">\'update:bar\'</span>, newValue)</code></pre></li>\n</ul>\n<ul>\n<li><p>Async Component  Improvements (<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fvue-demo%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fdemo3.vue" target="_blank" rel="nofollow noopener noreferrer">demo3</a>);</p>\n<p>  在 2.3 之前，可以使用异步组件：</p>\n<pre><code class="hljs javascript">  <span class="hljs-comment">// some.vue</span>\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-comment">// ...</span>\n    components: {\n      <span class="hljs-string">\'asyncCom\'</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">\'./asyncCøm\'</span>)\n    }\n  }</code></pre><p>  2.3 新增高级异步组件</p>\n<p>  官网上比较清楚：</p>\n<p> </p><figure><img alt="" class="lazyload inited" data-src="https://github.com/jkchao/blog/raw/master/vue/async.png" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<p> 为了便于演示，使用延迟加载异步组件：</p>\n<pre><code class="hljs javascript">\n  <span class="hljs-keyword">import</span> loadingCom <span class="hljs-keyword">from</span> <span class="hljs-string">\'../components/loadingCom.vue\'</span>\n  <span class="hljs-keyword">import</span> errCom <span class="hljs-keyword">from</span> <span class="hljs-string">\'../components/errCom.vue\'</span>\n  <span class="hljs-keyword">const</span> asyncCom = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({\n    <span class="hljs-attr">component</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {\n        resolve(<span class="hljs-keyword">import</span>(<span class="hljs-string">\'../components/asyncCom.vue\'</span>))\n      }, <span class="hljs-number">2000</span>)\n    }),\n    <span class="hljs-attr">loading</span>: loadingCom,\n    <span class="hljs-attr">error</span>: errCom,\n    <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,\n    <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>\n  })\n\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-comment">// ...</span>\n    components: { asyncCom }\n  }</code></pre><p> 效果如下图：</p>\n<p> </p><figure><img alt="" class="lazyload inited" data-src="https://github.com/jkchao/blog/raw/master/vue/async1.gif" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<p> 或者，你也可以点击后加载 (<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fvue-demo%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fdemo4.vue" target="_blank" rel="nofollow noopener noreferrer">demo4</a>)：</p>\n<p> </p><figure><img alt="" class="lazyload inited" data-src="https://github.com/jkchao/blog/raw/master/vue/async2.gif" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<p> 当然，也可以用于 <code>vue-router</code> ( 2.40+ ) <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fvue-demo%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fdemo5.vue" target="_blank" rel="nofollow noopener noreferrer">demo5</a>。</p>\n</li>\n<li><p>Functional Component Improvements；</p>\n<p>在2.3 + 版本，函数式组件可以省略 <code>props</code> 选项，所有组件上的属性会被自动解析 成<code>props</code>，更多内容，请参考 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Frender-function.html%23%E5%87%BD%E6%95%B0%E5%8C%96%E7%BB%84%E4%BB%B6" target="_blank" rel="nofollow noopener noreferrer">cn.vuejs.org/v2/guide/re…</a> 。</p>\n</li>\n</ul>\n<h1 id="2-4" data-id="heading-1">2.4</h1>\n<ul>\n<li><code>v-on</code> 支持绑定一个事件／监听器键值对的对象，此时不支持任何修饰器；</li>\n</ul>\n<pre><code class="hljs javascript">  &lt;button v-on=<span class="hljs-string">"{ mousedown: some, mouseup: other }"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></code></pre><ul>\n<li>新增 <code>comments</code> 选项，当设为 <code>true</code> 时，将会保留且渲染模板中的 HTML 注释；<br>该选项暂时无法在构建工具中使用 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue%2Fissues%2F6177" target="_blank" rel="nofollow noopener noreferrer"> issues</a>。</li>\n</ul>\n<ul>\n<li><p>新增 <code>interitAttrs</code> 选项；</p>\n<p>  在版本 2.4 之前，默认情况下父作用域的不被作为<code>props</code>特性绑定的属性，将会作为普通的 HTML 属性，应用在跟元素上。</p>\n<p>  举个例子：</p>\n<pre><code class="hljs javascript">  <span class="hljs-comment">// parent.vue</span>\n  &lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">child-commpent</span> <span class="hljs-attr">:foo</span>=<span class="hljs-string">"f"</span> <span class="hljs-attr">:boo</span>=<span class="hljs-string">"b"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-comment</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n\n  &lt;script&gt;\n  <span class="hljs-keyword">const</span> childComment = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">\'./childCom.vue\'</span>)\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data () {\n      <span class="hljs-keyword">return</span> {\n        <span class="hljs-attr">f</span>: <span class="hljs-string">\'Hello world!\'</span>\n        b: <span class="hljs-string">\'Hello Vue!\'</span>\n      }  \n    }\n  }\n  &lt;<span class="hljs-regexp">/script&gt;</span></code></pre><pre><code class="hljs javascript">  <span class="hljs-comment">// childComment.vue</span>\n  &lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ foo }}<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>\n\n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">props</span>: [<span class="hljs-string">\'foo\'</span>]\n  }\n  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre><p>  最后会被渲染为：</p>\n<pre><code class="hljs javascript">  &lt;div boo=<span class="hljs-string">"Hello Vue!"</span>&gt;Hello world!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>  设置 <code>interitAttrs</code> 为 <code>false</code>，之后，不会应用到跟元素上。</p>\n<pre><code class="hljs javascript">  // childCom.vue\n  &lt;template&gt;\n    &lt;div&gt;{{ foo }}&lt;/div&gt;\n  &lt;/template&gt;\n\n  &lt;script&gt;\n  export default {\n    props: [\'foo\'],\n    inheritAttrs: false\n  }\n  &lt;/script&gt;</code></pre><p>  渲染：</p>\n<pre><code class="hljs javascript">\n  &lt;div&gt;Hello world!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre></li>\n<li><p>新增 <code>$attrs, $listeners</code> 选项；</p>\n<p>  多级组件嵌套需要传递数据时，通常使用的方法是通过 <code>vuex</code> 。如果仅仅是传递数据，而不做中间处理，使用 <code>vuex</code> 处理，未免有点杀鸡用牛刀，Vue 2.4 版本提供了另一种方法，使用 <code>v-bind="$attrs"</code>, 将父组件中不被认为 <code>props</code>特性绑定的属性传入子组件中，通常配合 <code>interitAttrs</code> 选项一起使用，具体请看 demo 。</p>\n<pre><code class="hljs javascript">  <span class="hljs-comment">// demo.vue</span>\n  &lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">child-com</span> <span class="hljs-attr">:foo</span>=<span class="hljs-string">"foo"</span> <span class="hljs-attr">:boo</span>=<span class="hljs-string">"boo"</span> <span class="hljs-attr">:coo</span>=<span class="hljs-string">"coo"</span> <span class="hljs-attr">:doo</span>=<span class="hljs-string">"doo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-com</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">tempalte</span>&gt;</span></span>\n  &lt;script&gt;\n  <span class="hljs-keyword">const</span> childCom = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">\'./childCom1.vue\'</span>)\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    data () {\n      <span class="hljs-keyword">return</span> {\n        <span class="hljs-attr">foo</span>: <span class="hljs-string">\'Hello World!\'</span>,\n        <span class="hljs-attr">boo</span>: <span class="hljs-string">\'Hello Javascript!\'</span>,\n        <span class="hljs-attr">coo</span>: <span class="hljs-string">\'Hello Vue\'</span>,\n        <span class="hljs-attr">doo</span>: <span class="hljs-string">\'Last\'</span>\n      }\n    },\n    <span class="hljs-attr">components</span>: { childCom }\n  }\n  &lt;<span class="hljs-regexp">/script&gt;</span></code></pre><pre><code class="hljs javascript">  <span class="hljs-comment">// childCom1.vue</span>\n  &lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>foo: {{ foo }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>attrs: {{ $attrs }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n      <span class="hljs-tag">&lt;<span class="hljs-name">child-com2</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-com2</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n  &lt;script&gt;\n  <span class="hljs-keyword">const</span> childCom2 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">\'./childCom2.vue\'</span>)\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">props</span>: [<span class="hljs-string">\'foo\'</span>],\n    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,\n    created () {\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$attrs) <span class="hljs-comment">// { boo: \'Hello Javascript!\', coo: \'Hello Vue\', doo: \'Last\' }</span>\n    }\n  }\n  &lt;<span class="hljs-regexp">/script&gt;</span></code></pre><pre><code class="hljs javascript">  <span class="hljs-comment">// childCom2.vue</span>\n  &lt;template&gt;\n    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>boo: {{ boo }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>attrs: {{ $attrs }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n     <span class="hljs-tag">&lt;<span class="hljs-name">child-com3</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-com3</span>&gt;</span>\n    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>\n\n  &lt;script&gt;\n  <span class="hljs-keyword">const</span> childCom3 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">\'./childCom3.vue\'</span>)\n  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {\n    <span class="hljs-attr">props</span>: [<span class="hljs-string">\'boo\'</span>]\n    inheritAttrs: <span class="hljs-literal">false</span>,\n    created () {\n      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$attrs) <span class="hljs-comment">// { coo: \'Hello Vue\', doo: \'Last\' }</span>\n    }\n  }\n  &lt;<span class="hljs-regexp">/script&gt;</span></code></pre><pre><code class="hljs javascript">  <span class="hljs-comment">// childCom3.vue</span>\n  <span class="hljs-comment">// ...</span></code></pre><p>  最后被渲染为</p>\n<p>  </p><figure><img alt="" class="lazyload inited" data-src="https://github.com/jkchao/blog/raw/master/vue/render.png" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<p>  具体请看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fvue-demo%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fdemo6.vue" target="_blank" rel="nofollow noopener noreferrer">demo6</a> 。</p>\n<p>  <code>$listeners</code> 的用法和 <code>$attrs</code> 类似，<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fjkchao%2Fvue-demo%2Fblob%2Fmaster%2Fsrc%2Fviews%2Fdemo6.vue" target="_blank" rel="nofollow noopener noreferrer">demo6</a> 。</p>\n</li>\n</ul>\n<hr>\n<p>完。</p>\n</div>',__v:0},{tags:["Node.js","Facebook","API","前端","后端","GraphQL"],meta:{updateAt:"2018-02-09T05:06:21.632Z",createAt:"2018-02-09T05:06:21.632Z"},_id:"5a7d2c4da7d59115dcd1f2dd",id:"59fbd88e51882576ea350c53",title:"GraphQL 初探—面向未来 API 及其生态圈",avatar:"https://dn-mhke0kuv.qbox.me/8132eeef2c3edd765d6a.jpg?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1",author:"美团点评点餐",create_time:"2017 年 11 月 03 日",content:'<div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container"><div></div><p>什么是<a href="https://link.juejin.im?target=http%3A%2F%2Fgraphql.org%2F" target="_blank" rel="nofollow noopener noreferrer"> GraphQL </a>？第一次看到这个名词未免让人联想到数据库查询语言 SQL 。但本质上，这是两个完全不同的东西， GraphQL 在官方文档里的定义如下：</p><blockquote><p>GraphQL is a query language for your API, and a server-side runtime for executing queries by using a type system you define for your data.</p></blockquote><p>即 GraphQL 既是一个 API 查询语言，也指其服务端实现。但 GraphQL 不只是为了在 API 领域搞个类似数据库的查询语言，它的诞生更涉及到 API 设计的思路转变。</p><h2 data-id="heading-0">REST 模式的难题</h2><p>通常，一项新技术的产生都会伴随着两个背景，一个是该技术所在的领域出现了新趋势、二是原有的技术难以应对新趋势。而近几年， API 领域有几个趋势愈发值得关注：</p><p>首先是日益增多的移动端应用，和移动端性能本身较低下的矛盾，要求数据加载过程更高效。</p><p>再者，要满足客户端和前端快速开发、快速添加特性的需求， API 必须能快速拓展。</p><p>第三则是各种不同的前端框架和平台层出不穷，而后端 API 服务面对众多的前端框架、乃至前端和客户端共享 API 的情况，其能否按需提供数据，会影响接口复用度和开发效率。</p><p>而现如今在 API 领域被广泛使用的<a href="https://link.juejin.im?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRepresentational_state_transfer" target="_blank" rel="nofollow noopener noreferrer"> REST 模式</a>，面对上述愈发复杂的客户端和服务端交互，问题也渐渐浮现：</p><p>首先是接口灵活性差。由于设计接口粒度较粗或历史遗留原因，接口中有时会存在当前数据交互不需要的字段，导致取到无用且多余的数据；而另一方面，有时前端需要一份数据，却需要手动访问多个接口才能完整获取。</p><p>第二是接口操作流程繁琐，回想下前端获取数据的过程，通常我们要先构造 HTTP 请求，然后接收和解析服务端响应。有时还要对收到的或处理后的数据另作本地数据转储，最后才进行 UI 展示。</p><p>第三，随着客户端功能拓展，服务端不断增加接口。这样维护众多接口，不仅服务端维护成本高，此外也不能按需提供数据、阻碍了客户端的快速迭代和拓展。</p><p>还有 REST 模式实质上是基于 HTTP 协议的，这虽让其易于被 Web 开发人员理解和上手，但也决定它不能灵活选择网络协议来解决问题。</p><h2 data-id="heading-1">GraphQL 的解决方案</h2><p>面对 REST 模式的上述不足， Facebook 提出了他们的解决方案 – GraphQL ：</p><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/cbadb185098b113147683daa45664122?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><p>前面提到 GraphQL 既是一个 API 查询语言，也指其服务端实现，所以 GraphQL 本身也由两部分组成，Facebook 将它们分别<a href="https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2F%40leeb%2Frelicensing-the-graphql-specification-e7d07a52301b" target="_blank" rel="nofollow noopener noreferrer">开源</a>：</p><ul><li>语言标准： <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.openwebfoundation.org%2Flegal%2Fthe-owf-1-0-agreements%2Fowfa-1-0" target="_blank" rel="nofollow noopener noreferrer">Open Web Foundation Agreement (OWFa) v1.0 协议</a></li><li>GraphQL.js、客户端工具Relay： MIT 协议</li></ul><p>我们来逐条了解下 GraphQL 的特性：</p><h3 data-id="heading-2">声明式的数据获取</h3><p>如下图所示，声明式的数据查询带来了接口的精确返回，服务器会按数据查询的格式返回同样结构的 JSON 数据、真正照顾了客户端的灵活性：</p><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/26a7b768142ecdd3dacec2ae61ec0bbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><p>另外，这种数据获取方式也带来更简洁的数据查询流程。 GraphQL 认为，客户端只需描述查询结构发起查询，再把服务端响应数据用于 UI 展示即可。中间构造请求和转储数据的操作可以交由 GraphQL 客户端辅助完成。</p><h3 data-id="heading-3">一个服务仅暴露一个 GraphQL 层</h3><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/6cfce8faa6341c68636feb61dfd6fbfe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><p>上图是一个 GraphQL 应用的基本架构，其中客户端只和 GraphQL 层进行 API 交互，而 GraphQL 层再往后接入各种数据源。这样一来，只要是数据源有的数据， GraphQL 层都可以让客户端按需获取，不必专门再去定接口了。</p><h3 data-id="heading-4">传输层无关、数据库技术无关</h3><p>带来了更灵活的技术栈选择，比如我们可以选择对移动设备友好的协议，将网络传输数据量最小化，实现在网络协议层面优化应用。</p><h2 data-id="heading-5">GraphQL 接入概览</h2><p>既然 GraphQL 有诸多优点，那又该如何接入呢？大体上，有三种接入的方式：</p><h3 data-id="heading-6">直连数据库的GraphQL服务</h3><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/8b4ca9db43f8f223fe0f1f304e051db8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><p>最为简洁的服务配置，直接操作数据库也能减少中间环节的性能损耗。</p><h3 data-id="heading-7">集成现有服务的GraphQL层</h3><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/3269c3eef1257d5196b747e2dfe7c01e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><p>这种配置适合于旧服务的改造，尤其是在涉及第三方服务时、依然可以通过原有接口进行交互。</p><h3 data-id="heading-8">直连数据库和集成服务的混合模式</h3><p>前两种方式的混合：</p><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/2d3ebcaf728d83d65b3fb1ec4fe91879?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><h2 data-id="heading-9">GraphQL 核心概念浅析</h2><p>GraphQL 的一大特点便是声明式的 API Schema ，GraphQL 的 Schema 是一个声明式的查询规范（可认为是服务器和客户端间的一个查询协议），它主要由两部分组成：</p><ul><li>类型系统</li><li>编写语法：SDL（视图定义语言）</li></ul><p>GraphQL 的类型系统包含了各编程语言中通用的一些数据类型，具体可参考<a href="https://link.juejin.im?target=http%3A%2F%2Ffacebook.github.io%2Fgraphql%2FOctober2016%2F%23sec-Type-System" target="_blank" rel="nofollow noopener noreferrer">规范文档</a>了解。</p><p>接下来简单介绍下 GraphQL 的 SDL 语法：</p><h3 data-id="heading-10">定义 API Schema</h3><p>自定义类型的定义主要是在服务端完成的，语法如下：</p><pre class="hljs bash"><code><span class="hljs-built_in">type</span> 类型名 {\n    字段名: 类型\n}\n</code></pre><p>此外， GraphQL 还有 <code>Query</code>, <code>Mutation</code>, <code>Subscription</code> 等特殊的根类型，用于定义 API Schema 。我们可以定义一个用户：</p><pre class="hljs bash"><code><span class="hljs-built_in">type</span> User {\n    id: Int!\n    name: String\n}\n</code></pre><p>然后定义几个用于数据操作的 API Schema ：</p><pre class="hljs bash"><code><span class="hljs-built_in">type</span> Query { // 基本查询 Schema\n    user(id: Int!): User // 传入一个 id ，返回具体用户\n}\n\n<span class="hljs-built_in">type</span> Mutation { // 操作数据的 Schema\n    createUser( // 传入用户名自动创建一个用户\n        name: String\n    ): User\n}\n\n<span class="hljs-built_in">type</span> Subscription { // 监听数据变更的 Schema\n    userChanged: User\n}\n</code></pre><h3 data-id="heading-11">数据操作</h3><p>有了这些定义好的 API Schema ，我们就可以此来发起数据操作了。 GraphQL 的数据操作也分为 <code>Query</code>, <code>Mutation</code>, <code>Subscription</code> 三种类型。简单来讲， <code>Query</code> 就是获取数据的基本查询；<code>Mutation</code> 支持对数据的增、删、改等操作；而 <code>Subscription</code> 则用于监听数据变动、并靠 Websocket 等协议推送变动的消息给订阅方。</p><p>基于前面的定义的用户 Schema ，我们可以写出如下的数据操作：</p><pre class="hljs bash"><code>query {\n  user(id:3) { // 查询用户 id 为3的用户\n    name\n  }\n}\n\nmutation {\n  createUser(name: <span class="hljs-string">"Tom"</span>) { // 新增一个名为 <span class="hljs-string">"Tom"</span> 的用户\n    name\n    id\n  }\n}\n\nsubscription {\n  userChanged { // 监听用户数据变动\n    name\n    id\n  }\n}\n</code></pre><p>上面这些查询，根字段之后的所有内容称为查询的 payload 。服务端会按查询格式，在 <code>data</code> 字段返回 payload 中指定的数据，比如 <code>createUser</code> 这个操作就会返回如下的数据：</p><pre class="hljs bash"><code>{\n  <span class="hljs-string">"data"</span>: {\n    <span class="hljs-string">"createUser"</span>: {\n      <span class="hljs-string">"name"</span>: <span class="hljs-string">"Tom"</span>,\n      <span class="hljs-string">"id"</span>: 9\n    }\n  }\n}\n</code></pre><h2 data-id="heading-12">GraphQL 生态圈</h2><p>通过 API Schema，我们既可指定 API 功能、同时也能定义客户端如何请求数据。但前面介绍的只是个规范，而这个 GraphQL 的规范又是如何落地实现的呢？接下来会围绕服务端、客户端、调试工具，介绍下 GraphQL 应用开发的 “生态圈”。</p><h3 data-id="heading-13">服务端实现</h3><p>在服务端， GraphQL 服务器可用任何可构建 Web 服务器的语言实现。除 JavaScript 之外， Ruby ， Python ， Scala ， Java ， Clojure ， Go 和 .NET 都有实现供参考。</p><p>服务端查询执行的核心算法也很简单：就是查询逐字段遍历，并为各字段执行一个 resolver 以处理数据操作。下图举了一个例子：</p><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/6bb578106e51fab277a644a57685b8a3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><p>最左边为一个 GraphQL 查询，该语句查询了 id 为 <code>\'abc\'</code> 的作者所有文章的标题和内容。中间一副图展示了每个查询字段对应的数据类型，然后在最右边可看到每个字段的解析过程：首先查询 id 为 <code>\'abc\'</code> 的作者，再从该作者处获取其所有文章；而由于文章是一个列表，最后我们还要遍历这个列表以获取各文章对应的标题、内容。</p><p>这个逐字段解析的流程清晰易懂，但如果服务器只是这么实现的话，就会面临性能问题。见下图的例子，若用户要查询文章列表下各个作者的信息，由于文章列表中可能有大量重复的作者，当处理到同一作者的文章时就要重复查询该作者信息，甚至当“查询作者信息”这操作本身就包含大量子操作的话、对服务器性能的消耗就非常可观：</p><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/a217006a52668c89346f86cc97033867?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><p>对这种一个查询触发大量相同的数据操作的问题，一种解决思路是将数据操作改为批量处理。还是用上面的例子，下图中我们把查询作者信息的操作改为存入一个队列，待合适的时机再批量发起查询，这时查询的数量就只是队列里的一个最小子集，避免了重复操作。 Facebook 推出的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fdataloader" target="_blank" rel="nofollow noopener noreferrer"> DataLoder </a>就是一个这样的数据批量处理和缓存的方案。</p><p><img alt="" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/3/74b018279d630b7f1f45a2f9cc19f185?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="600" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;"></p><p>上面讨论了 GraphQL 服务端的基本实现思路，而针对 Node.js 的实现，我基于前文示例中的 API Schema 写了一个简单的 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Flevonlin%2Fgraphql-server-demo" target="_blank" rel="nofollow noopener noreferrer">Demo</a> ，读者可了解下 GraphQL 的服务端具体是如何实现和使用的。</p><h3 data-id="heading-14">客户端实现</h3><p>常见的 GraphQL 客户端库有：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Ffacebook.github.io%2Frelay%2F" target="_blank" rel="nofollow noopener noreferrer">Relay</a>：Facebook 官方的 GraphQL 客户端，它大大优化了性能，但只能在 Web 上可用</li><li><a href="https://link.juejin.im?target=http%3A%2F%2Fdev.apollodata.com%2F" target="_blank" rel="nofollow noopener noreferrer">Apollo</a>：一个开源社区项目，旨在为所有开发平台（Web, 安卓, iOS , React Native 等）构建强大而灵活的 GraphQL 客户端</li></ul><p>至于如何使用这两个客户端库，可以参考官方文档，这里不再赘述。而对于 Apollo 的入门，<a href="https://link.juejin.im?target=https%3A%2F%2Fdev-blog.apollodata.com%2Ffull-stack-react-graphql-tutorial-582ac8d24e3b" target="_blank" rel="nofollow noopener noreferrer"> Full-stack React + GraphQL Tutorial </a>一文提供了深入浅出的示例，建议动手尝试下，构建自己第一个 GraphQL 应用吧。</p><h3 data-id="heading-15">开发工具</h3><p>GraphQL 有大量实用的开发工具，基本都是基于 introspection 查询实现的。所谓 introspection 查询，就是指客户端向服务器询问 API Schema 信息的查询。比如，我们可以通过查询 <code>__schema</code> 等元字段来获取完整的类型信息：</p><pre class="hljs bash"><code>query {\n  __schema {\n    types {\n      name // 获取根字段名\n      fields {\n        name // 获取字段名\n      }\n    }\n  }\n}\n</code></pre><p>有了这样一个查询 Schema 信息的功能，就使得 GraphQL 的文档浏览器，自动补全，代码生成等开发工具非常容易实现。而开发工具中，最有名的就是 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgraphql%2Fgraphiql" target="_blank" rel="nofollow noopener noreferrer">GraphiQL</a> 了，其本质上可认为是个 GraphQL 客户端，但配有编辑、自动补全、文档浏览等功能，常用于服务端的调试。</p><p>前面我们那个<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Flevonlin%2Fgraphql-server-demo" target="_blank" rel="nofollow noopener noreferrer">服务端 Demo </a>也以中间件形式引入了基于 GraphiQL 的调试工具 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgraphcool%2Fgraphql-playground" target="_blank" rel="nofollow noopener noreferrer">GraphQL PlayGround </a>。运行 Demo 后，你可以访问 <code>localhost:3000/playground</code> 试试上面列举的所有查询~</p><h2 data-id="heading-16">GraphQL 存在的问题</h2><p>当然， GraphQL 也不是完美无缺的，现在 GraphQL 主要存在安全性和服务端缓存能力两方面的问题。</p><h3 data-id="heading-17">安全问题</h3><p>GraphQL 声明式的的数据查询提供了灵活、易拓展的接口；但如果我们发起的一次查询包含了过多的数据操作，那么这一次查询就会给数据服务器的带来巨大的压力，提升了被 DDOS 的风险。</p><p>此外，每次发起的查询语句，实质上也反映了查询文档的结构，如果被攻击者截取了我们的请求、拼凑出完整的接口内容，这也不利于接口的安全。</p><p>面对查询压力，我们可以通过服务端限流、客户端限流等措施来进行缓解，具体限流的措施可参见<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011059162" target="_blank" rel="nofollow noopener noreferrer">这篇文章</a>。</p><p>而对于 API 结构公开传输的问题，有人提出一个<a href="https://link.juejin.im?target=https%3A%2F%2Fdev-blog.apollodata.com%2Fpersisted-graphql-queries-with-apollo-client-119fd7e6bba5" target="_blank" rel="nofollow noopener noreferrer">持久化查询</a>的方案。简单来讲，就是客户端和服务端分别将约定好查询内容转换为查询ID，转而使用查询ID进行查询。这样一来既解决了查询语句公开传输的问题，而只传 ID 还顺便减少了传输的数据量、提升了传输速度。</p><h3 data-id="heading-18">服务端缓存能力</h3><p>GraphQL 能让客户端灵活地请求数据，这就样一来客户端请求内容就是不确定的，服务端难以根据同一个连接来维护查询缓存。</p><p>关于这个问题，前面提到 Facebook 有一个<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fdataloader" target="_blank" rel="nofollow noopener noreferrer"> DataLoader </a>的技术，可用于实现查询的批量处理和缓存，但其文档中描述的缓存也只是针对单个请求进行、粒度还是较粗。</p><h2 data-id="heading-19">总结</h2><p>GraphQL 作为一个新的 API 标准，通过声明式的数据获取方式，给客户端提供了简洁、灵活、高效的数据查询。适应了移动互联网时代客户端技术的快速发展和需求的快速迭代，是当前 REST 模式的有力竞争者。</p><p>同时其活跃的社区和日渐成熟的生态圈也证明了这是一个很有生命力的技术，目前 GraphQL 已被许多的公司（ Facebook ， GitHub ， Twitter 等等）用于生产环境中，相信其未来还有很大的发展前景。</p><p>但 GraphQL 自身存在的安全性等问题也不容忽视；此外引入 GraphQL 势必存在学习成本，在 API 设计思想上的变化页还会影响到相应的开发模式、开发流程。所以只有权衡好引入成本和收益，才能让这项新技术用在刀刃上。</p><h2 data-id="heading-20">Ref</h2><p><a href="https://link.juejin.im?target=http%3A%2F%2Fgraphql.org%2Flearn%2F" target="_blank" rel="nofollow noopener noreferrer">官方文档</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000010259012" target="_blank" rel="nofollow noopener noreferrer">[译] 怎样使用GraphQL（文中架构图引用自该教程）</a></p><p><br></p></div>',__v:0},{tags:["Vue.js","CSS","JavaScript"],meta:{updateAt:"2018-02-09T05:06:21.632Z",createAt:"2018-02-09T05:06:21.632Z"},_id:"5a7d2c4da7d59115dcd1f2dc",id:"5a121e4b6fb9a045076f41a3",title:"也许 Vue+CSS3 做交互特效更简单",avatar:"https://user-gold-cdn.xitu.io/2017/7/18/64d82b70650d11ed806f611d929c7b1e?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1",author:"守候i",create_time:"2017 年 11 月 20 日",content:'<div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container"><h2 data-id="heading-0">1.前言</h2><p>做项目就难免会开发交互效果或者特效，而我最近开发的项目一直在使用<code>vue</code>，开发技术栈方面，理所当然就使用了<code>vue</code>+<code>css3</code>开发，过程中发现使用<code>vue</code>+<code>css3</code>开发特效，和<code>javascript</code>/<code>jquery</code>+<code>css3</code>的思维方式不一样，但是比<code>javascript</code>/<code>jquery</code>+<code>css3</code>简单一点点。今天就分享三个简单的小实例，希望能起到拓展思维的作用，让大家明白vue+css3应该怎样开发交互效果！如果大家有什么好的建议，或者觉得我哪里写错了，欢迎指出！</p><blockquote><p>1.文章上面的代码，虽然代码很简单，不难理解，但是也是建议大家边写边看，这样不会混乱。<br>2.文章所提及的小实例，都是很基础的，大家可以参照自己的想法进行扩展，或者修改，可能会有意想不到的效果。我写这类型的文章也是想授人以渔，不是授人以鱼！<br>3.这几个实例，摘自我自己的平常练习的项目，代码已经提到github上面了(<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FchenhuiYj%2Fdemos%2Ftree%2Fmaster%2Fvue-demos" target="_blank" rel="nofollow noopener noreferrer">vue-demos</a>)。欢迎大家star。</p></blockquote><h2 data-id="heading-1">2.开场小动画</h2><h3 data-id="heading-2">运行效果</h3><p>gif图模糊效果看着跟实际效果不太一样！大家注意！</p><p><img class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c6920ea81c9?imageslim" data-width="800" data-height="146" src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c6920ea81c9?imageslim"></p><h3 data-id="heading-3">原理分析</h3><p>说到原理分析，其实也没什么可以分析的，就是在页面是下面这个状态的时候，把文字替换掉。至于看到字体缩成一团，就是<code>letter-spacing</code>这个<code>css</code>属性的控制效果。字体模糊就是<code>filter: blur()</code>这个<code>css</code>属性的控制效果！看到有逐渐的变化，就是css3动画（<code>animation</code>）的效果</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c691876a3ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="144" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;144&quot;&gt;&lt;/svg&gt;"></p><p>下面简单分析下，这个动画的几个步骤，从下面看到，这个动画一共8个步骤。</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c694a4e7487?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="440" data-height="704" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;440&quot; height=&quot;704&quot;&gt;&lt;/svg&gt;"></p><p>这下就清晰明了了，我们要在下图这个瞬间开始改变文字，也就是页面加载了两秒后，动画执行了两次后就开始改变文字。然后每隔两秒改变一次文字，直到最后！</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c691b1f4869?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="426" data-height="91" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;426&quot; height=&quot;91&quot;&gt;&lt;/svg&gt;"></p><p>下面给出<code>vue</code>和<code>javascript</code>两种方式的代码，看下哪种方式更加的简单！</p><h3 data-id="heading-4">vue方式</h3><pre class="hljs bash"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="hljs-string">"en"</span>&gt;\n&lt;head&gt;\n    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n    body{\n        background: <span class="hljs-comment">#ccc;</span>\n    }\n    h1 {\n        color: white;\n        text-transform: uppercase;\n        margin-top: 100px;\n        text-align: center;\n        font-size: 6rem;\n        line-height: 1;\n        animation: letterspacing 1s 7 alternate ease-in-out;\n        display: block;\n        letter-spacing: .5rem;\n    }\n\n    @keyframes letterspacing {\n        0% {\n            letter-spacing: -72px;\n            filter: blur(20px);\n        }\n\n        40% {\n            filter: blur(6px);\n        }\n\n        80% {\n            letter-spacing: 8px;\n            filter: blur(0);\n        }\n    }\n&lt;/style&gt;\n&lt;body&gt;\n&lt;div id=<span class="hljs-string">"text"</span>&gt;\n    &lt;h1&gt;{{<span class="hljs-built_in">test</span>Text}}&lt;/h1&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;script src=<span class="hljs-string">"vue.min.js"</span>&gt;&lt;/script&gt;\n&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;\n    new Vue({\n        el:<span class="hljs-string">\'#text\'</span>,\n        data:{\n            nowIndex:0,\n            <span class="hljs-built_in">test</span>Text:<span class="hljs-string">\'欢迎浏览\'</span>\n        },\n        <span class="hljs-function"><span class="hljs-title">mounted</span></span>(){\n            <span class="hljs-built_in">let</span> _this=this;\n            <span class="hljs-built_in">let</span> timer = <span class="hljs-built_in">set</span>Interval(<span class="hljs-function"><span class="hljs-title">function</span></span>(){\n                _this.nowIndex++;\n                switch (_this.nowIndex) {\n                    <span class="hljs-keyword">case</span> 1:\n                        _this.testText = <span class="hljs-string">\'守候的文章\'</span>;\n                        <span class="hljs-built_in">break</span>;\n                    <span class="hljs-keyword">case</span> 2:\n                        _this.testText = <span class="hljs-string">\'愿您浏览愉快\'</span>;\n                        <span class="hljs-built_in">break</span>;\n                    <span class="hljs-keyword">case</span> 3:\n                        _this.testText = <span class="hljs-string">\'学到知识\'</span>;\n                        <span class="hljs-built_in">break</span>;\n                }\n                <span class="hljs-keyword">if</span> (_this.nowIndex &gt; 3) {\n                    <span class="hljs-built_in">set</span>Timeout(() =&gt; {\n                        clearInterval(timer);\n                    }, 2000)\n                }\n            }, 2000)\n        }\n    })\n&lt;/script&gt;\n&lt;/html&gt;</code></pre><h3 data-id="heading-5">javascript方式</h3><pre class="hljs bash"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="hljs-string">"en"</span>&gt;\n&lt;head&gt;\n    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n    body{\n        background: <span class="hljs-comment">#ccc;</span>\n    }\n    h1 {\n        color: white;\n        text-transform: uppercase;\n        margin-top: 100px;\n        text-align: center;\n        font-size: 6rem;\n        line-height: 1;\n        animation: letterspacing 1s 7 alternate ease-in-out;\n        display: block;\n        letter-spacing: .5rem;\n    }\n\n    @keyframes letterspacing {\n        0% {\n            letter-spacing: -6rem;\n            filter: blur(1rem);\n        }\n\n        40% {\n            filter: blur(.3rem);\n        }\n\n        80% {\n            letter-spacing: .5rem;\n            filter: blur(0rem);\n        }\n    }\n&lt;/style&gt;\n&lt;body&gt;\n&lt;div id=<span class="hljs-string">"text"</span>&gt;\n    &lt;h1&gt;欢迎浏览&lt;/h1&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n    var oH1=document.querySelector(<span class="hljs-string">\'h1\'</span>),nowIndex=0;\n    console.log(oH1)\n    var timer = <span class="hljs-built_in">set</span>Interval(<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n        nowIndex++;\n        switch (nowIndex) {\n            <span class="hljs-keyword">case</span> 1:\n                oH1.innerHTML = <span class="hljs-string">\'守候的文章\'</span>;\n                <span class="hljs-built_in">break</span>;\n            <span class="hljs-keyword">case</span> 2:\n                oH1.innerHTML = <span class="hljs-string">\'愿您浏览愉快\'</span>;\n                <span class="hljs-built_in">break</span>;\n            <span class="hljs-keyword">case</span> 3:\n                oH1.innerHTML = <span class="hljs-string">\'学到知识\'</span>;\n                <span class="hljs-built_in">break</span>;\n        }\n        <span class="hljs-keyword">if</span> (nowIndex &gt; 3) {\n            <span class="hljs-built_in">set</span>Timeout(() =&gt; {\n                clearInterval(timer);\n            }, 2000)\n        }\n    }, 2000)\n&lt;/script&gt;\n&lt;/html&gt;</code></pre><h2 data-id="heading-6">3.导航滑块</h2><h3 data-id="heading-7">运行效果</h3><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c695c255d9c?imageslim" data-width="800" data-height="126" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;126&quot;&gt;&lt;/svg&gt;"></p><h3 data-id="heading-8">原理分析</h3><p>首先，下面是页面初始化的时候，橙色滑块的位置</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c694813ca84?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="691" data-height="46" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;691&quot; height=&quot;46&quot;&gt;&lt;/svg&gt;"></p><p>鼠标放到第二个tab上面，大家可以看到，橙色滑块就是向右偏移了一个tab的距离</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c69ac27319b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="650" data-height="68" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;650&quot; height=&quot;68&quot;&gt;&lt;/svg&gt;"></p><p>鼠标放到第三个tab上面，大家可以看到，橙色滑块就是向右偏移了两个tab的距离</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c69e2ea91a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="652" data-height="113" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;652&quot; height=&quot;113&quot;&gt;&lt;/svg&gt;"></p><p>如果从第一个tab到第六个tab的索引是0,1,2,3,4,5。</p><p>那么滑块的公式就是（索引*tab的宽度）。大家看到有逐渐过去的效果，其实是css3过渡（<code>transition</code>）的效果。大家看下面的代码就行了，一看就懂！代码如下：</p><h3 data-id="heading-9">vue方式</h3><pre class="hljs bash"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="hljs-string">"en"</span>&gt;\n&lt;head&gt;\n    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"reset.css"</span>&gt;\n&lt;style&gt;\n    .nav{\n        margin: 40px;\n        position: relative;\n    }\n.nav li{\n    <span class="hljs-built_in">float</span>: left;\n    width: 100px;\n    height: 40px;\n    line-height: 40px;\n    color: <span class="hljs-comment">#fff;</span>\n    text-align: center;\n    background: <span class="hljs-comment">#09f;</span>\n    cursor: pointer;\n}\n    .nav span{\n        position: relative;\n        z-index: 2;\n    }\n    .nav .slider{\n        position: absolute;\n        transition: all .5s cubic-bezier(0.4, -0.3, 0.57, 1.38);\n        width: 100px;\n        height: 40px;\n        background: <span class="hljs-comment">#f90;</span>\n        top: 0;\n        left: 0;\n        z-index: 1;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n&lt;div class=<span class="hljs-string">"nav clear"</span> id=<span class="hljs-string">"nav"</span> @mouseleave=<span class="hljs-string">"nowIndex=0"</span>&gt;\n    &lt;ul&gt;\n        &lt;li @mouseenter.stop=<span class="hljs-string">"nowIndex=0"</span>&gt;&lt;span&gt;Tab One&lt;/span&gt;&lt;/li&gt;\n        &lt;li @mouseenter.stop=<span class="hljs-string">"nowIndex=1"</span>&gt;&lt;span&gt;Tab Two&lt;/span&gt;&lt;/li&gt;\n        &lt;li @mouseenter.stop=<span class="hljs-string">"nowIndex=2"</span>&gt;&lt;span&gt;Tab Three&lt;/span&gt;&lt;/li&gt;\n        &lt;li @mouseenter.stop=<span class="hljs-string">"nowIndex=3"</span>&gt;&lt;span&gt;Tab four&lt;/span&gt;&lt;/li&gt;\n        &lt;li @mouseenter.stop=<span class="hljs-string">"nowIndex=4"</span>&gt;&lt;span&gt;Tab five&lt;/span&gt;&lt;/li&gt;\n        &lt;li @mouseenter.stop=<span class="hljs-string">"nowIndex=5"</span>&gt;&lt;span&gt;Tab six&lt;/span&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div class=<span class="hljs-string">"slider"</span> :style=<span class="hljs-string">"{\'transform\':\'translate3d(\'+nowIndex*100+\'px,0,0)\'}"</span>&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;script src=<span class="hljs-string">"vue.min.js"</span>&gt;&lt;/script&gt;\n&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;\n   new Vue({\n       el:<span class="hljs-string">\'#nav\'</span>,\n       data:{\n           nowIndex:0\n       }\n   })\n&lt;/script&gt;\n&lt;/html&gt;</code></pre><h3 data-id="heading-10">javascript方式</h3><pre class="hljs bash"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="hljs-string">"en"</span>&gt;\n&lt;head&gt;\n    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"reset.css"</span>&gt;\n&lt;style&gt;\n    .nav{\n        position: relative;\n    }\n.nav li{\n    <span class="hljs-built_in">float</span>: left;\n    width: 100px;\n    height: 40px;\n    line-height: 40px;\n    color: <span class="hljs-comment">#fff;</span>\n    text-align: center;\n    background: <span class="hljs-comment">#09f;</span>\n    cursor: pointer;\n}\n    .nav span{\n        position: relative;\n        z-index: 2;\n    }\n    .nav .slider{\n        position: absolute;\n        transition: all .5s cubic-bezier(0.4, -0.3, 0.57, 1.38);\n        width: 100px;\n        height: 40px;\n        background: <span class="hljs-comment">#f90;</span>\n        top: 0;\n        left: 0;\n        z-index: 1;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n&lt;div class=<span class="hljs-string">"nav clear"</span> id=<span class="hljs-string">"nav"</span>&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;span&gt;Tab One&lt;/span&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;span&gt;Tab Two&lt;/span&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;span&gt;Tab Three&lt;/span&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;span&gt;Tab four&lt;/span&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;span&gt;Tab five&lt;/span&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;span&gt;Tab six&lt;/span&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div class=<span class="hljs-string">"slider"</span>&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;\n    var oDiv=document.querySelector(<span class="hljs-string">"#nav"</span>),oLi=oDiv.querySelectorAll(<span class="hljs-string">"li"</span>),oSlider=document.querySelector(<span class="hljs-string">".slider"</span>);\n    oDiv.addEventListener(<span class="hljs-string">"mouseleave"</span>,<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n        oSlider.style.transform=<span class="hljs-string">\'translate3d(0,0,0)\'</span>;\n    })\n    <span class="hljs-keyword">for</span>(var i=0;i&lt;oLi.length;i++){\n        oLi[i].index=i;\n        oLi[i].addEventListener(<span class="hljs-string">"mouseenter"</span>,<span class="hljs-keyword">function</span> (e) {\n            oSlider.style.transform=<span class="hljs-string">\'translate3d(\'</span>+this.index*100+<span class="hljs-string">\'px,0,0)\'</span>;\n        })\n    }\n&lt;/script&gt;\n&lt;/html&gt;</code></pre><h2 data-id="heading-11">4.轮播图</h2><h3 data-id="heading-12">运行效果</h3><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c6a09676e46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="402" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;402&quot;&gt;&lt;/svg&gt;"></p><h3 data-id="heading-13">原理分析</h3><p>蓝框的是li，黑框的是div</p><p>初始化状态</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c69eedc657e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="177" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;177&quot;&gt;&lt;/svg&gt;"></p><p>处于显示第二张图片的时候</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/20/15fd6c69c722f686?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="230" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;230&quot;&gt;&lt;/svg&gt;"></p><p>看到上面，其实也就是控制ul的偏移量（<code>transform:translate3d</code>）。计算公式和上面的滑块相似，索引（<code>0|1|2|3</code>）*<code>li</code>的宽度。不同的就是，ul的偏移量是取负数，因为ul是想左偏，上面的滑块是向右偏！<br>当第一张图片的时候，ul偏移量设置（<code>transform: translate3d(0px, 0px, 0px)</code>）。<br>当第二张图片的时候，ul偏移量设置（<code>transform: translate3d(-1000px, 0px, 0px)</code>）。<br>当第二张图片的时候，ul偏移量设置（<code>transform: translate3d(-2000px, 0px, 0px)</code>）。以此类推，偏移量很简单的就能计算出来！</p><p>可能我说的大家有点懵，但是，看下面的代码，就不会懵了，因为代码也很简单！</p><h3 data-id="heading-14">vue方式</h3><pre class="hljs bash"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="hljs-string">"en"</span>&gt;\n&lt;head&gt;\n    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"reset.css"</span>&gt;\n    &lt;style&gt;\n        .slide-img {\n            width: 1000px;\n            height: 500px;\n            overflow: hidden;\n            position: relative;\n            margin: 20px auto;\n        }\n\n        ul {\n            transition: all .5s ease;\n        }\n\n        li {\n            <span class="hljs-built_in">float</span>: left;\n        }\n\n        .slide-arrow div {\n            width: 50px;\n            height: 100px;\n            position: absolute;\n            margin: auto;\n            top: 0;\n            bottom: 0;\n            background: url(<span class="hljs-string">"http://i1.bvimg.com/1949/4d860a3067fab23b.jpg"</span>) no-repeat;\n        }\n\n        .arrow-right {\n            transform: rotate(180deg);\n            right: 0;\n        }\n\n        .arrow-left {\n            left: 0;\n        }\n        .slide-option{\n            position: absolute;\n            bottom: 10px;\n            width: 100%;\n            left: 0;\n            text-align: center;\n        }\n        .slide-option span{\n            display: inline-block;\n            width: 14px;\n            height: 14px;\n            border-radius: 100%;\n            background: <span class="hljs-comment">#ccc;</span>\n            margin: 0 10px;\n        }\n        .slide-option .active{\n            background: <span class="hljs-comment">#09f;</span>\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=<span class="hljs-string">"slide-img clear"</span> id=<span class="hljs-string">"slide-img"</span>&gt;\n    &lt;!--用tran这个class控制ul是否含有过渡效果，样式已经写好--&gt;\n    &lt;ul :style=<span class="hljs-string">"{\'width\':(listWidth*list.length)+\'px\',\'transform\':\'translate3d(-\'+(listWidth*nowIndex)+\'px,0,0)\'}"</span>&gt;\n        &lt;!--遍历出来的图片--&gt;\n        &lt;li v-for=<span class="hljs-string">"(li,index) in list"</span> :style=<span class="hljs-string">"{\'width\':listWidth+\'px\'}"</span>&gt;\n            &lt;a href=<span class="hljs-string">"javascript:;"</span>&gt;\n                &lt;img :src=<span class="hljs-string">"li"</span> class=<span class="hljs-string">"slider-img"</span>/&gt;\n            &lt;/a&gt;\n        &lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div class=<span class="hljs-string">"slide-option"</span>&gt;\n        &lt;span v-for=<span class="hljs-string">"(li,index) in list"</span> :class=<span class="hljs-string">"{\'active\':index===nowIndex}"</span>&gt;&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=<span class="hljs-string">"slide-arrow"</span>&gt;\n        &lt;div class=<span class="hljs-string">"arrow-left"</span> @click.stop=<span class="hljs-string">"switchDo(\'reduce\')"</span>&gt;&lt;/div&gt;\n        &lt;div class=<span class="hljs-string">"arrow-right"</span> @click.stop=<span class="hljs-string">"switchDo"</span>&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;script src=<span class="hljs-string">"vue.min.js"</span>&gt;&lt;/script&gt;\n&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;\n    new Vue({\n        el: <span class="hljs-string">\'#slide-img\'</span>,\n        data: {\n            nowIndex: 0,\n            listWidth: <span class="hljs-string">\'1000\'</span>,\n            list: [<span class="hljs-string">\'./images/timg1.jpg\'</span>, <span class="hljs-string">\'./images/timg2.jpg\'</span>, <span class="hljs-string">\'./images/timg3.jpg\'</span>, <span class="hljs-string">\'./images/timg4.jpg\'</span>],\n            timer:null\n        },\n        methods: {\n            //滑动操作\n            switchDo(reduce){\n                clearInterval(this.timer);\n                //根据reduce判断this.nowIndex的增加或者减少！\n                <span class="hljs-keyword">if</span>(reduce===<span class="hljs-string">\'reduce\'</span>){\n                    //如果是第一张，就返回最后一张\n                    <span class="hljs-keyword">if</span>(this.nowIndex===0){\n                        this.nowIndex=this.list.length-1;\n                    }\n                    <span class="hljs-keyword">else</span>{\n                        this.nowIndex--;\n                    }\n                }\n                <span class="hljs-keyword">else</span>{\n                    //如果是最后一张，就返回第一张\n                    <span class="hljs-keyword">if</span>(this.nowIndex===this.list.length-1){\n                        this.nowIndex=0;\n                    }\n                    <span class="hljs-keyword">else</span>{\n                        this.nowIndex++;\n                    }\n                }\n                var _this=this;\n                this.timer=<span class="hljs-built_in">set</span>Interval(<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n                    _this.switchDo();\n                },4000)\n\n            },\n        },\n        <span class="hljs-function"><span class="hljs-title">mounted</span></span>(){\n            var _this=this;\n            this.timer=<span class="hljs-built_in">set</span>Interval(<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n                _this.switchDo();\n            },4000)\n        }\n    })\n&lt;/script&gt;\n&lt;/html&gt;</code></pre><h3 data-id="heading-15">javascript方式</h3><pre class="hljs bash"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="hljs-string">"en"</span>&gt;\n&lt;head&gt;\n    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"reset.css"</span>&gt;\n    &lt;style&gt;\n        .slide-img {\n            width: 1000px;\n            height: 500px;\n            overflow: hidden;\n            position: relative;\n            margin: 20px auto;\n        }\n\n        ul {\n            transition: all .5s ease;\n        }\n\n        li {\n            <span class="hljs-built_in">float</span>: left;\n        }\n\n        .slide-arrow div {\n            width: 50px;\n            height: 100px;\n            position: absolute;\n            margin: auto;\n            top: 0;\n            bottom: 0;\n            background: url(<span class="hljs-string">"http://i1.bvimg.com/1949/4d860a3067fab23b.jpg"</span>) no-repeat;\n        }\n\n        .arrow-right {\n            transform: rotate(180deg);\n            right: 0;\n        }\n\n        .arrow-left {\n            left: 0;\n        }\n        .slide-option{\n            position: absolute;\n            bottom: 10px;\n            width: 100%;\n            left: 0;\n            text-align: center;\n        }\n        .slide-option span{\n            display: inline-block;\n            width: 14px;\n            height: 14px;\n            border-radius: 100%;\n            background: <span class="hljs-comment">#ccc;</span>\n            margin: 0 10px;\n        }\n        .slide-option .active{\n            background: <span class="hljs-comment">#09f;</span>\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=<span class="hljs-string">"slide-img clear"</span> id=<span class="hljs-string">"slide-img"</span>&gt;\n    &lt;!--用tran这个class控制ul是否含有过渡效果，样式已经写好--&gt;\n    &lt;ul id=<span class="hljs-string">"slide-img-ul"</span>&gt;\n        &lt;!--遍历出来的图片--&gt;\n        &lt;li style=<span class="hljs-string">"width: 1000px;"</span>&gt;&lt;a href=<span class="hljs-string">"javascript:;"</span>&gt;&lt;img src=<span class="hljs-string">"images/timg1.jpg"</span> class=<span class="hljs-string">"slider-img"</span>/&gt;&lt;/a&gt;&lt;/li&gt;\n        &lt;li style=<span class="hljs-string">"width: 1000px;"</span>&gt;&lt;a href=<span class="hljs-string">"javascript:;"</span>&gt;&lt;img src=<span class="hljs-string">"images/timg2.jpg"</span> class=<span class="hljs-string">"slider-img"</span>/&gt;&lt;/a&gt;&lt;/li&gt;\n        &lt;li style=<span class="hljs-string">"width: 1000px;"</span>&gt;&lt;a href=<span class="hljs-string">"javascript:;"</span>&gt;&lt;img src=<span class="hljs-string">"images/timg3.jpg"</span> class=<span class="hljs-string">"slider-img"</span>/&gt;&lt;/a&gt;&lt;/li&gt;\n        &lt;li style=<span class="hljs-string">"width: 1000px;"</span>&gt;&lt;a href=<span class="hljs-string">"javascript:;"</span>&gt;&lt;img src=<span class="hljs-string">"images/timg4.jpg"</span> class=<span class="hljs-string">"slider-img"</span>/&gt;&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div class=<span class="hljs-string">"slide-option"</span>&gt;\n        &lt;span&gt;&lt;/span&gt;\n        &lt;span&gt;&lt;/span&gt;\n        &lt;span&gt;&lt;/span&gt;\n        &lt;span&gt;&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=<span class="hljs-string">"slide-arrow"</span>&gt;\n        &lt;div class=<span class="hljs-string">"arrow-left"</span>&gt;&lt;/div&gt;\n        &lt;div class=<span class="hljs-string">"arrow-right"</span>&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;\n    window.onload=<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n        var oUl=document.querySelector(<span class="hljs-string">\'#slide-img-ul\'</span>);\n        var oLi=oUl.querySelectorAll(<span class="hljs-string">\'li\'</span>);\n        var oSpan=document.querySelector(<span class="hljs-string">\'.slide-option\'</span>).querySelectorAll(<span class="hljs-string">\'span\'</span>);\n        var oArrowLeft=document.querySelector(<span class="hljs-string">\'.arrow-left\'</span>);\n        var oArrowRight=document.querySelector(<span class="hljs-string">\'.arrow-right\'</span>);\n        oUl.style.width=<span class="hljs-string">\'4000px\'</span>;\n        oArrowLeft.addEventListener(<span class="hljs-string">\'click\'</span>,<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n            switchDo(<span class="hljs-string">\'reduce\'</span>);\n        })\n        oArrowRight.addEventListener(<span class="hljs-string">\'click\'</span>,<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n            switchDo();\n        })\n        var timer=null,nowIndex=0;\n        <span class="hljs-keyword">function</span> switchDo(reduce){\n            clearInterval(timer);\n            //设置样式\n            oUl.style.transform=<span class="hljs-string">\'translate3d(-\'</span>+(1000*nowIndex)+<span class="hljs-string">\'px,0,0)\'</span>;\n            <span class="hljs-keyword">for</span> (var i=0;i&lt;oSpan.length;i++){\n                <span class="hljs-keyword">if</span>(i===nowIndex){\n                    oSpan[i].className=<span class="hljs-string">\'active\'</span>;\n                }\n                <span class="hljs-keyword">else</span>{\n                    oSpan[i].className=<span class="hljs-string">\'\'</span>;\n                }\n            }\n            //根据reduce判断this.nowIndex的增加或者减少！\n            <span class="hljs-keyword">if</span>(reduce===<span class="hljs-string">\'reduce\'</span>){\n                //如果是第一张，就返回最后一张\n                <span class="hljs-keyword">if</span>(nowIndex===0){\n                    nowIndex=oLi.length-1;\n                }\n                <span class="hljs-keyword">else</span>{\n                    nowIndex--;\n                }\n            }\n            <span class="hljs-keyword">else</span>{\n                //如果是最后一张，就返回第一张\n                <span class="hljs-keyword">if</span>(nowIndex===oLi.length-1){\n                    nowIndex=0;\n                }\n                <span class="hljs-keyword">else</span>{\n                    nowIndex++;\n                }\n            }\n            timer=<span class="hljs-built_in">set</span>Interval(<span class="hljs-function"><span class="hljs-title">function</span></span> () {\n                switchDo();\n            },4000)\n        }\n        switchDo();\n    }\n&lt;/script&gt;\n&lt;/html&gt;</code></pre><h2 data-id="heading-16">5.小结</h2><p>好了，关于<code>vue</code>+<code>css3</code>开发的特效，以及和<code>javascript</code>+<code>css3</code>的对比，就说到这里了，希望这三个小实例，能帮到大家了解下应该怎么使用<code>vue</code>+<code>css3</code>开发特效的。今天讲这三个小实例不是说给大家代码，让大家复制粘贴使用，而是希望能起到一个抛砖引玉的作用，拓展思维的作用！就像我之前写文章说得那样，我写文章是希望能起到一个授人以渔的作用，而不是授人以鱼！最后，如果大家觉得有什么地方我写错了，写错不好，或者有其它什么建议，欢迎指出！让大家相互学习，共同进步！</p><p><br></p><p>-------------------------华丽的分割线--------------------<br>想了解更多，关注关注我的微信公众号：守候书阁</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/8/160d33b27d3f303a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="258" data-height="258" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;258&quot; height=&quot;258&quot;&gt;&lt;/svg&gt;"></p><p><br></p></div>',__v:0},{tags:["Vue.js","JavaScript"],meta:{updateAt:"2018-02-09T05:06:21.632Z",createAt:"2018-02-09T05:06:21.632Z"},_id:"5a7d2c4da7d59115dcd1f2db",id:"5a0c19f26fb9a045186a465a",title:"vue插件开发练习--实用弹窗",avatar:"https://user-gold-cdn.xitu.io/2017/7/18/64d82b70650d11ed806f611d929c7b1e?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1",author:"守候i",create_time:"2017 年 11 月 29 日",content:'<div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container"><h2 data-id="heading-0">1.前言</h2><p>上回说了组件（<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011141625" target="_blank" rel="nofollow noopener noreferrer">vue组件开发练习--焦点图切换</a>）的一个练习项目，这次换下口味，说下vue的插件练手的项目。相对于现在之前的焦点图切换的组件，这个可能就更简单了，基本就是熟悉下插件开发的步骤就可以了！这个项目，我更建议大家动手练习了，这个弹窗比之前的焦点图更加的实用性，也更常用。同时也能让大家熟悉下vue的插件开发的流程。代码同样，我会上传到github（<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FchenhuiYj%2Fec-dialog" target="_blank" rel="nofollow noopener noreferrer">ec-dialog</a>），需要的可以直接去看代码！</p><blockquote><p><b>建议</b><br><b>1.下面的步骤，最好在自己本地上跑起来，根据文章的步骤，逐步完成，如果只看代码，很容易懵逼的。 </b><br><b>2.如果不清楚哪个代码有什么作用，可能自己调试下，把代码去掉后，看下有什么影响，就很容易想出代码有什么作用了！</b></p></blockquote><h2 data-id="heading-1">2.项目目录</h2><p><img class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf45a02d2f02f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="648" data-height="629" src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf45a02d2f02f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>还是一个很简单的目录，各个目录不知道有什么用的，可以移步去看我上一篇文章。和组件开发的目录相比，区别就在于<code>src/js/components</code>这个文件夹上。</p><h2 data-id="heading-2">3.开发过程</h2><h3 data-id="heading-3">3-1.把项目跑起来</h3><p>首先，先弄<code>src/js/components/alert</code>这个组件。还是一样，，先在<code>src/js/components/alert/src/main.vue</code>。输出‘守候’。代码如下</p><pre class="hljs bash"><code>&lt;template&gt;\n    &lt;transition name=<span class="hljs-string">"ec"</span>&gt;\n        &lt;div class=<span class="hljs-string">"ec"</span>&gt;\n            守候\n        &lt;/div&gt;\n    &lt;/transition&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    <span class="hljs-built_in">export</span> default {\n        <span class="hljs-function"><span class="hljs-title">data</span></span> () {\n            <span class="hljs-built_in">return</span> {\n                name: <span class="hljs-string">\'ec-alert\'</span>,\n            }\n        },\n        computed: {},\n        <span class="hljs-function"><span class="hljs-title">mounted</span></span> () {\n        },\n        methods: {\n        }\n    }\n&lt;/script&gt;\n</code></pre><p>然后来到<code>\'alert/index.js\'</code>。这个术语叫什么什么文件，我不太清楚，暂时就叫，插件配置文件吧！代码如下（注意看注释）</p><pre class="hljs bash"><code>import Vue from <span class="hljs-string">\'vue\'</span>\nimport AlertComponent from <span class="hljs-string">\'./src/main.vue\'</span>\n//合并对象函数，这个方法是会改变，第一个参数的值的\n<span class="hljs-keyword">function</span> merge(target) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = 1, j = arguments.length; i &lt; j; i++) {\n        <span class="hljs-built_in">let</span> <span class="hljs-built_in">source</span> = arguments[i] || {};\n        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> prop <span class="hljs-keyword">in</span> <span class="hljs-built_in">source</span>) {\n            <span class="hljs-keyword">if</span> (source.hasOwnProperty(prop)) {\n                <span class="hljs-built_in">let</span> value = <span class="hljs-built_in">source</span>[prop];\n                <span class="hljs-keyword">if</span> (value !== undefined) {\n                    target[prop] = value;\n                }\n            }\n        }\n    }\n    <span class="hljs-built_in">return</span> target;\n};\n<span class="hljs-built_in">let</span> instance;\n//extend 是构造一个组件的语法器.传入参数，返回一个组件\n<span class="hljs-built_in">let</span> AlertConstructor = Vue.extend(AlertComponent);\n\n<span class="hljs-built_in">let</span> initInstance = ()=&gt;{\n    //实例化ConfirmConstructor组件\n    instance = new AlertConstructor({\n        el: document.createElement(<span class="hljs-string">\'div\'</span>)\n    });\n    //添加到boby\n    document.body.appendChild(instance.<span class="hljs-variable">$el</span>);\n}\n\n<span class="hljs-built_in">let</span> Alert = (options={}) =&gt; {\n    //初始化\n    initInstance();\n    // 将单个 confirm instance 的配置合并到默认值（instance.<span class="hljs-variable">$data</span>，就是main.vue里面的data）中\n    merge(instance.<span class="hljs-variable">$data</span>, options);\n    //返回Promise\n    <span class="hljs-built_in">return</span> new Promise((resolve, reject)=&gt;{\n        instance.show = <span class="hljs-literal">true</span>;\n        <span class="hljs-built_in">let</span> success = instance.success;\n        <span class="hljs-built_in">let</span> cancel = instance.cancel;\n        instance.success = () =&gt; {\n            //先执行instance.success（main.vue里面的success函数）\n            success();\n            //再执行自定义函数\n            resolve(<span class="hljs-string">\'ok\'</span>);\n        }\n    });\n\n}\n<span class="hljs-built_in">export</span> default Alert;</code></pre><p>然后来到<code>components/js/index.js</code>这个文件，配置组件和API，代码如下</p><pre class="hljs bash"><code>import alert from <span class="hljs-string">\'./alert/index.js\'</span>\n\nconst install = <span class="hljs-keyword">function</span>(Vue) {\n    //注册全局组件\n    Vue.component(alert.name, alert)\n    //添加全局API\n    Vue.prototype.<span class="hljs-variable">$alert</span> = alert\n}\n<span class="hljs-built_in">export</span> default install</code></pre><p>然后在模板文件，<code>index.html</code>里面设置一个div,方便挂载测试</p><pre class="hljs bash"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="hljs-string">"en"</span>&gt;\n&lt;meta name=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"</span>&gt;\n&lt;head&gt;\n    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=<span class="hljs-string">"app"</span>&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;  </code></pre><p>然后在入口文件<code>index.js</code>里面，使用插件</p><pre class="hljs bash"><code>require(<span class="hljs-string">"./index.html"</span>);\n//引入sass\nrequire(<span class="hljs-string">"./src/sass/com.scss"</span>);\nimport Vue from <span class="hljs-string">\'vue\'</span>\nimport dialog from <span class="hljs-string">\'./src/js/components/index\'</span>;\nVue.use(dialog)\n<span class="hljs-built_in">let</span> App = new Vue({\n    el: <span class="hljs-string">\'#app\'</span>,\n    <span class="hljs-function"><span class="hljs-title">data</span></span>(){\n        <span class="hljs-built_in">return</span> {\n            <span class="hljs-string">\'name\'</span>: <span class="hljs-string">\'index\'</span>\n        }\n    },\n    <span class="hljs-function"><span class="hljs-title">mounted</span></span>(){\n        this.<span class="hljs-variable">$alert</span>();\n    }\n});</code></pre><p>然后，命令行 <code>$ npm run dev</code>，结果完美</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf459fb9634a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="800" data-height="256" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;256&quot;&gt;&lt;/svg&gt;"></p><h3 data-id="heading-4">3-2.样式修改</h3><p>完成了上一步，这个插件的一大半就算完成了！剩下的工作主要开发的就是在<code>components/../main.vue</code>这文件开发。<br>首先，先别急写代码，想一下，一个弹窗大概需要什么字段。</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf459d8089500?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="416" data-height="174" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;416&quot; height=&quot;174&quot;&gt;&lt;/svg&gt;"></p><p>参考上面，发现有一个标题，一个内容，一个按钮文字。最后还需要一个变量，控制弹窗是否显示。然后一个点击按钮的操作函数。然后还有样式，大概如下</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf459e8e16bcb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="373" data-height="444" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;373&quot; height=&quot;444&quot;&gt;&lt;/svg&gt;"></p><p>样式这个不多说，其他的字段，一个萝卜一个坑的填进去就好，代码如下</p><pre class="hljs bash"><code>&lt;template&gt;\n    &lt;transition name=<span class="hljs-string">"ec"</span>&gt;\n        &lt;div v-if=<span class="hljs-string">"show"</span> class=<span class="hljs-string">"ec"</span>&gt;\n            &lt;div class=<span class="hljs-string">"ec-box"</span>&gt;\n                &lt;div class=<span class="hljs-string">"ec-box-inner"</span>&gt;\n                    &lt;!--标题--&gt;\n                    &lt;div class=<span class="hljs-string">"ec-title"</span> v-if=<span class="hljs-string">"title"</span>&gt;{{title}}&lt;/div&gt;\n                    &lt;!--内容--&gt;\n                    &lt;div class=<span class="hljs-string">"ec-content"</span>&gt;{{content}}&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;!--按钮--&gt;       \n                &lt;div class=<span class="hljs-string">"ec-box-buttons"</span>&gt;\n                    &lt;span class=<span class="hljs-string">"ec-btn-success"</span> @click=<span class="hljs-string">"success"</span>&gt;{{submitText}}&lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/transition&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    <span class="hljs-built_in">export</span> default {\n        <span class="hljs-function"><span class="hljs-title">data</span></span> () {\n            <span class="hljs-built_in">return</span> {\n                name:<span class="hljs-string">\'ec-alert\'</span>,\n                show: <span class="hljs-literal">false</span>,\n                title: <span class="hljs-string">\'提示\'</span>,\n                content: <span class="hljs-string">\'\'</span>,\n                submitText: <span class="hljs-string">\'确定\'</span>,\n                cancelText: <span class="hljs-string">\'取消\'</span>\n            }\n        },\n        computed: {},\n        <span class="hljs-function"><span class="hljs-title">mounted</span></span> () {\n        },\n        methods: {\n            //按钮事件\n            <span class="hljs-function"><span class="hljs-title">success</span></span> () {\n                this.show = <span class="hljs-literal">false</span>;\n            }\n        }\n    }\n&lt;/script&gt;\n&lt;style lang=<span class="hljs-string">"scss"</span> scoped&gt;\n\n    .ec {\n        background: rgba(00, 00, 00, .5);\n        position: fixed;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        .ec-box {\n            width: 80%;\n            max-width: 400px;\n            top: 200px;\n            position: absolute;\n            left: 0;\n            right: 0;\n            margin: auto;\n            background: <span class="hljs-comment">#fff;</span>\n            box-sizing: border-box;\n            padding: 20px;\n            border-radius: 6px;\n\n        }\n        .ec-title {\n            padding-left: 0;\n            margin-bottom: 0;\n            font-size: 16px;\n            font-weight: 700;\n            height: 18px;\n            color: <span class="hljs-comment">#333;</span>\n        }\n        .ec-content {\n            padding: 14px 0;\n            line-height: 24px;\n            color: <span class="hljs-comment">#48576a;</span>\n            font-size: 14px;\n        }\n        .ec-box-buttons {\n            text-align: right;\n        }\n        .ec-btn-success {\n            background: <span class="hljs-comment">#20a0ff;</span>\n            border-color: <span class="hljs-comment">#20a0ff;</span>\n            display: inline-block;\n            line-height: 1;\n            white-space: nowrap;\n            cursor: pointer;\n            color: <span class="hljs-comment">#fff;</span>\n            margin: 0;\n            padding: 10px 15px;\n            border-radius: 4px;\n        }\n        .ec-btn-cancel {\n            display: inline-block;\n            line-height: 1;\n            white-space: nowrap;\n            cursor: pointer;\n            background: <span class="hljs-comment">#fff;</span>\n            border: 1px solid <span class="hljs-comment">#c4c4c4;</span>\n            color: <span class="hljs-comment">#1f2d3d;</span>\n            margin: 0;\n            padding: 10px 15px;\n            border-radius: 4px;\n        }\n    }\n    .ec-enter {\n        opacity: 0;\n        .ec-box {\n            transform:scale(0);\n        }\n    }\n\n    .ec-enter-active {\n        transition: opacity .4s;\n        .ec-box {\n            transition: transform .4s;\n        }\n    }\n    .ec-leave-active{\n        transition: opacity .2s;\n        .ec-box {\n            transition: transform .2s;\n        }\n    }\n    .ec-leave-active {\n        opacity: 0;\n    }\n&lt;/style&gt;\n</code></pre><p>运行效果</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf459e8ca04c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="374" data-height="273" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;374&quot; height=&quot;273&quot;&gt;&lt;/svg&gt;"></p><h3 data-id="heading-5">3-3.使用插件</h3><p>大家知道，在前面步骤，<code>\'alert/index.js\'</code>这里就已经返回的一个Promise。所以，用法就是像Promise那样使用！</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/29/1600372554b8c532?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="734" data-height="395" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;734&quot; height=&quot;395&quot;&gt;&lt;/svg&gt;"><br></p><p>所以在入口文件，<code>index.js</code>里面直接写</p><pre class="hljs bash"><code><span class="hljs-function"><span class="hljs-title">mounted</span></span>(){\n    this.<span class="hljs-variable">$alert</span>({\n        title:<span class="hljs-string">\'提示2\'</span>,\n        content:<span class="hljs-string">\'这里是提示内容2\'</span>\n    }).then(()=&gt;{\n        this.name=<span class="hljs-string">\'守候\'</span>\n        alert(this.name)\n    })\n}\n</code></pre><p>运行效果</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf45a6bef7383?imageslim" data-width="800" data-height="628" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;628&quot;&gt;&lt;/svg&gt;"></p><h2 data-id="heading-6">4.其它弹窗</h2><p>还是那句话，程序员不会满足于现状，只有一种弹窗，怎么够，下面我再增加一种，和上面那个基本一样，就是多了一个取消按钮而已。<br>这里我就再讲一个简单的栗子，至于弹窗的样式，太多了，我在这里就不展开说了，大家需要的可进行拓展。</p><p>首先，创建这个目录（可以直接把alert那个目录拷贝过来，然后再修改几下就完事了）</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf45a61827211?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="514" data-height="227" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;514&quot; height=&quot;227&quot;&gt;&lt;/svg&gt;"></p><p>然后，针对<code>comfirm/src/main.vue</code>文件，添加下面的代码（下面的代码基本就是从<code>alert/src/main.vue</code>拷贝过来的，就是增加一个取消按钮的对应一个字段和操作函数）</p><pre class="hljs bash"><code>&lt;template&gt;\n    &lt;transition name=<span class="hljs-string">"ec"</span>&gt;\n        &lt;div v-if=<span class="hljs-string">"show"</span> class=<span class="hljs-string">"ec"</span>&gt;\n            &lt;div class=<span class="hljs-string">"ec-box"</span>&gt;\n                &lt;div class=<span class="hljs-string">"ec-box-inner"</span>&gt;\n                    &lt;!--标题--&gt;\n                    &lt;div class=<span class="hljs-string">"ec-title"</span> v-if=<span class="hljs-string">"title"</span>&gt;{{title}}&lt;/div&gt;\n                    &lt;!--内容--&gt;\n                    &lt;div class=<span class="hljs-string">"ec-content"</span>&gt;{{content}}&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;!--按钮--&gt;\n                &lt;div class=<span class="hljs-string">"ec-box-buttons"</span>&gt;\n                    &lt;span class=<span class="hljs-string">"ec-btn-success"</span> @click=<span class="hljs-string">"success"</span>&gt;{{submitText}}&lt;/span&gt;\n                    &lt;span class=<span class="hljs-string">"ec-btn-cancel"</span> @click=<span class="hljs-string">"cancel"</span>&gt;{{cancelText}}&lt;/span&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/transition&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    <span class="hljs-built_in">export</span> default {\n        <span class="hljs-function"><span class="hljs-title">data</span></span> () {\n            <span class="hljs-built_in">return</span> {\n                name:<span class="hljs-string">\'ec-comfirm\'</span>,\n                show: <span class="hljs-literal">false</span>,\n                title: <span class="hljs-string">\'提示\'</span>,\n                content: <span class="hljs-string">\'\'</span>,\n                submitText: <span class="hljs-string">\'确定\'</span>,\n                cancelText: <span class="hljs-string">\'取消\'</span>\n            }\n        },\n        computed: {},\n        <span class="hljs-function"><span class="hljs-title">mounted</span></span> () {\n        },\n        methods: {\n            //确定按钮事件\n            <span class="hljs-function"><span class="hljs-title">success</span></span> () {\n                this.show = <span class="hljs-literal">false</span>;\n            },\n            //取消按钮事件\n            <span class="hljs-function"><span class="hljs-title">cancel</span></span> () {\n                this.show = <span class="hljs-literal">false</span>;\n            }\n        }\n    }\n&lt;/script&gt;\n&lt;style lang=<span class="hljs-string">"scss"</span> scoped&gt;\n    .ec {\n        background: rgba(00, 00, 00, .5);\n        position: fixed;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        z-index: 9999;\n        .ec-box {\n            width: 80%;\n            max-width: 400px;\n            top: 200px;\n            position: absolute;\n            left: 0;\n            right: 0;\n            margin: auto;\n            background: <span class="hljs-comment">#fff;</span>\n            box-sizing: border-box;\n            padding: 20px;\n            border-radius: 6px;\n\n        }\n        .ec-title {\n            padding-left: 0;\n            margin-bottom: 0;\n            font-size: 16px;\n            font-weight: 700;\n            height: 18px;\n            color: <span class="hljs-comment">#333;</span>\n        }\n        .ec-content {\n            padding: 14px 0;\n            line-height: 24px;\n            color: <span class="hljs-comment">#48576a;</span>\n            font-size: 14px;\n        }\n        .ec-box-buttons {\n            text-align: right;\n        }\n        .ec-btn-success {\n            background: <span class="hljs-comment">#20a0ff;</span>\n            border-color: <span class="hljs-comment">#20a0ff;</span>\n            display: inline-block;\n            line-height: 1;\n            white-space: nowrap;\n            cursor: pointer;\n            color: <span class="hljs-comment">#fff;</span>\n            margin: 0;\n            padding: 10px 15px;\n            border-radius: 4px;\n        }\n        .ec-btn-cancel {\n            display: inline-block;\n            line-height: 1;\n            white-space: nowrap;\n            cursor: pointer;\n            background: <span class="hljs-comment">#fff;</span>\n            border: 1px solid <span class="hljs-comment">#c4c4c4;</span>\n            color: <span class="hljs-comment">#1f2d3d;</span>\n            margin: 0;\n            padding: 10px 15px;\n            border-radius: 4px;\n        }\n    }\n    .ec-enter {\n        opacity: 0;\n        .ec-box {\n            transform:scale(0);\n        }\n    }\n\n    .ec-enter-active {\n        transition: opacity .4s;\n        .ec-box {\n            transition: transform .4s;\n        }\n    }\n    .ec-leave-active{\n        transition: opacity .2s;\n        .ec-box {\n            transition: transform .2s;\n        }\n    }\n    .ec-leave-active {\n        opacity: 0;\n    }\n&lt;/style&gt;\n</code></pre><p>然后就是<code>comfirm/index.js</code>(也是基本拷贝的，我就截图，告诉大家改哪里吧，这个得稍微细看才知道改哪里)</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf45a646ba145?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="592" data-height="800" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;592&quot; height=&quot;800&quot;&gt;&lt;/svg&gt;"></p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf45a63addf03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="513" data-height="526" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;513&quot; height=&quot;526&quot;&gt;&lt;/svg&gt;"></p><p>然后<code>components/index.js</code></p><pre class="hljs bash"><code>import comfirm from <span class="hljs-string">\'./comfirm/index.js\'</span>\nimport alert from <span class="hljs-string">\'./alert/index.js\'</span>\n\nconst install = <span class="hljs-keyword">function</span>(Vue) {\n    //注册全局组件\n    Vue.component(comfirm.name, comfirm)\n    Vue.component(alert.name, alert)\n    //添加全局API\n    Vue.prototype.<span class="hljs-variable">$confirm</span> = comfirm\n    Vue.prototype.<span class="hljs-variable">$alert</span> = alert\n}\n<span class="hljs-built_in">export</span> default install</code></pre><p>最后在入口文件，<code>index.js</code>使用</p><pre class="hljs bash"><code>require(<span class="hljs-string">"./index.html"</span>);\n//引入sass\nrequire(<span class="hljs-string">"./src/sass/com.scss"</span>);\nimport Vue from <span class="hljs-string">\'vue\'</span>\nimport dialog from <span class="hljs-string">\'./src/js/components/index\'</span>;\n//使用弹窗插件\nVue.use(dialog)\n<span class="hljs-built_in">let</span> App = new Vue({\n    el: <span class="hljs-string">\'#app\'</span>,\n    <span class="hljs-function"><span class="hljs-title">data</span></span>(){\n        <span class="hljs-built_in">return</span> {\n            <span class="hljs-string">\'name\'</span>: <span class="hljs-string">\'index\'</span>\n        }\n    },\n    <span class="hljs-function"><span class="hljs-title">mounted</span></span>(){\n        //触发confirm弹窗\n        this.<span class="hljs-variable">$confirm</span>({\n            title:<span class="hljs-string">\'提示\'</span>,\n            content:<span class="hljs-string">\'这里是提示内容\'</span>,\n            submitText:<span class="hljs-string">\'提交\'</span>,\n            cancelText:<span class="hljs-string">\'返回\'</span>\n        }).then(()=&gt;{\n            //触发alert弹窗\n            this.<span class="hljs-variable">$alert</span>({\n                title:<span class="hljs-string">\'提示2\'</span>,\n                content:<span class="hljs-string">\'这里是提示内容2\'</span>\n            }).then(()=&gt;{\n                this.name=<span class="hljs-string">\'守候\'</span>\n                alert(this.name)\n            })\n        }).catch((err)=&gt;{\n            alert(err)\n        })\n    }\n}); \n</code></pre><p>运行结果，就是这样</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/11/15/15fbf45a7d30809d?imageslim" data-width="800" data-height="628" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;628&quot;&gt;&lt;/svg&gt;"></p><h2 data-id="heading-7">5.小结</h2><p>一个简单的弹窗就到这里了，很简单，但是在我开发那里还是能用，能暂时满足。但是这个肯定是需要维护的，毕竟很多的项目都需要弹窗。大家也根据自己的需要进行拓展！以上的案例也很简单，容易懂。基本都是记流程。但是这个我很建议大家边动手，边看文章。这个可以让自己练习下基于vue开发插件，是一个不错的练习，希望能帮到大家学习到新的知识！最后，如果觉得文章那里写的不好或者写错了，欢迎指出！</p><p><br></p><p><br></p><p>-------------------------华丽的分割线--------------------<br>想了解更多，关注关注我的微信公众号：守候书阁</p><p><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/8/160d33b27d3f303a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="258" data-height="258" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;258&quot; height=&quot;258&quot;&gt;&lt;/svg&gt;"></p><p><br></p></div>',__v:0},{tags:["JavaScript","前端","jQuery"],meta:{updateAt:"2018-02-09T05:06:21.632Z",createAt:"2018-02-09T05:06:21.632Z"},_id:"5a7d2c4da7d59115dcd1f2da",id:"5a2bdc55f265da432b4abf5e",title:"JS时间处理插件MomentJS",avatar:"https://user-gold-cdn.xitu.io/2017/12/9/1603b5820ac466ee?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1",author:"谢小飞",create_time:"2017 年 12 月 09 日",content:'<div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container"><p>笔者在做项目的时候，需要对日期和时间进行一些处理和操作，但是每次都用JS自带的Date对象很不方便，还要写一堆繁琐的代码，后续维护起来也很痛苦。在网上找了一下JS处理日期和时间的插件，发现了MomentJS很好用，学习了一下它的语法，发现十分的简洁易懂，而且可扩展性很强，调用方法灵活。很多的方法调用形式多样，支持多种传参数方式。下面简单的整理了一下使用方式</p>\n<h1 class="heading" data-id="heading-0">构造Moment对象</h1>\n<p>MomentJS将时间封装成一个对象，moment对象，这个对象很多种构造方式，可以支持传入字符串、数组和对象的形式来构造。</p>\n<h2 class="heading" data-id="heading-1">当前系统时间</h2>\n<p>如果什么都不传，就获取当前的系统时间。</p>\n<pre><code class="hljs bash" lang="bash">var now = moment()\n</code></pre><h2 class="heading" data-id="heading-2">字符串构造</h2>\n<p>可以传入字符串，首先会检查字符串的格式是否符合<code>ISO 8601</code>的格式，如果不符合，就调用<code>new Date(string)</code>来构造。</p>\n<h3 class="heading" data-id="heading-3">已知格式字符串</h3>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'2017-01-02\'</span>);               //年月日\nmoment(<span class="hljs-string">\'2017-01-02 13\'</span>);            //年月日 小时\nmoment(<span class="hljs-string">\'2017-01-02 13:12\'</span>);         //年月日 小时分钟\nmoment(<span class="hljs-string">\'2017-01-02 13:12:52\'</span>);      //年月日 小时分钟秒\nmoment(<span class="hljs-string">\'2017-01-02 13:12:52.123\'</span>);  //年月日 小时分钟秒 毫秒\n</code></pre><h3 class="heading" data-id="heading-4">字符串+格式</h3>\n<p>假如日期的格式不符合<code>ISO 8601</code>的格式，但是你知道输入的字符串的格式，也可以通过这种方式解析，解析的语法有以下四种格式：</p>\n<pre><code class="hljs bash" lang="bash">moment(String, String);\nmoment(String, String, String);\nmoment(String, String, Boolean);\nmoment(String, String, String, Boolean);\n</code></pre><p>第一种已知某个时间的格式，将格式作为第二个参数传入</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'12-25-1995 12/43/53\'</span>, <span class="hljs-string">\'MM-DD-YYYY HH/mm/ss\'</span>)\n</code></pre><p>格式字母代表的含义如下表</p>\n<table>\n<thead>\n<tr>\n<th>Input</th>\n<th>Example</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>YYYY</td>\n<td>2014</td>\n<td>4位数年份</td>\n</tr>\n<tr>\n<td>YY</td>\n<td>14</td>\n<td>2位数年份</td>\n</tr>\n<tr>\n<td>Q</td>\n<td>1..4</td>\n<td>季度，将月份设置成季度的第一个月</td>\n</tr>\n<tr>\n<td>M MM</td>\n<td>1..12</td>\n<td>月份</td>\n</tr>\n<tr>\n<td>MMM MMMM</td>\n<td>Jan..December</td>\n<td>月份名称</td>\n</tr>\n<tr>\n<td>D DD</td>\n<td>1..31</td>\n<td>一个月的第几天</td>\n</tr>\n<tr>\n<td>DDD DDDD</td>\n<td>1..365</td>\n<td>一年的第几天</td>\n</tr>\n<tr>\n<td>H HH</td>\n<td>0..23</td>\n<td>24小时制</td>\n</tr>\n<tr>\n<td>h hh</td>\n<td>1..12</td>\n<td>12小时制</td>\n</tr>\n<tr>\n<td>m mm</td>\n<td>0..59</td>\n<td>分钟</td>\n</tr>\n<tr>\n<td>s ss</td>\n<td>0..59</td>\n<td>秒</td>\n</tr>\n</tbody>\n</table>\n<p>第二种，可以将当地区域的关键符作为第三个参数传入。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'2012 juillet\'</span>, <span class="hljs-string">\'YYYY MMM\'</span>, <span class="hljs-string">\'fr\'</span>);\nmoment(<span class="hljs-string">\'2012 July\'</span>,    <span class="hljs-string">\'YYYY MMM\'</span>, <span class="hljs-string">\'en\'</span>);\n</code></pre><p>MomentJS的匹配模式是十分宽松的，并且可能会导致一些我们不想要的行为。从<code>2.3.0</code>版本开始，我们可以在最后传入一个布尔值来让Moment使用严格模式匹配。严格模式要求输入的字符串和格式要完全相同。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'It is 2012-05-25\'</span>, <span class="hljs-string">\'YYYY-MM-DD\'</span>).isValid();       // <span class="hljs-literal">true</span>\nmoment(<span class="hljs-string">\'It is 2012-05-25\'</span>, <span class="hljs-string">\'YYYY-MM-DD\'</span>, <span class="hljs-literal">true</span>).isValid(); // <span class="hljs-literal">false</span>\nmoment(<span class="hljs-string">\'2012-05-25\'</span>,       <span class="hljs-string">\'YYYY-MM-DD\'</span>, <span class="hljs-literal">true</span>).isValid(); // <span class="hljs-literal">true</span>\n</code></pre><h3 class="heading" data-id="heading-5">字符串+多格式</h3>\n<p>假如你不知道输入的字符串确切是用的哪种格式，但是知道是某些格式中的一种，可以将多种格式用数组的形式传入，将会以最先匹配到的格式为输出结果。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">"12-25-1995"</span>, [<span class="hljs-string">"MM-DD-YYYY"</span>, <span class="hljs-string">"YYYY-MM-DD"</span>]);\n</code></pre><h2 class="heading" data-id="heading-6">对象</h2>\n<p>我们也可以通过传入一个对象的形式来创建moment对象，传入的对象中包括一些时间单位的属性。</p>\n<pre><code class="hljs bash" lang="bash">moment({ y    :2010, M     :3, d   :5, h    :15, m      :10, s      :3, ms          :123});\nmoment({ year :2010, month :3, day :5, hour :15, minute :10, second :3, millisecond :123});\nmoment({ years:2010, months:3, days:5, hours:15, minutes:10, seconds:3, milliseconds:123});\nmoment({ years:2010, months:3, date:5, hours:15, minutes:10, seconds:3, milliseconds:123});\n</code></pre><p>上面代码中的day和date都表示当前月的第几天。</p>\n<h3 class="heading" data-id="heading-7">Date 对象</h3>\n<p>我们也可以传入JS原生的Date对象来创建moment对象。</p>\n<pre><code class="hljs bash" lang="bash">var day = new Date(2011, 9, 16);\nvar dayWrapper = moment(day);\n</code></pre><h2 class="heading" data-id="heading-8">数组</h2>\n<p>我们可以传入一个数字的数组来创建moment对象，数组中每个每个数字代表的含义如下：</p>\n<pre><code class="hljs bash" lang="bash">// [年, 月, 日, 时, 分, 秒, 毫秒]\nmoment([2010, 1, 14, 15, 25, 50, 125]);\n//2010年2月14日15时25分50秒125毫秒\n</code></pre><p>需要注意的是：数组中的月、时、分、秒、毫秒都是从0开始的，而年和日都是从1开始的。</p>\n<h1 class="heading" data-id="heading-9">取值and赋值</h1>\n<p>MomentJS使用可以重载的get和set方法，跟我们以前在jQuery中的形式很相似。我们可以调用这些方法不传参数作来获取，传入参数作来设置。</p>\n<h2 class="heading" data-id="heading-10">自带函数</h2>\n<p>获取或者设置毫秒，设置的范围0到999</p>\n<pre><code class="hljs bash" lang="bash">moment().millisecond(Number);\nmoment().millisecond(); // Number\nmoment().milliseconds(Number);\nmoment().milliseconds(); // Number\n</code></pre><p>获取或者设置秒，设置的范围0到59</p>\n<pre><code class="hljs bash" lang="bash">moment().second(Number);\nmoment().second(); // Number\nmoment().seconds(Number);\nmoment().seconds(); // Number\n</code></pre><p>获取或者设置分钟，设置的范围0到59</p>\n<pre><code class="hljs bash" lang="bash">moment().minute(Number);\nmoment().minute(); // Number\nmoment().minutes(Number);\nmoment().minutes(); // Number\n</code></pre><p>获取或者设置小时，设置的范围0到23</p>\n<pre><code class="hljs bash" lang="bash">moment().hour(Number);\nmoment().hour(); // Number\nmoment().hours(Number);\nmoment().hours(); // Number\n</code></pre><p>获取或者设置日期，设置的范围1到31</p>\n<pre><code class="hljs bash" lang="bash">moment().date(Number);\nmoment().date(); // Number\nmoment().dates(Number);\nmoment().dates(); // Number\n</code></pre><p>获取或者设置星期，设置的范围0（周日）到6（周六）</p>\n<pre><code class="hljs bash" lang="bash">moment().day(Number|String);\nmoment().day(); // Number\nmoment().days(Number|String);\nmoment().days(); // Number\n</code></pre><p>获取或者设置一年中的天数，设置的范围1到366</p>\n<pre><code class="hljs bash" lang="bash">moment().dayOfYear(Number);\nmoment().dayOfYear(); // Number\n</code></pre><p>获取或者设置一年中的周</p>\n<pre><code class="hljs bash" lang="bash">moment().week(Number);\nmoment().week(); // Number\nmoment().weeks(Number);\nmoment().weeks(); // Number\n</code></pre><p>获取或者设置一年中的月份，设置的范围0到11</p>\n<pre><code class="hljs bash" lang="bash">moment().month(Number|String);\nmoment().month(); // Number\nmoment().months(Number|String);\nmoment().months(); // Number\n</code></pre><p>获取或者设置季度，设置的范围1到4</p>\n<pre><code class="hljs bash" lang="bash">moment().quarter(); // Number\nmoment().quarter(Number);\n</code></pre><p>获取或者设置年，设置的范围-270000到270000</p>\n<pre><code class="hljs bash" lang="bash">moment().year(Number);\nmoment().year(); // Number\nmoment().years(Number);\nmoment().years(); // Number\n</code></pre><h2 class="heading" data-id="heading-11">取值and赋值函数</h2>\n<p>除了上面的这么多函数外，MomentJS还有一个用来统一取值和赋值的函数，get和set。</p>\n<pre><code class="hljs bash" lang="bash">moment().get(<span class="hljs-string">\'year\'</span>);\nmoment().get(<span class="hljs-string">\'month\'</span>);  // 0 to 11\nmoment().get(<span class="hljs-string">\'date\'</span>);\nmoment().get(<span class="hljs-string">\'hour\'</span>);\nmoment().get(<span class="hljs-string">\'minute\'</span>);\nmoment().get(<span class="hljs-string">\'second\'</span>);\nmoment().get(<span class="hljs-string">\'millisecond\'</span>);\n</code></pre><p>set函数接收单位作为第一个参数，单位的值作为第二个参数。如果要设置多个值的话，也可以通过传入一个对象。</p>\n<pre><code class="hljs bash" lang="bash">moment().set(<span class="hljs-string">\'year\'</span>, 2013);\nmoment().set(<span class="hljs-string">\'month\'</span>, 3); //四月\nmoment().set(<span class="hljs-string">\'date\'</span>, 1);\nmoment().set(<span class="hljs-string">\'hour\'</span>, 13);\nmoment().set(<span class="hljs-string">\'minute\'</span>, 20);\nmoment().set(<span class="hljs-string">\'second\'</span>, 30);\nmoment().set(<span class="hljs-string">\'millisecond\'</span>, 123);\n\nmoment().set({<span class="hljs-string">\'year\'</span>: 2013, <span class="hljs-string">\'month\'</span>: 3});\n</code></pre><h2 class="heading" data-id="heading-12">max/min函数</h2>\n<p>max函数可以返回给定的moment对象中最大的实例，也就是最靠近未来的实例。</p>\n<pre><code class="hljs bash" lang="bash">var a = moment(<span class="hljs-string">\'2017-12-01\'</span>);\nvar b = moment(<span class="hljs-string">\'2017-12-06\'</span>);\nmoment.max(a, b);  // b\n</code></pre><p>min函数可以返回给定的moment对象中最小的实例，也就是最靠近过去的实例。</p>\n<pre><code class="hljs bash" lang="bash">var a = moment(<span class="hljs-string">\'2017-12-01\'</span>);\nvar b = moment(<span class="hljs-string">\'2017-12-06\'</span>);\nmoment.min(a, b);  // a\n</code></pre><h1 class="heading" data-id="heading-13">操作</h1>\n<p>有时候，我们需要对时间进行一系列的操作，最常见的就是加减计算。MomentJS提供了很多方法给我们来进行调用。\n　　MomentJS使用的模式跟jQuery相似，都是使用的函数的链式调用，可以让我们将操作链式执行下去，代码如下所示：</p>\n<pre><code class="hljs bash" lang="bash">moment()\n  .add(7, <span class="hljs-string">\'days\'</span>)\n  .subtract(1, <span class="hljs-string">\'months\'</span>)\n  .year(2009)\n  .hours(0)\n  .minutes(0)\n  .seconds(0);\n</code></pre><h2 class="heading" data-id="heading-14">add加法</h2>\n<p>add函数让我们把Moment对象的时间往后退，它的语法如下：</p>\n<pre><code class="hljs bash" lang="bash">moment().add(Number, String);\nmoment().add(Duration);\nmoment().add(Object);\n</code></pre><p>我们可以传入想要的增加的时间数量和时间单位，比如要往后推迟7天：</p>\n<pre><code class="hljs bash" lang="bash">moment().add(7, <span class="hljs-string">\'days\'</span>);\n</code></pre><p>当然，add函数也允许我们提供时间单位的缩写：</p>\n<pre><code class="hljs bash" lang="bash">moment().add(7, <span class="hljs-string">\'d\'</span>);\n</code></pre><table>\n<thead>\n<tr>\n<th>时间单位</th>\n<th>缩写</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>years</td>\n<td>y</td>\n</tr>\n<tr>\n<td>quarters</td>\n<td>Q</td>\n</tr>\n<tr>\n<td>months</td>\n<td>M</td>\n</tr>\n<tr>\n<td>weeks</td>\n<td>W</td>\n</tr>\n<tr>\n<td>days</td>\n<td>d</td>\n</tr>\n<tr>\n<td>hours</td>\n<td>h</td>\n</tr>\n<tr>\n<td>minutes</td>\n<td>m</td>\n</tr>\n<tr>\n<td>seconds</td>\n<td>s</td>\n</tr>\n<tr>\n<td>milliseconds</td>\n<td>ms</td>\n</tr>\n</tbody>\n</table>\n<p>如果想要同时增加不同时间单位，可以以对象的形式传入：</p>\n<pre><code class="hljs bash" lang="bash">moment().add(7, <span class="hljs-string">\'days\'</span>).add(1, <span class="hljs-string">\'months\'</span>);\nmoment().add({days:7,months:1});\n</code></pre><p>需要注意的是，如果原始日期的天数比新增后的日期的月份的总天数还要多，就变为该月的最后一天：</p>\n<pre><code class="hljs bash" lang="bash">// 01-31\nmoment([2010, 0, 31]);                  \n\n// 02-28 \nmoment([2010, 0, 31]).add(1, <span class="hljs-string">\'months\'</span>); \n//2月份没有31号，自动变为最后一天，即28号\n</code></pre><h2 class="heading" data-id="heading-15">subtract减法</h2>\n<p>subtract函数的用法和add相似，不同的是把时间往前推。</p>\n<pre><code class="hljs bash" lang="bash">moment().subtract(Number, String);\nmoment().subtract(Duration);\nmoment().subtract(Object);\n</code></pre><h2 class="heading" data-id="heading-16">startOf开始时间</h2>\n<p>startOf函数将Moment对象的时间设置为传入单位的开始时间。</p>\n<pre><code class="hljs bash" lang="bash">moment()                    //当前时间2017-12-09\nmoment().startOf(<span class="hljs-string">\'year\'</span>);   //今年年初2017-01-01\nmoment().startOf(<span class="hljs-string">\'month\'</span>);  //这个月开始2017-12-01\nmoment().startOf(<span class="hljs-string">\'quarter\'</span>);//这个季度开始2017-10-01\nmoment().startOf(<span class="hljs-string">\'week\'</span>);   //这周开始2017-12-03（周日为开始）\nmoment().startOf(<span class="hljs-string">\'isoWeek\'</span>);//这周开始2017-12-04（根据ISO 8601，周一为开始）\nmoment().startOf(<span class="hljs-string">\'day\'</span>);    //今天的开始时间2017-12-09 00:00:00:000\nmoment().startOf(<span class="hljs-string">\'hour\'</span>);   //今天当前小时开始2017-12-09 13:00:00:000\nmoment().startOf(<span class="hljs-string">\'minute\'</span>); //今天当前分钟开始2017-12-09 13:14:00:000\nmoment().startOf(<span class="hljs-string">\'second\'</span>); //今天当前秒钟开始2017-12-09 13:14:15:000\n</code></pre><h2 class="heading" data-id="heading-17">endOf结束时间</h2>\n<p>endOf函数将Moment对象的时间设置为传入单位的结束时间。使用方式和startOf相似。</p>\n<pre><code class="hljs bash" lang="bash">moment().endOf(String);\n</code></pre><h1 class="heading" data-id="heading-18">显示</h1>\n<p>当我们解析和操作完Moment对象后，我们就需要对最后的结果进行展示。</p>\n<h2 class="heading" data-id="heading-19">format格式化</h2>\n<p>format函数接收token字符串，并且将token替换成对应的值。</p>\n<pre><code class="hljs bash" lang="bash">moment().format();                                // <span class="hljs-string">"2014-09-08T08:02:17-05:00"</span> (ISO 8601)\nmoment().format(<span class="hljs-string">"dddd, MMMM Do YYYY, h:mm:ss a"</span>); // <span class="hljs-string">"Sunday, February 14th 2010, 3:25:50 pm"</span>\nmoment().format(<span class="hljs-string">"ddd, hA"</span>);                       // <span class="hljs-string">"Sun, 3PM"</span>\n</code></pre><p>对应的关系如下表：</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>Token</th>\n<th>输入</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>月</td>\n<td>M</td>\n<td>1 2 .. 11 12</td>\n</tr>\n<tr>\n<td></td>\n<td>Mo</td>\n<td>1st 2nd ... 11th 12th</td>\n</tr>\n<tr>\n<td></td>\n<td>MM</td>\n<td>01 02 ... 11 12</td>\n</tr>\n<tr>\n<td></td>\n<td>MMM</td>\n<td>Jan Feb ... Nov Dec</td>\n</tr>\n<tr>\n<td></td>\n<td>MMMM</td>\n<td>January February ... November December</td>\n</tr>\n<tr>\n<td>季度</td>\n<td>Q</td>\n<td>1 2 3 4</td>\n</tr>\n<tr>\n<td>月份中的天</td>\n<td>D</td>\n<td>1 2 ... 30 31</td>\n</tr>\n<tr>\n<td></td>\n<td>Do</td>\n<td>1st 2nd ... 30th 31st</td>\n</tr>\n<tr>\n<td></td>\n<td>DD</td>\n<td>01 02 ... 30 31</td>\n</tr>\n<tr>\n<td>年份中的天</td>\n<td>DDD</td>\n<td>1 2 ... 365 366</td>\n</tr>\n<tr>\n<td></td>\n<td>DDDo</td>\n<td>st 2nd ... 365th 366th</td>\n</tr>\n<tr>\n<td></td>\n<td>DDDD</td>\n<td>001 002 ... 365 366</td>\n</tr>\n<tr>\n<td>星期中的天</td>\n<td>d</td>\n<td>0 1 ... 5 6</td>\n</tr>\n<tr>\n<td></td>\n<td>do</td>\n<td>0th 1st ... 5th 6th</td>\n</tr>\n<tr>\n<td></td>\n<td>dd</td>\n<td>Su Mo ... Fr Sa</td>\n</tr>\n<tr>\n<td></td>\n<td>ddd</td>\n<td>Sun Mon ... Fri Sat</td>\n</tr>\n<tr>\n<td></td>\n<td>dddd</td>\n<td>Sunday Monday ... Friday Saturday</td>\n</tr>\n<tr>\n<td>年中的星期</td>\n<td>w</td>\n<td>1 2 ... 52 53</td>\n</tr>\n<tr>\n<td></td>\n<td>wo</td>\n<td>1st 2nd ... 52nd 53rd</td>\n</tr>\n<tr>\n<td></td>\n<td>ww</td>\n<td>01 02 ... 52 53</td>\n</tr>\n<tr>\n<td>年</td>\n<td>YY</td>\n<td>70 71 ... 29 30</td>\n</tr>\n<tr>\n<td></td>\n<td>YYYY</td>\n<td>1970 1971 ... 2029 2030</td>\n</tr>\n<tr>\n<td>AM/PM</td>\n<td>A</td>\n<td>AM PM</td>\n</tr>\n<tr>\n<td></td>\n<td>a</td>\n<td>am pm</td>\n</tr>\n<tr>\n<td>小时</td>\n<td>H</td>\n<td>0 1 ... 22 23</td>\n</tr>\n<tr>\n<td></td>\n<td>HH</td>\n<td>00 01 ... 22 23</td>\n</tr>\n<tr>\n<td></td>\n<td>h</td>\n<td>1 2 ... 11 12</td>\n</tr>\n<tr>\n<td></td>\n<td>hh</td>\n<td>01 02 ... 11 12</td>\n</tr>\n<tr>\n<td>分钟</td>\n<td>m</td>\n<td>0 1 ... 58 59</td>\n</tr>\n<tr>\n<td></td>\n<td>mm</td>\n<td>00 01 ... 58 59</td>\n</tr>\n<tr>\n<td>秒</td>\n<td>s</td>\n<td>0 1 ... 58 59</td>\n</tr>\n<tr>\n<td></td>\n<td>ss</td>\n<td>00 01 ... 58 59</td>\n</tr>\n<tr>\n<td>毫秒</td>\n<td>ms</td>\n<td>000 001 ... 998 999</td>\n</tr>\n</tbody>\n</table>\n<h2 class="heading" data-id="heading-20">diff时差</h2>\n<p>语法</p>\n<pre><code class="hljs bash" lang="bash">moment().diff(Moment|String|Number|Date|Array);\nmoment().diff(Moment|String|Number|Date|Array, String);\nmoment().diff(Moment|String|Number|Date|Array, String, Boolean);\n</code></pre><p>diff函数可以帮我们获取到两个Moment对象的时间差，默认的单位是毫秒。</p>\n<pre><code class="hljs bash" lang="bash">var a = moment([2017, 12, 29]);\nvar b = moment([2017, 12, 28]);\na.diff(b) // 86400000\n</code></pre><p>除了得到毫秒为单位，diff函数还支持获取其他的时间单位，将其作为第二个参数传入：</p>\n<pre><code class="hljs bash" lang="bash">var a = moment([2007, 0, 29]);\nvar b = moment([2007, 0, 28]);\na.diff(b, <span class="hljs-string">\'days\'</span>) // 1\n</code></pre><p>支持的测量单位有years、months、weeks、days、hours、minutes、seconds和milliseconds。默认返回的数值会向下取舍，去掉小数。假如想要精确一点，得到小数类型的数值，第三个参数传入一个true。</p>\n<pre><code class="hljs bash" lang="bash">var a = moment([2008, 6]);\nvar b = moment([2007, 0]);\na.diff(b, <span class="hljs-string">\'years\'</span>);       // 1\na.diff(b, <span class="hljs-string">\'years\'</span>, <span class="hljs-literal">true</span>); // 1.5\n</code></pre><h2 class="heading" data-id="heading-21">daysInMonth获取当前月份的天数</h2>\n<p>daysInMonth获取当前月的总天数</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">"2012-02"</span>, <span class="hljs-string">"YYYY-MM"</span>).daysInMonth() // 29\nmoment(<span class="hljs-string">"2012-01"</span>, <span class="hljs-string">"YYYY-MM"</span>).daysInMonth() // 31\n</code></pre><h2 class="heading" data-id="heading-22">toDate转为Date对象</h2>\n<p>将Moment对象转为js原生的Date对象</p>\n<h2 class="heading" data-id="heading-23">toArray转为数组</h2>\n<p>返回时间数组，和构造Moment对象时传入的数组代表的含义相同。</p>\n<pre><code class="hljs bash" lang="bash">moment().toArray(); // [2017, 12, 9, 13, 40, 16, 154];\n</code></pre><h2 class="heading" data-id="heading-24">toObject</h2>\n<p>将Moment对象转为包含年月日时分秒毫秒的对象。</p>\n<pre><code class="hljs bash" lang="bash">moment().toObject()  // {\n                     //     years: 2017\n                     //     months: 12\n                     //     date: 9,\n                     //     hours: 13,\n                     //     minutes: 40,\n                     //     seconds: 18,\n                     //     milliseconds: 600\n                     // }\n</code></pre><h1 class="heading" data-id="heading-25">查询</h1>\n<p>查询操作主要用来判断Moment是否满足某些条件。</p>\n<h2 class="heading" data-id="heading-26">isBefore是否之前</h2>\n<pre><code class="hljs bash" lang="bash">moment().isBefore(Moment|String|Number|Date|Array);\nmoment().isBefore(Moment|String|Number|Date|Array, String);\n</code></pre><p>isBefore判断一个moment对象是否在某个时间点之前。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'2010-10-20\'</span>).isBefore(<span class="hljs-string">\'2010-10-21\'</span>); // <span class="hljs-literal">true</span>\n</code></pre><p>默认的比较单位是毫秒，但是假如我们想要限制到其他的时间单位，我们可以将其作为第二个参数传入。接受的单位和startOf支持的单位一样。</p>\n<pre><code class="hljs bash" lang="bash">console.log(moment(<span class="hljs-string">\'2017-11-03\'</span>).isBefore(<span class="hljs-string">\'2017-11-06\'</span>))\nconsole.log(moment(<span class="hljs-string">\'2017-11-03\'</span>).isBefore(<span class="hljs-string">\'2017-11-06\'</span>, <span class="hljs-string">\'year\'</span>))\nconsole.log(moment(<span class="hljs-string">\'2017-11-03\'</span>).isBefore(<span class="hljs-string">\'2018-11-06\'</span>, <span class="hljs-string">\'year\'</span>))\n</code></pre><h2 class="heading" data-id="heading-27">isSame是否相同</h2>\n<pre><code class="hljs bash" lang="bash">moment().isSame(Moment|String|Number|Date|Array);\nmoment().isSame(Moment|String|Number|Date|Array, String);\n</code></pre><p>isSame判断一个moment对象是否和另一个moment对象相同。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'2010-10-20\'</span>).isSame(<span class="hljs-string">\'2010-10-20\'</span>); // <span class="hljs-literal">true</span>\nmoment(<span class="hljs-string">\'2010-10-20\'</span>).isSame(<span class="hljs-string">\'2010-10-21\'</span>); // <span class="hljs-literal">false</span>\n</code></pre><p>同样的，我们如果要将比较的单位改为其他的，也可以作为第二个参数传入。接受的单位和startOf支持的单位一样。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'2010-10-20\'</span>).isSame(<span class="hljs-string">\'2009-12-31\'</span>, <span class="hljs-string">\'year\'</span>);  // <span class="hljs-literal">false</span>\nmoment(<span class="hljs-string">\'2010-10-20\'</span>).isSame(<span class="hljs-string">\'2010-01-01\'</span>, <span class="hljs-string">\'year\'</span>);  // <span class="hljs-literal">true</span>\n</code></pre><p>当传入第二个参数时，它会匹配所有相同或者更大的单位。比如传入了月份，将会比较年和月，传入了日期，将会比较年月日</p>\n<pre><code class="hljs bash" lang="bash">// <span class="hljs-literal">false</span>, 不同的年\nmoment(<span class="hljs-string">\'2010-01-01\'</span>).isSame(<span class="hljs-string">\'2011-01-01\'</span>, <span class="hljs-string">\'month\'</span>);\n\n// <span class="hljs-literal">false</span>, 不同的月\nmoment(<span class="hljs-string">\'2010-01-01\'</span>).isSame(<span class="hljs-string">\'2010-02-01\'</span>, <span class="hljs-string">\'day\'</span>);\n</code></pre><h2 class="heading" data-id="heading-28">isAfter是否之后</h2>\n<p>isBefore判断一个moment对象是否在某个时间点之后。接受的单位和startOf支持的单位一样。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'2010-10-20\'</span>).isAfter(<span class="hljs-string">\'2010-10-19\'</span>); // <span class="hljs-literal">true</span>\n</code></pre><h2 class="heading" data-id="heading-29">isBetween是否之间</h2>\n<pre><code class="hljs bash" lang="bash">moment().isBetween(moment-like, moment-like);\nmoment().isBetween(moment-like, moment-like, String);\n//moment-like 表示 Moment|String|Number|Date|Array\n</code></pre><p>判断一个moment对象是否在两个其他时间点之间。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'2017-10-20\'</span>).isBetween(<span class="hljs-string">\'2017-10-19\'</span>, <span class="hljs-string">\'2017-10-25\'</span>); // <span class="hljs-literal">true</span>\n</code></pre><p>传入第二个参数作为限制的单位。接受的单位和startOf支持的单位一样。</p>\n<pre><code class="hljs bash" lang="bash">moment(<span class="hljs-string">\'2010-10-20\'</span>).isBetween(<span class="hljs-string">\'2010-01-01\'</span>, <span class="hljs-string">\'2012-01-01\'</span>, <span class="hljs-string">\'year\'</span>); // <span class="hljs-literal">false</span>\nmoment(<span class="hljs-string">\'2010-10-20\'</span>).isBetween(<span class="hljs-string">\'2009-12-31\'</span>, <span class="hljs-string">\'2012-01-01\'</span>, <span class="hljs-string">\'year\'</span>); // <span class="hljs-literal">true</span>\n</code></pre><h2 class="heading" data-id="heading-30">isLeapYear是否闰年</h2>\n<p>是闰年就返回true，不是就返回false。</p>\n<pre><code class="hljs bash" lang="bash">moment([2000]).isLeapYear() // <span class="hljs-literal">true</span>\nmoment([2001]).isLeapYear() // <span class="hljs-literal">false</span>\nmoment([2100]).isLeapYear() // <span class="hljs-literal">false</span>\n</code></pre><h2 class="heading" data-id="heading-31">isMoment 是否Moment对象</h2>\n<p>判断是否Moment对象</p>\n<pre><code class="hljs bash" lang="bash">moment.isMoment() // <span class="hljs-literal">false</span>\nmoment.isMoment(new Date()) // <span class="hljs-literal">false</span>\nmoment.isMoment(moment()) // <span class="hljs-literal">true</span>\n</code></pre><h2 class="heading" data-id="heading-32">isDate是否Date对象</h2>\n<p>判断是否Date对象</p>\n<pre><code class="hljs bash" lang="bash">moment.isDate(); // <span class="hljs-literal">false</span>\nmoment.isDate(new Date()); // <span class="hljs-literal">true</span>\nmoment.isDate(moment()); // <span class="hljs-literal">false</span>\n</code></pre><p>如果觉得写得还不错，请关注我的<a style="color:#f63;text-decoration:none;" href="https://link.juejin.im?target=%2F%2Fjuejin.im%2Fuser%2F580038cebf22ec0064bd0b2d" target="_blank" rel="nofollow noopener noreferrer">掘金主页</a>。更多文章请访问<a style="color:#f63;text-decoration:none;" href="https://link.juejin.im?target=http%3A%2F%2Fxieyufei.com" target="_blank" rel="nofollow noopener noreferrer">我的博客地址</a></p>\n</div>',__v:0},{tags:["Webpack","JavaScript"],meta:{updateAt:"2018-02-09T05:06:21.632Z",createAt:"2018-02-09T05:06:21.632Z"},_id:"5a7d2c4da7d59115dcd1f2d9",id:"5a38e100f265da4324809297",title:"从 webpack 到全面拥抱 Parcel #1 探索 Parcel",avatar:"https://user-gold-cdn.xitu.io/2017/12/5/16025f69a17a516c?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1",author:"rails365编程学院",create_time:"2017 年 12 月 19 日",content:'<div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container"><p>最近大家都在关注一个很流行的类似 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.rails365.net%2Fgroups%2Fwebpack" rel="nofollow noopener noreferrer">webpack</a> 的前端构建工具 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fparcel-bundler%2Fparcel" rel="nofollow noopener noreferrer">Parcel</a>。这个库刚出来没多久(好像截至目前十几天)，但是很受欢迎，看下图就知道。</p>\n<p></p><figure><img class="lazyload inited loaded" data-src="https://user-gold-cdn.xitu.io/2017/12/19/1606e2f115943aae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="1067" data-height="205" src="https://user-gold-cdn.xitu.io/2017/12/19/1606e2f115943aae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>\n<p>所以值得一探！</p>\n<p>官方地址：https://parceljs.org/</p>\n<p>github 地址：https://github.com/parcel-bundler/parcel</p>\n<p>介绍这个库之前，我们来说一下我个人觉得 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fwww.rails365.net%2Fgroups%2Fwebpack" rel="nofollow noopener noreferrer">webpack</a> 的一些不好的地方（相对于 Parcel）。</p>\n<ol>\n<li>\n<p>需要写配置文件（webpack.config.js），可能每使用一个功能，比如加载图片或 css，都要添加配置，要维护配置文件，而 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fparceljs.org%2F" rel="nofollow noopener noreferrer">Parcel</a> 不需要。</p>\n</li>\n<li>\n<p>感觉编译或加载速度有些慢，特别是库多或项目复杂的时候，虽然有一些办法代码拆分的方法可以解决，比如 CommonsChunkPlugin 或 DLLPlugin 之类的，但这些方法有些复杂。</p>\n</li>\n</ol>\n<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/19/1606e2f11c26ac60?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="532" data-height="268" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;532&quot; height=&quot;268&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<ol start="3">\n<li>需要一定的时间去学习如何使用 webpack。</li>\n</ol>\n<p>而 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fparceljs.org%2F" rel="nofollow noopener noreferrer">Parcel</a> 有很多优点，可以不使用配置文件，也就是说你只管写代码，它会自动运行，很智能化，打个比方吧，比如在 webpack 中如果要处理 css，那得要安装和加载一个 css 的 loader，然后配置文件写上几行，可是 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fparceljs.org%2F" rel="nofollow noopener noreferrer">Parcel</a> 不需要，直接用就行。<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fparceljs.org%2F" rel="nofollow noopener noreferrer">Parcel</a> 学习起来比较简单，基本上可以说 "不用学习"，只是使用就可以了。</p>\n<p>除此之外，模块热替换和代码拆分的功能，<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fparceljs.org%2F" rel="nofollow noopener noreferrer">Parcel</a> 也有，还有，如果要你用 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fparceljs.org%2F" rel="nofollow noopener noreferrer">Parcel</a> 写一个 react 的运行环境，可能不需要配置任何内容，只要安装几个 react 的包就可以用起来了。</p>\n<p>说了这么多，我还是要把官方对它的特性进行概括的图片放出来：</p>\n<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/19/1606e2f11c3a1cbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="1280" data-height="430" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;430&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<p>下面我们要开始来体验 parcel 的神奇之处，请跟紧。(源码我放到 https://github.com/hfpp2012/hello-parcel）</p>\n<h2 class="heading" data-id="heading-0">1. 安装</h2>\n<pre><code class="hljs bash" lang="bash">$ npm install -g parcel-bundler\n</code></pre><p>然后初始化一个项目。</p>\n<pre><code class="hljs bash" lang="bash">$ mkdir parcelapp\n$ npm init\n</code></pre><h2 class="heading" data-id="heading-1">2. 初体验</h2>\n<p>新建 html 文件。（这个将会是 parcel 的入口文件）</p>\n<p><strong>index.html</strong></p>\n<pre><code class="hljs html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,initial-scale=1.0"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Joke Generator<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"wrap"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Joke<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"joke"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"copy"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre><p><strong>index.js</strong></p>\n<pre><code class="hljs bash" lang="bash">console.log(<span class="hljs-string">\'Hello\'</span>);\n</code></pre><p>运行编译命令。</p>\n<pre><code class="hljs bash" lang="bash">$ parcel index.html\n</code></pre><p><strong>注意：上面的 parcel 命令接的是 html 文件，它会读 html 文件的内容，找到 javascript 文件，进行自运处理，不用像 webpack 那样，还要指定 javascript 的入口文件啥的。</strong></p>\n<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/19/1606e2f116495124?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="616" data-height="183" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;616&quot; height=&quot;183&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<p>生成了 <code>dist</code> 目录。</p>\n<pre><code class="hljs bash" lang="bash">dist\n├── index.html\n└── parcelapp.js\n</code></pre><p>监听在 1234 端口，浏览器效果如下：</p>\n<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/19/1606e2f11db9a494?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="685" data-height="440" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;685&quot; height=&quot;440&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<h2 class="heading" data-id="heading-2">3. CommonJS 模块语法</h2>\n<p>新建 jokes.js 文件。</p>\n<p><strong>jokes.js</strong></p>\n<pre><code class="hljs javascript" lang="javascript"><span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">getOne</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n      <span class="hljs-comment">// 这个 api 是公开的。</span>\n      fetch(<span class="hljs-string">\'http://api.icndb.com/jokes/random\'</span>)\n        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())\n        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n          resolve(data.value.joke);\n        })\n    })\n  }\n}\n</code></pre><p><strong>index.js</strong></p>\n<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">const</span> jokes = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./jokes\'</span>);\n\njokes.getOne()\n  .then(<span class="hljs-function"><span class="hljs-params">joke</span> =&gt;</span> {\n    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'joke\'</span>).innerHTML = joke;\n  });\n</code></pre><p>效果如下：</p>\n<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/19/1606e2f118965045?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="689" data-height="411" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;689&quot; height=&quot;411&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<h2 class="heading" data-id="heading-3">4. ES6 模块语法</h2>\n<p><code>require</code> 改成 <code>import</code>，如下所示：</p>\n<p><strong>index.js</strong></p>\n<pre><code class="hljs javascript" lang="javascript"><span class="hljs-comment">// const jokes = require(\'./jokes\');</span>\n\n<span class="hljs-keyword">import</span> { jokes } <span class="hljs-keyword">from</span> <span class="hljs-string">\'./jokes\'</span>;\n\njokes.getOne()\n  .then(<span class="hljs-function"><span class="hljs-params">joke</span> =&gt;</span> {\n    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">\'joke\'</span>).innerHTML = joke;\n  });\n</code></pre><p><strong>jokes.js</strong></p>\n<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> jokes = {\n  <span class="hljs-attr">getOne</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {\n      fetch(<span class="hljs-string">\'http://api.icndb.com/jokes/random\'</span>)\n        .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())\n        .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {\n          resolve(data.value.joke);\n        })\n    })\n  }\n}\n</code></pre><h2 class="heading" data-id="heading-4">5. 使用 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Faxios%2Faxios" rel="nofollow noopener noreferrer">axios</a> 代替 fetch</h2>\n<p>这只是为了演示使用一些库。</p>\n<p>首先安装 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Faxios%2Faxios" rel="nofollow noopener noreferrer">axios</a>。</p>\n<pre><code class="hljs bash" lang="bash">$ npm install axios\n</code></pre><p><strong>注意，这里每安装一个库，都要重新运行 parcel index.html</strong></p>\n<p><strong>jokes.js</strong></p>\n<pre><code class="hljs bash" lang="bash">import axios from <span class="hljs-string">\'axios\'</span>;\n\n<span class="hljs-built_in">export</span> const jokes = {\n  getOne: <span class="hljs-function"><span class="hljs-title">function</span></span>() {\n    <span class="hljs-built_in">return</span> new Promise((resolve, reject) =&gt; {\n      axios.get(<span class="hljs-string">\'http://api.icndb.com/jokes/random\'</span>)\n        .then(res =&gt; {\n          resolve(res.data.value.joke);\n        })\n    })\n  }\n}\n</code></pre><h2 class="heading" data-id="heading-5">6. 使用 jquery 代替 getElementById</h2>\n<pre><code class="hljs bash" lang="bash">$ npm install jquery\n</code></pre><p><strong>index.js</strong></p>\n<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">import</span> { jokes } <span class="hljs-keyword">from</span> <span class="hljs-string">\'./jokes\'</span>;\n<span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">\'jquery\'</span>;\n\njokes.getOne()\n  .then(<span class="hljs-function"><span class="hljs-params">joke</span> =&gt;</span> {\n    <span class="hljs-comment">// document.getElementById(\'joke\').innerHTML = joke;</span>\n    $(<span class="hljs-string">\'#joke\'</span>).text(joke);\n  });\n</code></pre><h2 class="heading" data-id="heading-6">7. 导入 非 JavaScript 资源</h2>\n<p><strong>copyright.txt</strong></p>\n<pre><code class="hljs bash" lang="bash">Copyright 2018\n</code></pre><p><strong>index.js</strong></p>\n<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">\'fs\'</span>;\n\n...\n\nconst copy = fs.readFileSync(__dirname + <span class="hljs-string">\'/copyright.txt\'</span>, <span class="hljs-string">\'utf8\'</span>);\n\n$(<span class="hljs-string">\'#copy\'</span>).text(copy);\n</code></pre><h2 class="heading" data-id="heading-7">8. 简单处理 css</h2>\n<p><strong>style.css</strong></p>\n<pre><code class="hljs css" lang="css"><span class="hljs-selector-tag">h1</span> {\n  <span class="hljs-attribute">color</span>: red;\n  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">1rem</span>;\n}\n\n<span class="hljs-selector-id">#wrap</span> {\n  <span class="hljs-attribute">display</span>: flex;\n  <span class="hljs-attribute">justify-content</span>: center;\n  <span class="hljs-attribute">align-content</span>: center;\n  <span class="hljs-attribute">align-items</span>: center;\n  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;\n  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;\n  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;\n  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(0, 0, 0, 0.12);\n}\n</code></pre><p><strong>index.html</strong></p>\n<pre><code class="hljs html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>\n  ...\n  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"style.css"</span> /&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Joke Generator<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>\n<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>\n  ...\n<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>\n</code></pre><h2 class="heading" data-id="heading-8">9. 在 css 中使用 import</h2>\n<p><strong>backgrounds.css</strong></p>\n<pre><code class="hljs css" lang="css"><span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f4f4f4</span>;\n}\n</code></pre><p><strong>style.css</strong></p>\n<pre><code class="hljs css" lang="css">@<span class="hljs-keyword">import</span> <span class="hljs-string">\'./backgrounds.css\'</span>;\n\n...\n</code></pre><h2 class="heading" data-id="heading-9">10. 使用 sass</h2>\n<p>首先，安装 node-sass。</p>\n<pre><code class="hljs bash" lang="bash">$ npm install node-sass\n</code></pre><p><strong>这里要花费一定时间，请耐心等待</strong></p>\n<p><strong>backgrounds.scss</strong></p>\n<p><strong>注意：这里由 backgrounds.css 改名为 backgrounds.scss</strong></p>\n<pre><code class="hljs css" lang="css">@<span class="hljs-keyword">import</span> <span class="hljs-string">\'./variables.scss\'</span>;\n\n<span class="hljs-selector-tag">body</span> {\n  <span class="hljs-attribute">background</span>: $light-grey;\n}\n</code></pre><p><strong>variables.scss</strong></p>\n<pre><code class="hljs css" lang="css">$light-grey: #f4f4f4;\n</code></pre><p><strong>style.css</strong></p>\n<pre><code class="hljs css" lang="css"><span class="hljs-comment">/* 改名为 scss */</span>\n@<span class="hljs-keyword">import</span> <span class="hljs-string">\'./backgrounds.scss\'</span>;\n...\n</code></pre><p><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fparceljs.org%2F" rel="nofollow noopener noreferrer">Parcel</a> 还有很多好玩的，我们以后再说。</p>\n</div>',__v:0},{tags:["Webpack","前端","Chrome","浏览器"],meta:{updateAt:"2018-02-09T05:06:21.632Z",createAt:"2018-02-09T05:06:21.632Z"},_id:"5a7d2c4da7d59115dcd1f2d8",id:"5a3e71de6fb9a0452846b2ca",title:"Webpack实战-构建离线应用",avatar:"https://dn-mhke0kuv.qbox.me/Ql6BAtKbPPCQ2MCl74XLOMA?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1",author:"浩麟",create_time:"2017 年 12 月 23 日",content:'<div data-v-13f76525="" data-v-3f216172="" class="entry-content post-content juejin-image-viewer__container"><h2 class="heading" data-id="heading-0">认识离线应用</h2>\n<p>你的网页性能优化的再好，如果网络不好那也会导致网页的体验差。\n离线应用是指通过离线缓存技术，让资源在第一次被加载后缓存在本地，下次访问它时就直接返回本地的文件，就算没有网络连接。</p>\n<p>离线应用有以下优点：</p>\n<ul>\n<li>在没有网络的情况下也能打开网页。</li>\n<li>由于部分被缓存的资源直接从本地加载，对用户来说可以加速网页加载速度，对网站运营者来说可以减少服务器压力以及传输流量费用。</li>\n</ul>\n<p>离线应用的核心是离线缓存技术，历史上曾先后出现2种离线离线缓存技术，它们分别是：</p>\n<ol>\n<li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTML%2FUsing_the_application_cache" rel="nofollow noopener noreferrer">AppCache</a> 又叫 Application Cache，目前已经从 Web 标准中删除，请尽量不要使用它。</li>\n<li><a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FService_Worker_API%2FUsing_Service_Workers" rel="nofollow noopener noreferrer">Service Workers</a> 是目前最新的离线缓存技术，是 <a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fhtmlapi%2Fwebworker.html" rel="nofollow noopener noreferrer">Web Worker</a> 的一部分。\n它通过拦截网络请求实现离线缓存，比 AppCache 更加灵活。它也是构建 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2FApps%2FProgressive" rel="nofollow noopener noreferrer">PWA</a> 应用的关键技术之一。</li>\n</ol>\n<p>Service Workers 相比于 AppCache 来说更加灵活，因为它可以通过 JavaScript 代码去控制缓存的逻辑。\n由于第1种技术已经废弃，本节只专注于讲解如何用 Webpack 构建使用了 Service Workers 的网页。</p>\n<h2 class="heading" data-id="heading-1">认识 Service Workers</h2>\n<p>Service Workers 是一个在浏览器后台运行的脚本，它生命周期完全独立于网页。它无法直接访问 DOM，但可以通过 postMessage 接口发送消息来和 UI 进程通信。\n拦截网络请求是 Service Workers 的一个重要功能，通过它能完成离线缓存、编辑响应、过滤响应等功能。</p>\n<p>想更深入的了解 Service Workers，推荐阅读文章<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fgetting-started%2Fprimers%2Fservice-workers%3Fhl%3Dzh-cn" rel="nofollow noopener noreferrer">服务工作线程：简介</a>。</p>\n<h3 class="heading" data-id="heading-2">Service Workers 兼容性</h3>\n<p>目前 Chrome、Firefox、Opera 都已经全面支持 Service Workers，但对于移动端浏览器就不太乐观了，只有高版本的 Android 支持。\n由于 Service Workers 无法通过注入 polyfill 去实现兼容，所以在你打算使用它前请先调查清楚你的网页的运行场景。</p>\n<p>判断浏览器是否支持 Service Workers 的最简单的方法是通过以下代码：</p>\n<pre><code class="hljs js" lang="js"><span class="hljs-comment">// 如果 navigator 对象上存在 serviceWorker 对象，就表示支持</span>\n<span class="hljs-keyword">if</span> (navigator.serviceWorker) {\n  <span class="hljs-comment">// 通过 navigator.serviceWorker 使用</span>\n}\n</code></pre><h3 class="heading" data-id="heading-3">注册 Service Workers</h3>\n<p>要给网页接入 Service Workers，需要在网页加载后注册一个描述 Service Workers 逻辑的脚本。\n代码如下：</p>\n<pre><code class="hljs js" lang="js"><span class="hljs-keyword">if</span> (navigator.serviceWorker) {\n  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">\'DOMContentLoaded\'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-comment">// 调用 serviceWorker.register 注册，参数 /sw.js 为脚本文件所在的 URL 路径</span>\n      navigator.serviceWorker.register(<span class="hljs-string">\'/sw.js\'</span>);\n  });\n}\n</code></pre><p>一旦这个脚本文件被加载，Service Workers 的安装就开始了。这个脚本被安装到浏览器中后，就算用户关闭了当前网页，它仍会存在。\n也就是说第一次打开该网页时 Service Workers 的逻辑不会生效，因为脚本还没有被加载和注册，但是以后再次打开该网页时脚本里的逻辑将会生效。</p>\n<p>在 Chrome 中可以通过打开网址 <code>chrome://inspect/#service-workers</code> 来查看当前浏览器中所有注册了的 Service Workers。</p>\n<h3 class="heading" data-id="heading-4">使用 Service Workers 实现离线缓存</h3>\n<p>Service Workers 在注册成功后会在其生命周期中派发出一些事件，通过监听对应的事件在特点的时间节点上做一些事情。</p>\n<p>在 Service Workers 脚本中，引入了新的关键字 <code>self</code> 代表当前的 Service Workers 实例。</p>\n<p>在 Service Workers 安装成功后会派发出 <code>install</code> 事件，需要在这个事件中执行缓存资源的逻辑，实现代码如下：</p>\n<pre><code class="hljs js" lang="js"><span class="hljs-comment">// 当前缓存版本的唯一标识符，用当前时间代替</span>\n<span class="hljs-keyword">var</span> cacheKey = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString();\n\n<span class="hljs-comment">// 需要被缓存的文件的 URL 列表</span>\n<span class="hljs-keyword">var</span> cacheFileList = [\n  <span class="hljs-string">\'/index.html\'</span>,\n  <span class="hljs-string">\'/app.js\'</span>,\n  <span class="hljs-string">\'/app.css\'</span>\n];\n\n<span class="hljs-comment">// 监听 install 事件</span>\nself.addEventListener(<span class="hljs-string">\'install\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{\n  <span class="hljs-comment">// 等待所有资源缓存完成时，才可以进行下一步</span>\n  event.waitUntil(\n    caches.open(cacheKey).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) </span>{\n      <span class="hljs-comment">// 要缓存的文件 URL 列表</span>\n      <span class="hljs-keyword">return</span> cache.addAll(cacheFileList);\n    })\n  );\n});\n</code></pre><p>接下来需要监听网络请求事件去拦截请求，复用缓存，代码如下：</p>\n<pre><code class="hljs js" lang="js">self.addEventListener(<span class="hljs-string">\'fetch\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{\n  event.respondWith(\n    <span class="hljs-comment">// 去缓存中查询对应的请求</span>\n    caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{\n        <span class="hljs-comment">// 如果命中本地缓存，就直接返回本地的资源</span>\n        <span class="hljs-keyword">if</span> (response) {\n          <span class="hljs-keyword">return</span> response;\n        }\n        <span class="hljs-comment">// 否则就去用 fetch 下载资源</span>\n        <span class="hljs-keyword">return</span> fetch(event.request);\n      }\n    )\n  );\n});\n</code></pre><p>以上就实现了离线缓存。</p>\n<h3 class="heading" data-id="heading-5">更新缓存</h3>\n<p>线上的代码有时需要更新和重新发布，如果这个文件被离线缓存了，那就需要 Service Workers 脚本中有对应的逻辑去更新缓存。\n这可以通过更新 Service Workers 脚本文件做到。</p>\n<p>浏览器针对 Service Workers 有如下机制：</p>\n<ol>\n<li>每次打开接入了 Service Workers 的网页时，浏览器都会去重新下载 Service Workers 脚本文件（所以要注意该脚本文件不能太大），如果发现和当前已经注册过的文件存在字节差异，就将其视为“新服务工作线程”。</li>\n<li>新 Service Workers 线程将会启动，且将会触发其 install 事件。</li>\n<li>当网站上当前打开的页面关闭时，旧 Service Workers 线程将会被终止，新 Service Workers 线程将会取得控制权。</li>\n<li>新 Service Workers 线程取得控制权后，将会触发其 activate 事件。</li>\n</ol>\n<p>新 Service Workers 线程中的 activate 事件就是最佳的清理旧缓存的时间点，代码如下：</p>\n<pre><code class="hljs js" lang="js"><span class="hljs-comment">// 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key </span>\n<span class="hljs-keyword">var</span> cacheWhitelist = [cacheKey];\n\nself.addEventListener(<span class="hljs-string">\'activate\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{\n  event.waitUntil(\n    caches.keys().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cacheNames</span>) </span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(\n        cacheNames.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cacheName</span>) </span>{\n          <span class="hljs-comment">// 不在白名单的缓存全部清理掉</span>\n          <span class="hljs-keyword">if</span> (cacheWhitelist.indexOf(cacheName) === <span class="hljs-number">-1</span>) {\n            <span class="hljs-comment">// 删除缓存</span>\n            <span class="hljs-keyword">return</span> caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n</code></pre><p>最终完整的代码 Service Workers 脚本代码如下：</p>\n<pre><code class="hljs js" lang="js"><span class="hljs-comment">// 当前缓存版本的唯一标识符，用当前时间代替</span>\n<span class="hljs-keyword">var</span> cacheKey = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString();\n\n<span class="hljs-comment">// 当前缓存白名单，在新脚本的 install 事件里将使用白名单里的 key</span>\n<span class="hljs-keyword">var</span> cacheWhitelist = [cacheKey];\n\n<span class="hljs-comment">// 需要被缓存的文件的 URL 列表</span>\n<span class="hljs-keyword">var</span> cacheFileList = [\n  <span class="hljs-string">\'/index.html\'</span>,\n  <span class="hljs-string">\'app.js\'</span>,\n  <span class="hljs-string">\'app.css\'</span>\n];\n\n<span class="hljs-comment">// 监听 install 事件</span>\nself.addEventListener(<span class="hljs-string">\'install\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{\n  <span class="hljs-comment">// 等待所有资源缓存完成时，才可以进行下一步</span>\n  event.waitUntil(\n    caches.open(cacheKey).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) </span>{\n      <span class="hljs-comment">// 要缓存的文件 URL 列表</span>\n      <span class="hljs-keyword">return</span> cache.addAll(cacheFileList);\n    })\n  );\n});\n\n<span class="hljs-comment">// 拦截网络请求</span>\nself.addEventListener(<span class="hljs-string">\'fetch\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{\n  event.respondWith(\n    <span class="hljs-comment">// 去缓存中查询对应的请求</span>\n    caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{\n        <span class="hljs-comment">// 如果命中本地缓存，就直接返回本地的资源</span>\n        <span class="hljs-keyword">if</span> (response) {\n          <span class="hljs-keyword">return</span> response;\n        }\n        <span class="hljs-comment">// 否则就去用 fetch 下载资源</span>\n        <span class="hljs-keyword">return</span> fetch(event.request);\n      }\n    )\n  );\n});\n\n<span class="hljs-comment">// 新 Service Workers 线程取得控制权后，将会触发其 activate 事件</span>\nself.addEventListener(<span class="hljs-string">\'activate\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{\n  event.waitUntil(\n    caches.keys().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cacheNames</span>) </span>{\n      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(\n        cacheNames.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cacheName</span>) </span>{\n          <span class="hljs-comment">// 不在白名单的缓存全部清理掉</span>\n          <span class="hljs-keyword">if</span> (cacheWhitelist.indexOf(cacheName) === <span class="hljs-number">-1</span>) {\n            <span class="hljs-comment">// 删除缓存</span>\n            <span class="hljs-keyword">return</span> caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n</code></pre><h2 class="heading" data-id="heading-6">接入 Webpack</h2>\n<p>用 Webpack 构建接入 Service Workers 的离线应用要解决的关键问题在于如何生成上面提到的 <code>sw.js</code> 文件，\n并且<code>sw.js</code>文件中的 <code>cacheFileList</code> 变量，代表需要被缓存文件的 URL 列表，需要根据输出文件列表所对应的 URL 来决定，而不是像上面那样写成静态值。</p>\n<p>假如构建输出的文件目录结构为：</p>\n<pre><code class="hljs bash" lang="bash">├── app_4c3e186f.js\n├── app_7cc98ad0.css\n└── index.html\n</code></pre><p>那么 <code>sw.js</code> 文件中 <code>cacheFileList</code> 的值应该是：</p>\n<pre><code class="hljs js" lang="js"><span class="hljs-keyword">var</span> cacheFileList = [\n  <span class="hljs-string">\'/index.html\'</span>,\n  <span class="hljs-string">\'app_4c3e186f.js\'</span>,\n  <span class="hljs-string">\'app_7cc98ad0.css\'</span>\n];\n</code></pre><p>Webpack 没有原生功能能完成以上要求，幸好庞大的社区中已经有人为我们做好了一个插件 <a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Foliviertassinari%2Fserviceworker-webpack-plugin" rel="nofollow noopener noreferrer">serviceworker-webpack-plugin</a> 可以方便的解决以上问题。\n使用该插件后的 Webpack 配置如下：</p>\n<pre><code class="hljs js" lang="js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>);\n<span class="hljs-keyword">const</span> ExtractTextPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'extract-text-webpack-plugin\'</span>);\n<span class="hljs-keyword">const</span> { WebPlugin } = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'web-webpack-plugin\'</span>);\n<span class="hljs-keyword">const</span> ServiceWorkerWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'serviceworker-webpack-plugin\'</span>);\n\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">entry</span>: {\n    <span class="hljs-attr">app</span>: <span class="hljs-string">\'./main.js\'</span><span class="hljs-comment">// Chunk app 的 JS 执行入口文件</span>\n  },\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">filename</span>: <span class="hljs-string">\'[name].js\'</span>,\n    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">\'\'</span>,\n  },\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.css/</span>,<span class="hljs-comment">// 增加对 CSS 文件的支持</span>\n        <span class="hljs-comment">// 提取出 Chunk 中的 CSS 代码到单独的文件中</span>\n        use: ExtractTextPlugin.extract({\n          <span class="hljs-attr">use</span>: [<span class="hljs-string">\'css-loader\'</span>] <span class="hljs-comment">// 压缩 CSS 代码</span>\n        }),\n      },\n    ]\n  },\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-comment">// 一个 WebPlugin 对应一个 HTML 文件</span>\n    <span class="hljs-keyword">new</span> WebPlugin({\n      <span class="hljs-attr">template</span>: <span class="hljs-string">\'./template.html\'</span>, <span class="hljs-comment">// HTML 模版文件所在的文件路径</span>\n      filename: <span class="hljs-string">\'index.html\'</span> <span class="hljs-comment">// 输出的 HTML 的文件名称</span>\n    }),\n    <span class="hljs-keyword">new</span> ExtractTextPlugin({\n      <span class="hljs-attr">filename</span>: <span class="hljs-string">`[name].css`</span>,<span class="hljs-comment">// 给输出的 CSS 文件名称加上 Hash 值</span>\n    }),\n    <span class="hljs-keyword">new</span> ServiceWorkerWebpackPlugin({\n      <span class="hljs-comment">// 自定义的 sw.js 文件所在路径</span>\n      <span class="hljs-comment">// ServiceWorkerWebpackPlugin 会把文件列表注入到生成的 sw.js 中</span>\n      entry: path.join(__dirname, <span class="hljs-string">\'sw.js\'</span>),\n    }),\n  ],\n  <span class="hljs-attr">devServer</span>: {\n    <span class="hljs-comment">// Service Workers 依赖 HTTPS，使用 DevServer 提供的 HTTPS 功能。</span>\n    https: <span class="hljs-literal">true</span>,\n  }\n};\n</code></pre><p>以上配置有2点需要注意：</p>\n<ul>\n<li>由于 Service Workers 必须在 HTTPS 环境下才能拦截网络请求实现离线缓存，使用在 <a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fwebpack.wuhaolin.cn%2F2%25E9%2585%258D%25E7%25BD%25AE%2F2-6DevServer.html" rel="nofollow noopener noreferrer">2-6 DevServer https</a> 中提到的方式去实现 HTTPS 服务。</li>\n<li>serviceworker-webpack-plugin 插件为了保证灵活性，允许使用者自定义 <code>sw.js</code>，构建输出的 <code>sw.js</code> 文件中会在头部注入一个变量 <code>serviceWorkerOption.assets</code> 到全局，里面存放着所有需要被缓存的文件的 URL 列表。</li>\n</ul>\n<p>需要修改上面的 <code>sw.js</code> 文件中写成了静态值的 <code>cacheFileList</code> 为如下：</p>\n<pre><code class="hljs js" lang="js"><span class="hljs-comment">// 需要被缓存的文件的 URL 列表</span>\n<span class="hljs-keyword">var</span> cacheFileList = global.serviceWorkerOption.assets;\n</code></pre><p>以上已经完成所有文件的修改，在重新构建前，先安装新引入的依赖：</p>\n<pre><code class="hljs bash" lang="bash">npm i -D serviceworker-webpack-plugin webpack-dev-server\n</code></pre><p>安装成功后，在项目根目录下执行 <code>webpack-dev-server</code> 命令后，DevServer 将以 HTTPS 模式启动，并输出如下日志：</p>\n<pre><code class="hljs bash" lang="bash">&gt; webpack-dev-server\n\nProject is running at https://localhost:8080/\nwebpack output is served from /\nHash: 402ee6ce5bffb16dffe2\nVersion: webpack 3.5.5\nTime: 619ms\n     Asset       Size  Chunks                    Chunk Names\n    app.js     325 kB       0  [emitted]  [big]  app\n   app.css   21 bytes       0  [emitted]         app\nindex.html  235 bytes          [emitted]         \n     sw.js    4.86 kB          [emitted]         \n</code></pre><p>用 Chrome 浏览器打开网址 <code>https://localhost:8080/index.html</code> 后，就能访问接入了 Service Workers 离线缓存的页面了。</p>\n<h2 class="heading" data-id="heading-7">验证结果</h2>\n<p>为了验证 Service Workers 和缓存生效了，需要通过 Chrome 的开发者工具来查看。</p>\n<p>通过打开开发者工具的 Application-Service Workers 一栏，就能看到当前页面注册的 Service Workers，正常的效果如图：</p>\n<p></p><figure><img alt="图3.12.1 查看当前页面注册的 Service Workers" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/23/16083ecc3d9f9acf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="1258" data-height="444" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1258&quot; height=&quot;444&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<p>通过打开开发者工具的 Application-Cache-Cache Storage 一栏，能看到当前页面缓存的资源列表，正常的效果如图：</p>\n<p></p><figure><img alt="图3.12.2 查看当前页面的 Cache Storage" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/23/16083ecc3ec9968c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="1280" data-height="284" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;284&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<p>为了验证网页在离线时能访问的能力，需要在开发者工具中的 Network 一栏中通过 Offline 选项禁用掉网络，再刷新页面能正常访问，并且网络请求的响应都来自 Service Workers，正常的效果如图：</p>\n<p></p><figure><img alt="图3.12.3 离线情况下访问页面" class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/23/16083ecc41e583aa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="1280" data-height="305" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;305&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></figure><p></p>\n<blockquote>\n<p>本实例<a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fwebpack.wuhaolin.cn%2F3-14%25E6%259E%2584%25E5%25BB%25BA%25E7%25A6%25BB%25E7%25BA%25BF%25E5%25BA%2594%25E7%2594%25A8.zip" rel="nofollow noopener noreferrer">提供项目完整代码</a></p>\n</blockquote>\n<p><a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fwebpack.wuhaolin.cn%2F" rel="nofollow noopener noreferrer"></a></p><figure><a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fwebpack.wuhaolin.cn%2F" rel="nofollow noopener noreferrer"><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/20/1607259d52144ee4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="1280" data-height="802" src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;802&quot;&gt;&lt;/svg&gt;"><figcaption></figcaption></a></figure><p></p>\n<p><a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fwebpack.wuhaolin.cn%2F" rel="nofollow noopener noreferrer">《深入浅出Webpack》全书在线阅读链接</a></p>\n<p><a target="_blank" href="https://link.juejin.im?target=http%3A%2F%2Fwebpack.wuhaolin.cn%2F3%25E5%25AE%259E%25E6%2588%2598%2F3-14%25E6%259E%2584%25E5%25BB%25BA%25E7%25A6%25BB%25E7%25BA%25BF%25E5%25BA%2594%25E7%2594%25A8.html" rel="nofollow noopener noreferrer">阅读原文</a></p>\n</div>',__v:0}],count:62}],error:null,state:{user:{userInfo:{}},article:{articleDetail:{}}},serverRendered:!0}</script><script src="/_nuxt/manifest.fbc6bd9770885bc7a818.js" defer></script><script src="/_nuxt/layouts_default.57c9bebbe8d2e3396b4a.js" defer></script><script src="/_nuxt/pages_article_index.23c3cff31bc7808389c3.js" defer></script><script src="/_nuxt/vendor.cb6db4276c8094660c7c.js" defer></script><script src="/_nuxt/app.a588a7cc70431adbc41f.js" defer></script>
  

