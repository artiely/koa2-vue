[{
  "title": "下一代状态管理工具 immer 简介及源码解析",
  "content": "<div data-v-13f76525=\"\" data-v-3f216172=\"\" class=\"entry-content post-content juejin-image-viewer__container\"><blockquote>\n<p>博客链接：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fzhangzhao.name%2F2018%2F02%2F01%2Fimmer%2520-%2520immutable%2F\" rel=\"nofollow noopener noreferrer\">下一代状态管理工具 immer 简介及源码解析</a></p>\n</blockquote>\n<p>JS 里面的变量类型可以大致分为基本类型和引用类型。在使用过程中，引用类型经常会产生一些无法意识到的副作用，所以在现代 JS 开发过程中，大家都有意识的写下断开引用的不可变数据类型。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-comment\">// 引用带来的副作用</span>\n<span class=\"hljs-keyword\">var</span> a = [{ <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">1</span> }]\n<span class=\"hljs-keyword\">var</span> b = a.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.val = <span class=\"hljs-number\">2</span>)\n\n<span class=\"hljs-comment\">// 期望：b 的每一个元素的 val 值变为 2</span>\n<span class=\"hljs-built_in\">console</span>.log(a[<span class=\"hljs-number\">0</span>].val) <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<div class=\"tip\">\n  从上述例子我们可以发现，本意是只想让 b 中的每一个元素的值变为 2 ，但却无意中改掉了 a 中每一个元素的结果，这是不符合预期的。接下来如果某个地方使用到了 a ，很容易发生一些我们难以预料并且难以 debug 的 bug。\n</div>\n<p>在有了这样的问题之后，一般来说当需要传递一个对象进一个函数时，我们可以使用 <code>Object.assign</code> 或者 <code>...</code> 对对象进行解构，成功断掉一层的引用。</p>\n<p>例如上面的问题我们可以改用下面的这种写法：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">var</span> a = [{ <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">1</span> }]\n<span class=\"hljs-keyword\">var</span> b = a.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> ({ ...item, <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">2</span> }))\n\n<span class=\"hljs-built_in\">console</span>.log(a[<span class=\"hljs-number\">0</span>].val) <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">console</span>.log(b[<span class=\"hljs-number\">0</span>].val) <span class=\"hljs-comment\">// 2</span>\n</code></pre><p>这样做其实还会有一个问题，无论是 <code>Object.assign</code> 还是 <code>...</code> 的解构操作，断掉的引用也只是一层，如果对象嵌套超过一层，这样做还是有一定的风险。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">var</span> a = [\n  { <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">desc</span>: { <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'a'</span> } }\n]\n<span class=\"hljs-keyword\">var</span> b = a.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> ({ ...item, <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">2</span> }))\n\n<span class=\"hljs-built_in\">console</span>.log(a === b)           <span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">console</span>.log(a.desc === b.desc) <span class=\"hljs-comment\">// true</span>\n</code></pre><p>这样一来，后面的代码如果一不小心在一个函数内部给 <code>b.desc</code> 对象里面的内容通过“点”进行赋值，就一定会改变具有相同引用的 <code>a.desc</code> 部分的值，这当然是不符合我们的预期的。</p>\n<p>所以在这之后，大多数情况下我们会考虑 <strong>深拷贝</strong> 这样的操作来完全避免上面遇到的所有问题。深拷贝，顾名思义就是在遍历过程中，如果遇到了可能出现引用的数据类型，就会递归的完全创建一个新的类型。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-comment\">// 一个简单的深拷贝函数，去掉了一些胶水部分</span>\n<span class=\"hljs-comment\">// 用户态输入一定是一个 Plain Object，并且所有 value 也是 Plain Object</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepClone</span>(<span class=\"hljs-params\">a</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> keys = <span class=\"hljs-built_in\">Object</span>.keys(a)\n  <span class=\"hljs-keyword\">return</span> keys.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">memo, current</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> value = a[current]\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">'object'</span>) {\n      <span class=\"hljs-keyword\">return</span> {\n        ...memo,\n        [current]: deepClone(value),\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> {\n      ...memo,\n      [current]: value,\n    }\n  }, {})\n}\n</code></pre><p>用上面的 deepClone 函数进行简单测试</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">var</span> a = {\n  <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">desc</span>: {\n    <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'a'</span>,\n  },\n}\n<span class=\"hljs-keyword\">var</span> b = deepClone(a)\n\nb.val = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-built_in\">console</span>.log(a.val) <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">console</span>.log(b.val) <span class=\"hljs-comment\">// 2</span>\n\nb.desc.text = <span class=\"hljs-string\">'b'</span>\n<span class=\"hljs-built_in\">console</span>.log(a.desc.text) <span class=\"hljs-comment\">// 'a'</span>\n<span class=\"hljs-built_in\">console</span>.log(b.desc.text) <span class=\"hljs-comment\">// 'b'</span>\n</code></pre><p>上面的这个 <code>deepClone</code> 可以满足简单的需求，但是真正在生产工作中，我们需要考虑非常多的因素。举例来说：</p>\n<ul>\n<li>key 里面 getter，setter 以及原型链上的内容如何处理</li>\n<li>value 是一个 Symbol 如何处理</li>\n<li>value 是其他非 Plain Object 如何处理</li>\n<li>value 内部出现了一些循环引用如何处理</li>\n</ul>\n<p>因为有太多不确定因素，所以我还是推荐使用大型开源项目里面的工具函数，比较常用的为大家所熟知的就是 <code>lodash.cloneDeep</code>，无论是安全性还是效果都有所保障。</p>\n<p>其实，这样的概念我们常称作 immutable ，意为不可变的数据，其实理解为不可变关系更为恰当。每当我们创建一个被 <code>deepClone</code> 过的数据，新的数据进行有副作用 (side effect) 的操作都不会影响到之前的数据，这也就是 immutable 的精髓和本质。</p>\n<p>然而 deepClone 这种函数虽然断绝了引用关系实现了 immutable，但是开销实在太大。所以在 2014 年，facebook 的 immutable-js 横空出世，即保证了 immutable ，又兼顾了性能。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">immutable-js 简介</h2>\n<p>immutable-js 使用了另一套数据结构的 API ，与我们的常见操作有些许不同，它将所有的原生对象都会转化成 immutable-js 的内部对象，并且任何操作最终都会返回一个新的 immutable 的值。</p>\n<p>上面的例子使用 immutable-js 就需要这样改造一下：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> { fromJS } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'immutable'</span>)\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">val</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">desc</span>: {\n    <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'a'</span>,\n  },\n}\n\n<span class=\"hljs-keyword\">const</span> a = fromJS(data)\n\n<span class=\"hljs-keyword\">const</span> b = a.set(<span class=\"hljs-string\">'val'</span>, <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-built_in\">console</span>.log(a.get(<span class=\"hljs-string\">'val'</span>)) <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">console</span>.log(b.get(<span class=\"hljs-string\">'val'</span>)) <span class=\"hljs-comment\">// 2</span>\n\n<span class=\"hljs-keyword\">const</span> pathToText = [<span class=\"hljs-string\">'desc'</span>, <span class=\"hljs-string\">'text'</span>]\n<span class=\"hljs-keyword\">const</span> c = a.setIn([...pathToText], <span class=\"hljs-string\">'c'</span>)\n<span class=\"hljs-built_in\">console</span>.log(a.getIn([...pathToText])) <span class=\"hljs-comment\">// 'a'</span>\n<span class=\"hljs-built_in\">console</span>.log(c.getIn([...pathToText])) <span class=\"hljs-comment\">// 'c'</span>\n</code></pre><p>对于性能方面，immutable-js 也有它的优势，举个简单的例子：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> { fromJS } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'immutable'</span>)\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">content</span>: {\n    <span class=\"hljs-attr\">time</span>: <span class=\"hljs-string\">'2018-02-01'</span>,\n    <span class=\"hljs-attr\">val</span>: <span class=\"hljs-string\">'Hello World'</span>,\n  },\n  <span class=\"hljs-attr\">desc</span>: {\n    <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'a'</span>,\n  },\n}\n\n<span class=\"hljs-keyword\">const</span> a = fromJS(data)\n<span class=\"hljs-keyword\">const</span> b = a.setIn([<span class=\"hljs-string\">'desc'</span>, <span class=\"hljs-string\">'text'</span>], <span class=\"hljs-string\">'b'</span>)\n<span class=\"hljs-built_in\">console</span>.log(b.get(<span class=\"hljs-string\">'desc'</span>) === a.get(<span class=\"hljs-string\">'desc'</span>))       <span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">console</span>.log(b.get(<span class=\"hljs-string\">'content'</span>) === a.get(<span class=\"hljs-string\">'content'</span>)) <span class=\"hljs-comment\">// true</span>\n\n<span class=\"hljs-keyword\">const</span> c = a.toJS()\n<span class=\"hljs-keyword\">const</span> d = b.toJS()\n<span class=\"hljs-built_in\">console</span>.log(c.desc === d.desc)       <span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">console</span>.log(c.content === d.content) <span class=\"hljs-comment\">// false</span>\n</code></pre><p>从上面的例子可以看出来，在 immutable-js 的数据结构中，深层次的对象在没有修改的情况下仍然能够保证严格相等。这里的严格相等就可以认为是没有新建这个对象，仍然在内部保持着之前的引用，但是修改却不会同步的修改。</p>\n<p>经常使用 React 的同学肯定也对 immutable-js 不陌生，这也就是为什么 immutable-js 会极大提高 React 页面性能的原因之一了。</p>\n<p>当然能够达到 immutable 效果的当然不只这几个个例，这篇文章我主要想介绍实现 immutable 的库其实是 immer。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">immer 简介</h2>\n<p>immer 的作者同时也是 mobx 的作者，一个看起来非常感性的中年大叔。mobx 又像是把 Vue 的一套东西融合进了 React，已经在社区取得了不错的反响。immer 则是他在 immutable 方面所做的另一个实践，在 2018-02-01，immer 成功发布了 <strong>1.0.0</strong> 版本，我差不多在一个月前开始关注这个项目，所以大清早看到作者在 twitter 上发的通告，有感而发今天写下这篇文章，算是简单介绍一下 immer 这个 immutable 框架的使用以及内部简单的实现原理。</p>\n<p>与 immutable-js 最大的不同，immer 是使用原生数据结构的 API 而不是内置的 API，举个简单例子：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> produce = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'immer'</span>)\n\n<span class=\"hljs-keyword\">const</span> state = {\n  <span class=\"hljs-attr\">done</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">val</span>: <span class=\"hljs-string\">'string'</span>,\n}\n\n<span class=\"hljs-keyword\">const</span> newState = produce(state, (draft) =&gt; {\n  draft.done = <span class=\"hljs-literal\">true</span>\n})\n\n<span class=\"hljs-built_in\">console</span>.log(state.done) <span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">console</span>.log(newState.done) <span class=\"hljs-comment\">// true</span>\n</code></pre><p>所有需要更改的逻辑都可以放进 produce 的第二个参数的函数内部，即使给对象内的元素直接赋值，也不会对原对象产生任何影响。</p>\n<p>简单介绍完使用之后，下面就开始简单介绍它的内部实现。不过在这之前，想先通过上面的例子简单的发散思考一下。</p>\n<p>通过文章最开始的例子我们就能明白，给函数传入一个对象，直接通过“点”操作符对里面的一个属性进行更改是一定会改变外面的结果的。而上面的这个例子中，<code>draft</code> 参数穿入进去，与 <code>state</code> 一样也有 done 这个属性，但是在通过 <code>draft.done</code> 改变值之后，原来的 <code>state.done</code> 并没有发生改变。其实到这里，结合之前研究 vue 源码的经验，我当时就笃定，这里一定用了 <code>Object.defineProperty</code>，draft 通过“点”操作的之后，一些数据的结果被劫持了，然后做了一些新的操作。</p>\n<h2 class=\"heading\" data-id=\"heading-2\">immer 原理解析</h2>\n<p>真正翻开源码，诚然里面确实有 defineProperty 的身影，不过在另一个标准的文件中，用了一种新的方式，那就是 ES6 中新增的 Proxy 对象。而在日常的业务过程中，应该很少有前端工程师会用到 Proxy 对象，因为它的应用场景确实有些狭隘，所以这里简单介绍一下 Proxy 对象的使用。</p>\n<p>Proxy 对象接受两个参数，第一个参数是需要操作的对象，第二个参数是设置对应拦截的属性，这里的属性同样也支持 get，set 等等，也就是劫持了对应元素的读和写，能够在其中进行一些操作，最终返回一个 Proxy 对象。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>({}, {\n  get(target, key) {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'proxy get key'</span>, key)\n  },\n  set(target, key, value) {\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'value'</span>, value)\n  }\n})\n\nproxy.info     <span class=\"hljs-comment\">// 'proxy get key info'</span>\nproxy.info = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 'value 1'</span>\n</code></pre><p>上面这个例子中传入的第一个参数是一个空对象，当然我们可以用其他对象有内容的对象代替它。例如维护一份 state 在内部，来判断是否有变化，下面这个例子就是一个构造函数，如果将它的实例传入 Proxy 对象作为第一个参数，就能够后面的处理对象中使用其中的方法：</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Store</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(state) {\n    <span class=\"hljs-keyword\">this</span>.modified = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">this</span>.source = state\n    <span class=\"hljs-keyword\">this</span>.copy = <span class=\"hljs-literal\">null</span>\n  }\n  get(key) {\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.modified) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.source[key]\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.copy[key]\n  }\n  set(key, value) {\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.modified) <span class=\"hljs-keyword\">this</span>.modifing()\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.copy[key] = value\n  }\n  modifing() {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.modified) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">this</span>.modified = <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">this</span>.copy = <span class=\"hljs-built_in\">Array</span>.isArray(<span class=\"hljs-keyword\">this</span>.source)\n      ? <span class=\"hljs-keyword\">this</span>.source.slice()\n      : { ...this.source }\n  }\n}\n</code></pre><p>上面这个构造函数相比源代码省略了很多判断的部分。实例上面有 modified，source，copy 三个属性，有 get，set，modifing 三个方法。modified 作为内置的 flag，判断如何进行设置和返回。</p>\n<p>里面最关键的就应该是 <code>modifing</code> 这个函数，如果触发了 setter 并且之前没有改动过的话，就会手动将 <code>modified</code> 这个 flag 设置为 <code>true</code>，并且手动通过原生的 API 实现一层 immutable。</p>\n<p>对于 Proxy 的第二个参数，就更加简单了。在这个例子中，只是简单做一层转发，任何对元素的读取和写入都转发到前面的实例内部方法去。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> PROXY_FLAG = <span class=\"hljs-string\">'@@SYMBOL_PROXY_FLAG'</span>\n<span class=\"hljs-keyword\">const</span> handler = {\n  get(target, key) {\n    <span class=\"hljs-keyword\">if</span> (key === PROXY_FLAG) <span class=\"hljs-keyword\">return</span> target\n    <span class=\"hljs-keyword\">return</span> target.get(key)\n  },\n  set(target, key, value) {\n    <span class=\"hljs-keyword\">return</span> target.set(key, value)\n  },\n}\n</code></pre><div class=\"tip\">这里在 getter 里面加一个 flag 的目的就在于将来从 proxy 对象中获取 store 实例更加方便。</div>\n<p>最终我们能够完成这个 produce 函数，创建 store 实例后创建 proxy 实例。然后将创建的 proxy 实例传入第二个函数中去。这样无论在内部做怎样有副作用的事情，最终都会在 store 实例内部将它解决。最终得到了修改之后的 proxy 对象，而 proxy 对象内部已经维护了两份 state ，通过判断 modified 的值来确定究竟返回哪一份。</p>\n<pre><code class=\"hljs js\" lang=\"js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">produce</span>(<span class=\"hljs-params\">state, producer</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> store = <span class=\"hljs-keyword\">new</span> Store(state)\n  <span class=\"hljs-keyword\">const</span> proxy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(store, handler)\n\n  producer(proxy)\n\n  <span class=\"hljs-keyword\">const</span> newState = proxy[PROXY_FLAG]\n  <span class=\"hljs-keyword\">if</span> (newState.modified) <span class=\"hljs-keyword\">return</span> newState.copy\n  <span class=\"hljs-keyword\">return</span> newState.source\n}\n</code></pre><p>这样，一个分割成 Store 构造函数，handler 处理对象和 produce 处理 state 这三个模块的最简版就完成了，将它们组合起来就是一个最最最 tiny 版的 immer ，里面去除了很多不必要的校验和冗余的变量。但真正的 immer 内部也有其他的功能，例如深度克隆情况下的结构共享等等。</p>\n<p>如果真的对这部分逻辑感兴趣的话，可以直接读作者的源码 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmweststrate%2Fimmer\" rel=\"nofollow noopener noreferrer\">immer</a> 或者看我自己写的继续深入了一层的源码 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Floatheb%2Ftiny-all-over-the-world%2Fblob%2Fmaster%2Fimmutable%2Fimmer%2Findex.js\" rel=\"nofollow noopener noreferrer\">tiny-immer</a> 。写这篇文章的目的并不是一开始就让读者深入进去，而是在以后小型项目有了另一个 immutable 的选择。</p>\n<h2 class=\"heading\" data-id=\"heading-3\">性能</h2>\n<p>性能方面，就用 immer 官方 README 里面的介绍来说明情况。</p>\n<p>这是一个关于 immer 性能的简单测试。这个测试使用了 100000 个组件元素，并且更新其中的 10000 个。freeze 表示状态树在生成之后已被冻结。这是一个最佳的开发实践，因为它可以防止开发人员意外修改状态树。</p>\n<p></p><figure><img class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/2/2/16155119d47ad76c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"775\" data-height=\"535\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;775&quot; height=&quot;535&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>通过上图的观察，基本可以得出：</p>\n<ul>\n<li>\n<p>从 immer 的角度来看，这个性能环境比其他框架和库要恶劣的多，因为它必须代理的根节点相对于其余的数据集来说大得多</p>\n</li>\n<li>\n<p>从 mutate 和 deepclone 来看，mutate 基准确定了数据更改费用的基线，没有不可变性（或深度克隆情况下的结构共享）</p>\n</li>\n<li>\n<p>使用 Proxy 的 immer 大概是手写 reducer 的两倍，当然这在实践中可以忽略不计</p>\n</li>\n<li>\n<p>immer 大致和 immutable-js 一样快。但是，immutable-js 最后经常需要 toJS 操作，这里的性能的开销是很大的。例如将不可变的 JS 对象转换回普通的对象，将它们传递给组件中，或着通过网络传输等等（还有将从例如服务器接收到的数据转换为 immutable-js 内置对象的前期成本）</p>\n</li>\n<li>\n<p>immer 的 ES5 实现速度明显较慢。对于大多数的 reducer 来说，这并不重要，因为处理大量数据的 reducer 可以完全不（或者仅部分）使用 immer 的 produce 函数。幸运的是，immer 完全支持这种选择性加入的情况</p>\n</li>\n<li>\n<p>在 freeze 的版本中，只有 mutate，deepclone 和原生 reducer 才能够递归地冻结全状态树，而其他测试用例只冻结树的修改部分</p>\n</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-4\">写在后面</h2>\n<p>其实纵观 immer 的实现，核心的原理就是放在了对对象读写的劫持，从表现形式上立刻就能让人想到 vue ，mobx 从核心原理上来说也是对对象的读写劫持，最近有另一篇非常火的文章 -- 如何让 <code>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)</code> 为 true，也相信不少的小伙伴读过，除了那个肉眼不可见字符的答案，其他答案也算是对对象的读写劫持从而达到目标。</p>\n<p>所以说在 JS 中，很多知识相辅相成，有多少种方式能让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 为 true，理论上有多少种答案就会有多少种 MVVM 的组成方式，甚至就有多少种方法能够实现这样的 immutable。所以任何一点点小的知识点的聚合，未来都可能影响前端的发展。</p>\n<p>最近我个人也在整理所有开源框架的最小实现，项目代码现在都放在 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Floatheb%2Ftiny-all-over-the-world\" rel=\"nofollow noopener noreferrer\">tiny-all-the-world</a> 。它的目的就在于把前端常用框架类库实现一个没有第三方依赖的简易版，希望大家也能够从其中有所学习。</p>\n</div>"
}, {
  "title": "我未曾见过的 JS 特性",
  "content": "<div data-v-13f76525=\"\" data-v-3f216172=\"\" class=\"entry-content post-content juejin-image-viewer__container\"><blockquote>\n<ul>\n<li>原文地址：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fair.ghost.io%2Fjs-things-i-never-knew-existed%2F\" rel=\"nofollow noopener noreferrer\">JS things I never knew existed</a></li>\n<li>原文作者：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fair.ghost.io%2F\" rel=\"nofollow noopener noreferrer\">Skyllo</a></li>\n<li>译文出自：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner\" rel=\"nofollow noopener noreferrer\">掘金翻译计划</a></li>\n<li>本文永久链接：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%2Fblob%2Fmaster%2FTODO%2Fjs-things-i-never-knew-existed.md\" rel=\"nofollow noopener noreferrer\">github.com/xitu/gold-m…</a></li>\n<li>译者：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FNeilLi1992\" rel=\"nofollow noopener noreferrer\">Yong Li</a></li>\n<li>校对者：<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FrealYukiko\" rel=\"nofollow noopener noreferrer\">Yukiko</a>，<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fdazhi1011\" rel=\"nofollow noopener noreferrer\">dz</a></li>\n</ul>\n</blockquote>\n<h1 class=\"heading\" data-id=\"heading-0\">我未曾见过的 JS 特性</h1>\n<p>有一天我正在阅读 MDN 文档，发现了一些我之前压根没有意识到在 JS 中存在的特性和 API。这里我罗列了一些，不管它们是否有用，JS 的学习永无止境。</p>\n<h2 class=\"heading\" data-id=\"heading-1\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Flabel\" rel=\"nofollow noopener noreferrer\">标记语句</a></h2>\n<p>有多少人知道在 JS 里你可以给 <code>for</code> 循环和语句块命名？反正我不知道…… 命名完新名称之后你可以在 <code>for</code> 循环中的 <code>break</code> 和 <code>continue</code> 之后、语句块中的 <code>break</code> 之后\u001d使用新名称。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">loop1: // 标记 <span class=\"hljs-string\">\"loop1\"</span> \n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> i = 0; i &lt; 3; i++) { // <span class=\"hljs-string\">\"loop1\"</span>\n   loop2: // 标记 <span class=\"hljs-string\">\"loop2\"</span>\n   <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> j = 0; j &lt; 3; j++) { // <span class=\"hljs-string\">\"loop2\"</span>\n      <span class=\"hljs-keyword\">if</span> (i === 1) {\n         <span class=\"hljs-built_in\">continue</span> loop1; // 继续外层的 <span class=\"hljs-string\">\"loop1\"</span> 循环\n         // <span class=\"hljs-built_in\">break</span> loop1; // 中止外层的 <span class=\"hljs-string\">\"loop1\"</span> 循环\n      }\n      console.log(`i = <span class=\"hljs-variable\">${i}</span>, j = <span class=\"hljs-variable\">${j}</span>`);\n   }\n}\n\n/* \n * <span class=\"hljs-comment\"># 输出</span>\n * i = 0, j = 0\n * i = 0, j = 1\n * i = 0, j = 2\n * i = 2, j = 0\n * i = 2, j = 1\n * i = 2, j = 2\n */\n</code></pre><p>下面是语句块命名的例子，在语句块中你只能在 <code>break</code> 之后使用新命名。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">foo: {\n  console.log(<span class=\"hljs-string\">'one'</span>);\n  <span class=\"hljs-built_in\">break</span> foo;\n  console.log(<span class=\"hljs-string\">'这句打印不会被执行'</span>);\n}\nconsole.log(<span class=\"hljs-string\">'two'</span>);\n\n/*\n * <span class=\"hljs-comment\"># 输出</span>\n * one\n * two\n */\n</code></pre><h2 class=\"heading\" data-id=\"heading-2\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fvoid\" rel=\"nofollow noopener noreferrer\">\"void\" 运算符</a></h2>\n<p>我一度以为我已经了解了所有的运算符，直到我看到了这一个。它从 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FNew_in_JavaScript%2F1.1\" rel=\"nofollow noopener noreferrer\">1996 年</a> 起就存在于 JS 了。所有的浏览器都支持，并且它也很容易理解，引用自 MDN：</p>\n<blockquote>\n<p>void 运算符对给定的表达式进行求值，然后返回 undefined。</p>\n</blockquote>\n<p>使用它，你可以换一种方式来写立即调用的函数表达式（IIFE），就像这样：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">void <span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">iife</span></span>() {\n\tconsole.log(<span class=\"hljs-string\">'hello'</span>);\n}();\n\n// 和下面等效\n\n(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">iife</span></span>() {\n    console.log(<span class=\"hljs-string\">'hello'</span>);\n})()\n</code></pre><p>使用 <code>void</code> 的一个注意点是，无论给定的表达式返回结果是什么，void 运算符的整体结果都是空的（undefined）！</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">const word = void <span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">iife</span></span>() {\n\t<span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'hello'</span>;\n}();\n\n// word 是 `undefined`\n\nconst word = (<span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">iife</span></span>() {\n\t<span class=\"hljs-built_in\">return</span> <span class=\"hljs-string\">'hello'</span>;\n})();\n\n// word 是 <span class=\"hljs-string\">\"hello\"</span>\n</code></pre><p>你也可以和 <code>async</code> 一起使用 <code>void</code>，这样你就能把函数作为异步代码的入口：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">void async <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>() { \n    try {\n        const response = await fetch(<span class=\"hljs-string\">'air.ghost.io'</span>); \n        const text = await response.text();\n        console.log(text);\n    } catch(e) {\n        console.error(e);\n    }\n}()\n\n// 或者保持下面的写法\n\n(async () =&gt; {\n    try {\n        const response = await fetch(<span class=\"hljs-string\">'air.ghost.io'</span>); \n        const text = await response.text();\n        console.log(text);\n    } catch(e) {\n        console.error(e);\n    }\n})();\n</code></pre><h2 class=\"heading\" data-id=\"heading-3\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FComma_Operator\" rel=\"nofollow noopener noreferrer\">逗号运算符</a></h2>\n<p>在学习了逗号运算符之后，我意识到了之前我并不完全清楚其工作原理。下面是来自 MDN 的引用：</p>\n<blockquote>\n<p>逗号运算符对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p>\n</blockquote>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-function\"><span class=\"hljs-title\">myFunc</span></span>() {\n  <span class=\"hljs-built_in\">let</span> x = 0;\n  <span class=\"hljs-built_in\">return</span> (x += 1, x); // 等价于 <span class=\"hljs-built_in\">return</span> ++x;\n}\n\ny = <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">true</span>; // console 中得到 <span class=\"hljs-literal\">true</span>\nconsole.log(y); // <span class=\"hljs-literal\">false</span>，逗号优先级低于赋值\n\nz = (<span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">true</span>); // console 中得到 <span class=\"hljs-literal\">true</span>\nconsole.log(z); // <span class=\"hljs-literal\">true</span>，括号中整体返回 <span class=\"hljs-literal\">true</span>\n</code></pre><h3 class=\"heading\" data-id=\"heading-4\">配合 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FConditional_Operator\" rel=\"nofollow noopener noreferrer\">条件运算符</a></h3>\n<p>逗号运算符中的最后一个值作为返回给条件运算符的值，因此你可以在最后一个值前面放任意多个表达式。在下面的例子中，我在返回的布尔值之前放了打印语句。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">const <span class=\"hljs-built_in\">type</span> = <span class=\"hljs-string\">'man'</span>;\n\nconst isMale = <span class=\"hljs-built_in\">type</span> === <span class=\"hljs-string\">'man'</span> ? (\n    console.log(<span class=\"hljs-string\">'Hi Man!'</span>),\n    <span class=\"hljs-literal\">true</span>\n) : (\n    console.log(<span class=\"hljs-string\">'Hi Lady!'</span>),\n    <span class=\"hljs-literal\">false</span>\n);\n\nconsole.log(`isMale is <span class=\"hljs-string\">\"<span class=\"hljs-variable\">${isMale}</span>\"</span>`);\n</code></pre><h2 class=\"heading\" data-id=\"heading-5\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FIntl\" rel=\"nofollow noopener noreferrer\">国际化 API</a></h2>\n<p>即使在最有利的情况下，国际化还是很难做好。幸好还有一套大部分浏览器都支持得不错的 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fcaniuse.com%2F%23feat%3Dinternationalization\" rel=\"nofollow noopener noreferrer\">API</a>。其中我最爱的一个特性就是日期格式化，见下面的例子：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">const date = new Date();\n\nconst options = {\n  year: <span class=\"hljs-string\">'numeric'</span>, \n  month: <span class=\"hljs-string\">'long'</span>, \n  day: <span class=\"hljs-string\">'numeric'</span>\n};\n\nconst formatter1 = new Intl.DateTimeFormat(<span class=\"hljs-string\">'es-es'</span>, options);\nconsole.log(formatter1.format(date)); // 22 de diciembre de 2017\n\nconst formatter2 = new Intl.DateTimeFormat(<span class=\"hljs-string\">'en-us'</span>, options);\nconsole.log(formatter2.format(date)); // December 22, 2017\n</code></pre><h2 class=\"heading\" data-id=\"heading-6\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FPipeline_operator\" rel=\"nofollow noopener noreferrer\">管道操作符</a></h2>\n<p>在此篇成文之时，该功能只有 Firefox 58 及以上版本通过传入启动参数来支持，不过 Babel 已经有一个针对它的 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel%2Ftree%2Fmaster%2Fpackages%2Fbabel-plugin-proposal-pipeline-operator\" rel=\"nofollow noopener noreferrer\">插件提议</a>。它看起来应该是受到 bash 的启发，我觉得很棒！</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">const square = (n) =&gt; n * n;\nconst increment = (n) =&gt; n + 1;\n\n// 不使用管道操作符\nsquare(increment(square(2))); // 25\n\n// 使用管道操作符\n2 |&gt; square |&gt; increment |&gt; square; // 25\n</code></pre><h2 class=\"heading\" data-id=\"heading-7\">值得一提</h2>\n<h3 class=\"heading\" data-id=\"heading-8\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FAtomics\" rel=\"nofollow noopener noreferrer\">Atomics</a></h3>\n<p>当数据被多个线程共享时，原子操作确保正在读和写的数据是符合预期的，即下一个原子操作一定会在上一个原子操作结束之后才会开始。这有利于保持不同线程间的数据同步（比如主线程和另一条 WebWorker 线程）。</p>\n<p>我很喜欢如 Java 等其它语言中的原子性。我预感当越来越多的人使用 WebWorkers，将操作从主线程分离出来时，原子操作的使用会越来越广泛。</p>\n<h3 class=\"heading\" data-id=\"heading-9\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2FReduceRight\" rel=\"nofollow noopener noreferrer\">Array.prototype.reduceRight</a></h3>\n<p>好吧，我之前从未见过这个，因为它基本等同于 <code>Array.prototype.reduce()</code> + <code>Array.prototype.reverse()</code> 并且你很少需要这么做。但如果你有这需求的话，<code>reduceRight</code> 是最好的选择！</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">const flattened = [[0, 1], [2, 3], [4, 5]].reduceRight(<span class=\"hljs-keyword\">function</span>(a, b) {\n    <span class=\"hljs-built_in\">return</span> a.concat(b);\n}, []);\n\n// flattened array is [4, 5, 2, 3, 0, 1]\n</code></pre><h3 class=\"heading\" data-id=\"heading-10\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FWindowOrWorkerGlobalScope%2FsetTimeout\" rel=\"nofollow noopener noreferrer\">setTimeout() 参数</a></h3>\n<p>这个早就存在了，但如果我早点知道的话，我大概可以省去很多的 <code>.bind(...)</code>。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">set</span>Timeout(alert, 1000, <span class=\"hljs-string\">'Hello world!'</span>);\n\n/*\n * <span class=\"hljs-comment\"># alert 输出</span>\n * Hello World!\n */\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-built_in\">log</span>(text, textTwo) {\n    console.log(text, textTwo);\n}\n\n<span class=\"hljs-built_in\">set</span>Timeout(<span class=\"hljs-built_in\">log</span>, 1000, <span class=\"hljs-string\">'Hello World!'</span>, <span class=\"hljs-string\">'And Mars!'</span>);\n\n/*\n * <span class=\"hljs-comment\"># 输出</span>\n * Hello World! And Mars!\n */\n</code></pre><h3 class=\"heading\" data-id=\"heading-11\"><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FHTMLElement%2Fdataset\" rel=\"nofollow noopener noreferrer\">HTMLElement.dataset</a></h3>\n<p>在此之前我一直对 HTML 元素使用自定义数据属性 <code>data-*</code>，因为我不曾意识到存在一个 API 来方便地查询它们。除了个别的命名限制之外（见上面的链接），它的作用基本就是在 JS 中查询的时候允许你使用驼峰命名法（camelCase）来查询「减号-命名」（dash-case）的属性。所以属性名 <code>data-birth-planet</code> 在 JS 中就变成了 <code>birthPlanet</code>。</p>\n<pre><code class=\"hljs bash\" lang=\"bash\">&lt;div id=<span class=\"hljs-string\">'person'</span> data-name=<span class=\"hljs-string\">'john'</span> data-birth-planet=<span class=\"hljs-string\">'earth'</span>&gt;&lt;/div&gt;\n</code></pre><p>查询：</p>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> personEl = document.querySelector(<span class=\"hljs-string\">'#person'</span>);\n\nconsole.log(personEl.dataset) // DOMStringMap {name: <span class=\"hljs-string\">\"john\"</span>, birthPlanet: <span class=\"hljs-string\">\"earth\"</span>}\nconsole.log(personEl.dataset.name) // john\nconsole.log(personEl.dataset.birthPlanet) // earth\n\n// 你也可以在程序中添加属性\npersonEl.dataset.foo = <span class=\"hljs-string\">'bar'</span>;\nconsole.log(personEl.dataset.foo); // bar\n</code></pre><h2 class=\"heading\" data-id=\"heading-12\">结束语</h2>\n<p>我希望你和我一样在这里学到了一些新知识。在此也\b赞一下 Mozila 新的 MDN 站点，看起来非常棒，我花了比想象中更多的时间来阅读文档。</p>\n<p><em>修订: 修正几处命名并且为 <code>async</code> 函数添加 <code>try</code>, <code>catch</code>。感谢 Reddit！</em></p>\n<p>2018 新年快乐！</p>\n<hr>\n<blockquote>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner\" rel=\"nofollow noopener noreferrer\">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im\" rel=\"nofollow noopener noreferrer\">掘金</a> 上的英文分享文章。内容覆盖 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%23android\" rel=\"nofollow noopener noreferrer\">Android</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%23ios\" rel=\"nofollow noopener noreferrer\">iOS</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%23%25E5%2589%258D%25E7%25AB%25AF\" rel=\"nofollow noopener noreferrer\">前端</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%23%25E5%2590%258E%25E7%25AB%25AF\" rel=\"nofollow noopener noreferrer\">后端</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%23%25E5%258C%25BA%25E5%259D%2597%25E9%2593%25BE\" rel=\"nofollow noopener noreferrer\">区块链</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%23%25E4%25BA%25A7%25E5%2593%2581\" rel=\"nofollow noopener noreferrer\">产品</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%23%25E8%25AE%25BE%25E8%25AE%25A1\" rel=\"nofollow noopener noreferrer\">设计</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner%23%25E4%25BA%25BA%25E5%25B7%25A5%25E6%2599%25BA%25E8%2583%25BD\" rel=\"nofollow noopener noreferrer\">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fxitu%2Fgold-miner\" rel=\"nofollow noopener noreferrer\">掘金翻译计划</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fweibo.com%2Fjuejinfanyi\" rel=\"nofollow noopener noreferrer\">官方微博</a>、<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fjuejinfanyi\" rel=\"nofollow noopener noreferrer\">知乎专栏</a>。</p>\n</blockquote>\n</div>"
}, {
  "title": "理解TCP/IP、UDP - 通过nodejs的net模块",
  "content": "<div data-v-13f76525=\"\" data-v-3f216172=\"\" class=\"entry-content post-content juejin-image-viewer__container\"><h2 class=\"heading\" data-id=\"heading-0\">1. 引子</h2>\n<p>最近在学习node.js的net模块，涉及到了tcp/ip,arp,rcmp,http等协议,在这之前本人仅对http协议进行过深入的研究，至于其它协议仅仅只是知道有这些协议存在而已，未深入研究过。说实在的，网络协议概念很简单，但是也很抽象，网上查了很多资料，都是一些晦涩难懂的语言，所以个人觉得，明白协议的作用、怎么用、以何种形式用，再去看协议的具体工作过程更会让人印象深刻，下面就简明扼要的阐述TCP、IP、UDP。</p>\n<blockquote>\n<p>TCP/IP协议，是传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。-- 百度百科</p>\n</blockquote>\n<blockquote>\n<p>不同的计算机系统，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。</p>\n</blockquote>\n<p>封面图中，展示了OSI七层及TCP/IP五层协议的对应关系；</p>\n<ul>\n<li>网络由下往上分为物理层、数据链路层、网络层、传输层、应用层。</li>\n<li>IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性，socket则是对TCP/IP协议的封装和应用（程序员层面上）。</li>\n<li>也可以说，TPC/IP协议是传输层协议，主要解决<strong>数据如何在网络中传输</strong>，而HTTP是应用层协议，主要解决 <strong>如何包装数据</strong>。</li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-1\">2. 一张图让你了解TCP/IP到底是啥？</h2>\n<p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/1/31/1614a5740c71feca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1048\" data-height=\"591\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1048&quot; height=&quot;591&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>IP能锁定一台物理机器，对应着一张网卡，外界发来的数据包网卡都会接收。如果所有程序都需要监听网卡接发数据，每个包都被发到了所有应用程序，那应用程序符合不了，最后会垮掉，所以就诞生了端口这个标识，从数据安全层面考虑，一个标识号只能被一个应用程序监听。其实网卡都是被系统层封装了，<strong>端口和进程之间的关系也是系统封装好的</strong>。我们只需要用socket就行，给定一个端口号就行了。其它的事都交给操作系统去做。\n<strong>TCP读取端口号，这个端口号就是创建socket时注册的，socket创建成功应该有一个process ID，这应该是操作系统来完成的，TCP于是就把[ 端口号  Process ID] 联系了起来，于是就和这个Process ID进程交换，完成数据的发送和接收。</strong>  <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F22577025%2Fanswer%2F125711899\" rel=\"nofollow noopener noreferrer\">点击查看参考链接</a></p>\n<p>通过这篇文章，我才知道IP和TCP到底做了些啥玩意....... 就是寻址和保证数据传递正确；</p>\n<h2 class=\"heading\" data-id=\"heading-2\">3. TCP</h2>\n<h3 class=\"heading\" data-id=\"heading-3\">TCP三次握手四次断开</h3>\n<p></p><figure><img alt=\"image\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/1/31/1614a574105411f9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"546\" data-height=\"768\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;546&quot; height=&quot;768&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-4\">1. 三次握手</h3>\n<ol>\n<li>第一次握手<code>主机A</code>通过一个标识为SYN标识位的数据段发送给主机B<code>请求连接</code>，通过该数据段告诉主机B希望建立连接，需要B应答，并告诉主机B传输的起始序列号;</li>\n<li>第二次握手是<code>主机B</code>用一个<code>确认应答</code>ACK和同步序列号SYNC标志位的数据段来响应主机A，一是发送ACK告诉主机A收到了数据段，二是通知主机A从哪个序列号做标记;</li>\n<li>第三次握手是<code>主机A确认收到</code>了主机B的数据段并可以开始传输实际数据。</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-5\">2. 四次断开</h3>\n<ol>\n<li><code>主机A</code>发送FIN控制位发出<code>断开连接的请求</code>;</li>\n<li><code>主机B</code>进行响应，<code>确认收到断开连接请求</code>;</li>\n<li><code>主机B</code>提出反方向的<code>关闭要求</code>;</li>\n<li><code>主机A确认</code>收到的主机B的<code>关闭连接请求</code>;</li>\n</ol>\n<p>问题：为什么断开要四次，而不是三次？因为主机B在响应收到断开链接请求的同时，还存在未发送完的数据；</p>\n<h2 class=\"heading\" data-id=\"heading-6\">4. UDP</h2>\n<p>UDP协议并不提供超时重传，出错重传等功能，所以说其是不可靠的协议。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">5. TCP与UDP的区别</h2>\n<p>TCP(Transimision Control Protocal)  ==&gt; http ftp smtp   ==&gt; 电话</p>\n<ul>\n<li>传输控制协议</li>\n<li>可靠的、面向连接的协议</li>\n<li>传输效率低</li>\n</ul>\n<p>UDP(User Datagram Protocal)   ==&gt; qq, 微信 ==&gt; 广播</p>\n<ul>\n<li>用户数据报协议</li>\n<li>不可靠的、无连接的服务</li>\n<li>传输效率高</li>\n</ul>\n<ol>\n<li>TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上（实际上也很大程度上保证了）保证了连接的可靠性；而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。\n2。也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。</li>\n</ol>\n<p>知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。</p>\n<h2 class=\"heading\" data-id=\"heading-8\">6. node.js net模块</h2>\n<ul>\n<li>net模块也是node的核心模块,用于底层的网络通信；</li>\n<li>http.Server继承了net.Server；</li>\n<li>http客户端与http服务端的通信均依赖于socket（net.Socket）；</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-9\">6.1 net模块组成</h3>\n<p>主要包含两个部分：</p>\n<ol>\n<li>\n<p><strong>net.Server</strong>\ntcp/server, 服务端TCP监听来自客户端的请求，并使用TCP连接(socket)向客户端发送数据；\n内部通过socket来实现与客户端的通信；</p>\n</li>\n<li>\n<p><strong>net.Socket</strong>\ntcp/本地，客户端TCP连接到服务器，并与服务器交换数据；\nsocket的node实现，实现了全双工的stream的接口；</p>\n</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-10\">6.2 服务端net.Server</h3>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> net = require(<span class=\"hljs-string\">'net'</span>)\n<span class=\"hljs-built_in\">let</span> PORT = 8081\n<span class=\"hljs-built_in\">let</span> HOST = <span class=\"hljs-string\">'localhost'</span>\n/**\n * 1. 创建一个TCP服务器实例，调用listen函数开始监听指定端口；\n * 2. 传入net.createServer()的回调函数，作为connection事件的处理函数；\n * 3. 在每个connection事件中，该回调函数接收到的socket对象是唯一的；\n * 4. 该连接自动关联一个socket对象\n * */\n<span class=\"hljs-built_in\">let</span> server = net.createServer((socket) =&gt; {\n\tconsole.log(<span class=\"hljs-string\">'connection:'</span> + socket.remoteAddress, socket.remotePort)\n\t// 为这个socket实例添加一个“data”事件处理函数\n\tsocket.on(<span class=\"hljs-string\">'data'</span>, (data) =&gt; {\n\t\tconsole.log(<span class=\"hljs-string\">'DATA'</span> + socket.remoteAddress + <span class=\"hljs-string\">\":\"</span> + data);\n\t\tsocket.write(<span class=\"hljs-string\">'You said \"'</span>+ data +<span class=\"hljs-string\">'\"\\r\\n'</span>) // 向客户端回发该数据\n\t})\n\t\n\tsocket.on(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n\t\tconsole.log(<span class=\"hljs-string\">'客户端关闭'</span>)\n\t\t/**\n\t\t * 服务端收到客户端发出的关闭连接请求时，会触发end事件\n\t\t * 这个时候客户端没有真正的关闭，只是开始关闭；\n\t\t * 当真正的关闭的时候，会触发close事件；\n\t\t * */\n\t\tserver.unref();\n\t\t//调用了该方法，则所有的客户端关闭跟本服务器的连接后，将关闭服务器\n\t})\n\t\n\t// 客户端关闭事件\n\tsocket.on(<span class=\"hljs-string\">'close'</span>, () =&gt; {\n\t\tconsole.log(<span class=\"hljs-string\">'CLOSED: '</span> + socket.remoteAddress + <span class=\"hljs-string\">' '</span> + socket.remotePort);\n\t})\n\t\n\t/*socket.pause()\n\tsocket.setTimeout(3000) //设置客户端超时时间，如果客户端一直不输入，超过这个时间，就认为超时了\n\tsocket.on(<span class=\"hljs-string\">'timeout'</span>, () =&gt; {\n\t\tconsole.log(<span class=\"hljs-string\">'超时了'</span>)\n\t\tsocket.pipe(ws, {end: <span class=\"hljs-literal\">false</span>})\n\t\t// 默认情况下，当可读流读到末尾的时候会关闭可写流\n\t})*/\n})\n\nserver.listen(PORT, HOST, () =&gt; {\n\tconsole.log(<span class=\"hljs-string\">'服务端的地址是：'</span>, server.address())\n})\n\nserver.on(<span class=\"hljs-string\">'error'</span>, (err) =&gt; {\n\tconsole.log(err)\n})\n\n//服务端也可以通过显式处理<span class=\"hljs-string\">\"connection\"</span>事件来建立TCP连接，只是写法不同，二者没有区别即:\n/*\n<span class=\"hljs-built_in\">let</span> server = net.createServer()\nserver.listen(PORT,HOST)\nserver.on(<span class=\"hljs-string\">'connection'</span>, (socket) =&gt; {\n\tconsole.log(<span class=\"hljs-string\">'CONNECTED: '</span> + sock.remoteAddress +<span class=\"hljs-string\">':'</span>+ sock.remotePort);\n})*/\nserver.on(<span class=\"hljs-string\">'close'</span>, () =&gt; {\n\t//关闭服务器，停止接收新的客户端的请求\n\tconsole.log( <span class=\"hljs-string\">'close事件：服务端关闭'</span> );\n})\n\nserver.on(<span class=\"hljs-string\">'error'</span>, (error) =&gt; {\n\tconsole.log( <span class=\"hljs-string\">'error事件：服务端异常：'</span> + error.message );\n})\n</code></pre><h3 class=\"heading\" data-id=\"heading-11\">6.3 客户端net.Socket</h3>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> net = require(<span class=\"hljs-string\">'net'</span>)\n\n//创建一个TCP客户端连接到刚创建的服务器上，该客户端向服务器发送一串消息，并在得到服务器的反馈后关闭连接。\n\nvar client = new net.Socket()\n<span class=\"hljs-built_in\">let</span> PORT = 8081\n<span class=\"hljs-built_in\">let</span> HOST = <span class=\"hljs-string\">'localhost'</span>\n\nclient.connect(PORT, HOST, () =&gt; {\n\tconsole.log(<span class=\"hljs-string\">'connect to '</span> + HOST + <span class=\"hljs-string\">':'</span> + PORT)\n\tclient.write(<span class=\"hljs-string\">'I am happyGloria.'</span>) //建立连接后立即向服务器发送数据，服务器将收到这些数据\n})\n\nclient.on(<span class=\"hljs-string\">'data'</span>, (data) =&gt; {\n\tconsole.log(<span class=\"hljs-string\">'DATA: '</span> + data)\n\tclient.destroy() // 完全关闭连接\n})\n\nclient.on(<span class=\"hljs-string\">'close'</span>, <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span> () {\n\tconsole.log(<span class=\"hljs-string\">'Connection closed'</span>)\n})\n</code></pre><h3 class=\"heading\" data-id=\"heading-12\">6.4 基于tcp的聊天室</h3>\n<pre><code class=\"hljs bash\" lang=\"bash\"><span class=\"hljs-built_in\">let</span> net = require(<span class=\"hljs-string\">'net'</span>)\n<span class=\"hljs-built_in\">let</span> util = require(<span class=\"hljs-string\">'util'</span>)\n<span class=\"hljs-built_in\">let</span> HOST = <span class=\"hljs-string\">'localhost'</span>\n<span class=\"hljs-built_in\">let</span> PORT = 8082\n<span class=\"hljs-built_in\">let</span> clients = {}\n\n<span class=\"hljs-keyword\">function</span> broadcast (username, msg) {\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">let</span> name <span class=\"hljs-keyword\">in</span> clients) {\n\t\t<span class=\"hljs-keyword\">if</span> (name != username) {\n\t\t\tclients[name].write(msg + <span class=\"hljs-string\">'\\r\\n'</span>)\n\t\t}\n\t}\n}\n\n<span class=\"hljs-built_in\">let</span> server = net.createServer((socket) =&gt; {\n\tsocket.setEncoding(<span class=\"hljs-string\">'utf8'</span>)\n\tserver.getConnections((err, count) =&gt; {\n\t\tsocket.write(<span class=\"hljs-string\">'在线人数是'</span> + count + <span class=\"hljs-string\">'位，请输入你的昵称:\\r\\n'</span>)\n\t})\n\t\n\t<span class=\"hljs-built_in\">let</span> username\n\tsocket.on(<span class=\"hljs-string\">'data'</span>, (data) =&gt; {\n\t\tdata = data.replace(/\\r\\n/, <span class=\"hljs-string\">''</span>)\n\t\t<span class=\"hljs-keyword\">if</span> (username) {\n\t\t\tbroadcast(username, `<span class=\"hljs-variable\">${username}</span> 说: <span class=\"hljs-variable\">${data}</span>`)\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t<span class=\"hljs-keyword\">if</span> (clients[data]) {\n\t\t\t\tsocket.write(<span class=\"hljs-string\">'您的昵称'</span> + data + <span class=\"hljs-string\">'被占用了，请您更换新的昵称\\r\\n'</span>)\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\tusername = data\n\t\t\t\tclients[username] = socket\n\t\t\t\tbroadcast(username, `欢迎<span class=\"hljs-variable\">${username}</span>加入`)\n\t\t\t}\n\t\t}\n\t})\n\t\n\tsocket.on(<span class=\"hljs-string\">'end'</span>, () =&gt; {\n\t\tbroadcast(username, `<span class=\"hljs-variable\">${username}</span>离开聊天室`)\n\t\tclients[username] &amp;&amp; clients[username].destroy()\n\t\tdelete clients[username]\n\t})\n})\n\n\nserver.listen(PORT, HOST, () =&gt; {\n\tconsole.log(`tcp聊天室已启动，地址是<span class=\"hljs-variable\">${util.inspect(server.address())}</span>`)\n})\n</code></pre><p>参考资料： https://www.zhihu.com/question/51074319</p>\n</div>"
}, {
  "title": "使用vue构建一个自动建站项目",
  "content": "<div data-v-13f76525=\"\" data-v-3f216172=\"\" class=\"entry-content post-content juejin-image-viewer__container\"><h2 class=\"heading\" data-id=\"heading-0\">写在前面</h2>\n<p>之前一直用Jquery+Jquery-ui来做这个项目，那个时候没有设计稿，没有项目需求，就因为BOSS一句话，要做这样的东西，当时就...好吧！我承认，其实已经习惯了，无所谓了(也是无奈，哎)!!! <br>\n在之后的一段时间里，做了一个demo出来，BOSS很满意了，所以自己接下来就慢慢做吧，差不多两三个月吧，就闷头做这个，后来项目上线了，当然因为产品的不完善，还是有点问题了！<br>\n不过基本能满足公司的需求了，能编辑的都可以编辑，组件的background(包括背景图片) color border box-shadow margin padding width height 对齐方式(字体和组件内部元素) border-radius font(font-size/font-family)等等这些基础的都可以随心变更，当然考虑到可能满足不了公司的使用，就加了一个自定义样式的功能，而这个只有懂前端的人才能使用了，没办法，需求永远赶不上变化，这样保险一点。因为大家都知道，需求的满足和变更永远跑在现成需求的前面 <br>\n除了这些基础的可更改，各个组件的特有可变更的功能也基本齐全的，比如轮播图图片变更，轮播方式，控制是否轮播等等这些功能，这里就不一一介绍了<br>\n包括后来，因为有组件内部个别元素不能修改，又增加了[绑定修改]功能，就是这个功能选中之后，在视图界面，选中需要修改的元素，便可以进行修改了，这个功能还是有点意思的<br>\n说了这么多，其实当时因为做的仓促，存储的时候存的是HTML,大家不要鄙视(要脸0.0),这个也是我心里一直的梗，最近加上BOSS重新提出了一些想法，有蛮多东西要加，思前想后,决定将项目重构一下<br>\n考虑到vue响应式与基本是纯数据操作，所以决定使用vue重新构建这个项目。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">开发准备</h2>\n<p><strong>1、</strong>使用vue-cli，下载下来配置好的东西<br>\n<strong>2、</strong>因为中间牵涉了拖拽生成组件的操作，所以使用了vuedraggable和sortablejs。<br></p>\n<p><strong>安装vuedraggable sortablejs</strong></p>\n<pre><code class=\"hljs js\" lang=\"js\">    npm install vuedraggable\n    npm install sortablejs\n</code></pre><p>项目中我们只需要引入vuedraggable就可以了，牵涉了sortablejs东西的时候，vuedraggable会去自己加载调用sortablejs里面的方法的，这个就不是我们需要关注的(你如果想了解，可以自己去看看)；<br>\n<strong>3、</strong>安装vuex，因为里面牵涉到了大量的数据交互，很多组件都需要一些公用的数据，不使用vuex去管理，将会为开发带来更多不必要的麻烦;<br></p>\n<p><strong>安装vuex</strong></p>\n<pre><code class=\"hljs bash\" lang=\"bash\">    npm install --save vuex\n</code></pre><p><strong>4、</strong>因为没有设计稿的缘故，所以大胆使用了第三方UI库 element-ui;<br>\n<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Felement-cn.eleme.io%2F%23%2Fzh-CN%2Fcomponent%2Finstallation\" rel=\"nofollow noopener noreferrer\">element-ui官网地址</a><br></p>\n<p><strong>安装elememt</strong></p>\n<pre><code class=\"hljs bash\" lang=\"bash\"> npm install element-ui\n //为什么是element-ui而不是element?因为当时npm上已经有了element包了(我当时还觉得挺有意思的，0.0 好冷啊！！！)\n</code></pre><p><strong>5、</strong>axios安装,后面与后台数据交互会用到<br></p>\n<p><strong>安装axios</strong></p>\n<pre><code class=\"hljs bash\" lang=\"bash\">npm install --save axios\n</code></pre><p>差不多准备工作就这些了，接下来我们看项目实施；</p>\n<h2 class=\"heading\" data-id=\"heading-2\">项目开始</h2>\n<h3 class=\"heading\" data-id=\"heading-3\">1、各种文件的配置</h3>\n<h4 class=\"heading\" data-id=\"heading-4\">-&gt; main.js中文件的配置</h4>\n<p></p><figure><img alt=\"main.js配置\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/1/31/1614a96406ca720d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"603\" data-height=\"313\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;603&quot; height=&quot;313&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure>\n图片中都有解释，应该可以看的懂的；<p></p>\n<h4 class=\"heading\" data-id=\"heading-5\">-&gt; 侧边栏拖拽组件数据的配置</h4>\n<p></p><figure><img alt=\"dragApi\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/1/31/1614a9ccbea95359?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"597\" data-height=\"507\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;597&quot; height=&quot;507&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure>\n因为文件太长，所以删掉了一些，这里就是一个简单的格式，仅供参考，不作为标准；<p></p>\n<p>在组件当中，存在一个布局的问题，所以要有布局组件，让组件可以放到布局组建中，这样才更加的灵活</p>\n<h4 class=\"heading\" data-id=\"heading-6\">-&gt; vuexjs 状态管理中的js配置</h4>\n<p></p><figure><img alt=\"storejs配置\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/1/31/1614aa42fdce66b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"603\" data-height=\"536\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;603&quot; height=&quot;536&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p><strong>说明：</strong><br>\n1、因为用户在拖拽之后要实时保存到sessionStorage中， 所以再初始的时候要到sessionStroage中去取数据，防止突然刷新页面，还没有保存到数据库中，用户刚刚编辑的数据全部丢失的情况;<br>\n2、这里说明一下，可能考虑到用于已经提交了数据，所以用户关闭窗口之后，再次进来的时候，要结合后台给出的用户之前的数据，一起存储到sessionStorage中去，相信这一点大家肯定想的到的，这里善意提醒一下 0.0；<br>\n3、我这这里暂时放了四个参数，图中都有说明，我主要是将基本编辑做成了一个组件，会根据用户点击时哪个组件，而重新渲染数据给到编辑组件，从而可以实时对应到点击的组件去编辑；<br>\n4、editShow的作用就是控制编辑组件显示与否的，主要删除组件的时候，让编辑组件隐藏一下；点击其他组件的显示一下；</p>\n<blockquote>\n<p><strong>基本的配置就这些了，接下来就是真正的开发了;</strong></p>\n</blockquote>\n<hr>\n<h3 class=\"heading\" data-id=\"heading-7\">2、项目开发开始</h3>\n<h4 class=\"heading\" data-id=\"heading-8\">-&gt; app.vue文件中该怎么写？</h4>\n<pre><code class=\"hljs html\" lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!--用的element-ui--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-container</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-aside</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Draggable</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-aside-drag\"</span> <span class=\"hljs-attr\">:options</span>=<span class=\"hljs-string\">\"dragOption\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-aside-list\"</span> \n                    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(dragList,index) in dragData\"</span> \n                    <span class=\"hljs-attr\">:type</span>=<span class=\"hljs-string\">\"dragList.type\"</span> \n                    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"dragList.type\"</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"aside-item-body\"</span>&gt;</span>\n                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"aside-item-ele\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span>\n                        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"aside-item-ele\"</span>&gt;</span>{{ list.title }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Draggable</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-aside</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-main</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-main\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-phone\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-phone-header\"</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"phone-camera\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"phone-ls\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n                <span class=\"hljs-comment\">&lt;!--页面view区 --&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Sort</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-phone-body\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Sort</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-phone-footer\"</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-phone-menu\"</span>&gt;</span>RS<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-main</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-aside</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"app-right\"</span>&gt;</span>\n            <span class=\"hljs-comment\">&lt;!--组件编辑区域--&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BaseEdit</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">BaseEdit</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-aside</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-container</span>&gt;</span>    \n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> DragApi <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@/dragapi/dragapi.js\"</span>;\n<span class=\"hljs-keyword\">import</span> Draggable <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"vuedraggable\"</span>;\n<span class=\"hljs-keyword\">import</span> Sort <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@/view/Sort\"</span>;\n<span class=\"hljs-keyword\">import</span> BaseEdit <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@/view/BaseEdit\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n\t<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'app'</span>,\n\tdata(){\n\t    <span class=\"hljs-keyword\">return</span>{\n\t        <span class=\"hljs-attr\">dragData</span>: {},\n\t        <span class=\"hljs-attr\">dragOption</span>: {\n\t            <span class=\"hljs-attr\">group</span>: {\n\t                <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'components'</span>, <span class=\"hljs-comment\">//这个很重要，其他的与之能产生关联的拖拽框就靠这name 一定要一致</span>\n\t                pull: <span class=\"hljs-string\">'clone'</span>,  \n\t                <span class=\"hljs-attr\">put</span>: <span class=\"hljs-literal\">false</span>\n\t            },\n\t            <span class=\"hljs-attr\">sort</span>: <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">//默然为true。这里我们只需要他拖拽，无需能拖动排序</span>\n\t        }\n\t    }\n\t},\n\t<span class=\"hljs-attr\">components</span>: {\n\t    Draggable,\n\t    Sort,\n\t    BaseEdit\n\t},\n\tcreated(){\n\t    <span class=\"hljs-comment\">//侧边栏拖拽列表数据</span>\n\t    <span class=\"hljs-comment\">//这里我只写了组件的数据进来，布局的暂时没放</span>\n\t    <span class=\"hljs-keyword\">this</span>.dragData = DragApi.configList[<span class=\"hljs-number\">1</span>].content;\n\t}\n}\n\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre><h4 class=\"heading\" data-id=\"heading-9\">-&gt; 来看看sort view视图区域组件</h4>\n<pre><code class=\"hljs bash\" lang=\"bash\">&lt;template&gt;\n    &lt;Draggable :options=<span class=\"hljs-string\">\"sortOption\"</span>\n        @sort=<span class=\"hljs-string\">\"onSort\"</span>\n        @add=<span class=\"hljs-string\">\"onAdd\"</span>\n        class=<span class=\"hljs-string\">\"app-sort\"</span>&gt;\n        &lt;!-- ui组件 --&gt;\n        &lt;!--这里不懂的人，可以去vue官网看看动态组件--&gt;\n        &lt;div v-for=<span class=\"hljs-string\">\"(appUi,index) in sortApi\"</span> //循环组件\n             :is=<span class=\"hljs-string\">\"appUi.component\"</span> //根据存在的组件渲染出来\n             :content=<span class=\"hljs-string\">\"appUi.content\"</span>\n             :oStyle=<span class=\"hljs-string\">\"appUi.style\"</span>\n             :editPartShow=<span class=\"hljs-string\">\"appUi.editPartShow\"</span>\n             :aIndex=<span class=\"hljs-string\">\"index\"</span>\n             //组件想要点击生效，只需要@click.native就行了\n             @click.native=<span class=\"hljs-string\">\"getIndex(index)\"</span>\n             //key值一定要给出来，不然相同组件的排序可能会不成功\n             :key=<span class=\"hljs-string\">\"appUi.content.code\"</span>&gt;\n        &lt;/div&gt;\n    &lt;/Draggable&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    //利用vuex 辅助函数来操作vuexjs中的数据\n    import { mapState,mapMutations } from <span class=\"hljs-string\">'vuex'</span>;\n    //拖拽插件引入\n    import Draggable from <span class=\"hljs-string\">'vuedraggable'</span>;\n    //各个组件引入\n    import Carousel from <span class=\"hljs-string\">\"@/components/Carousel.vue\"</span>;\n    import Btn from <span class=\"hljs-string\">\"@/components/Btn.vue\"</span>;\n\n    <span class=\"hljs-built_in\">export</span> default {\n        name: <span class=\"hljs-string\">'Sort'</span>,\n        components: {\n            Draggable,Btn,Carousel\n        },\n        <span class=\"hljs-function\"><span class=\"hljs-title\">data</span></span>(){\n            <span class=\"hljs-built_in\">return</span> {\n                sortOption: {\n                    group: {\n                      name: <span class=\"hljs-string\">'components'</span>, //前面说的name,在这里就起了作用，不一样，是不能放入的\n                      pull: <span class=\"hljs-literal\">true</span>,\n                      put: <span class=\"hljs-literal\">true</span>\n                    },\n                    sort: <span class=\"hljs-literal\">true</span>,\n                    animation: 300 //给了个动画，看起来舒服些\n                }\n            }\n        },\n        computed:{\n            ...mapState([<span class=\"hljs-string\">'editIndex'</span>,<span class=\"hljs-string\">'sortApi'</span>]),\n        },\n        watch:{\n            sortApi:{\n                handler(newVal,oldVal){\n                    window.sessionStorage.setItem(<span class=\"hljs-string\">'localData'</span>,JSON.stringify(newVal));\n                },\n                deep: <span class=\"hljs-literal\">true</span>\n            }\n        },\n        methods:{\n            ...mapMutations([<span class=\"hljs-string\">'sortCp'</span>,<span class=\"hljs-string\">'addCp'</span>,<span class=\"hljs-string\">'setStyle'</span>,<span class=\"hljs-string\">'setCommon'</span>]),\n            onSort(res){ //排序产生的事件\n                <span class=\"hljs-keyword\">if</span>(res.from === res.to){\n                    this.sortCp(res);\n                }\n            },\n            onAdd(res){//组件增加产生的事件\n                this.addCp(res);\n            },\n            getIndex(index){\n               this.setCommon({index: index,flag: <span class=\"hljs-literal\">true</span>});\n            }\n        }\n    }\n&lt;/script&gt;\n</code></pre><h4 class=\"heading\" data-id=\"heading-10\">-&gt; 再来看看编辑组件</h4>\n<pre><code class=\"hljs bash\" lang=\"bash\">&lt;template&gt;\n    &lt;transition name=<span class=\"hljs-string\">\"slide-right\"</span>&gt;\n        &lt;div v-if=<span class=\"hljs-string\">\"sortApi.length &gt; 0 &amp;&amp; editShow === true\"</span>&gt;\n            //组件特有编辑\n            &lt;el-tabs v-model=<span class=\"hljs-string\">\"activeName\"</span>&gt;\n                &lt;el-tab-pane label=<span class=\"hljs-string\">\"组件设置\"</span> name=<span class=\"hljs-string\">\"first\"</span>&gt;\n                    &lt;div v-for=<span class=\"hljs-string\">\"(appUi,index) in sortApi\"</span>\n                         :is=<span class=\"hljs-string\">\"appUi.component+'Edit'\"</span>\n                         :content=<span class=\"hljs-string\">\"appUi.content\"</span>\n                         :oStyle=<span class=\"hljs-string\">\"appUi.style\"</span>\n                         :editPartShow=<span class=\"hljs-string\">\"appUi.editPartShow\"</span>\n                         :aIndex=<span class=\"hljs-string\">\"index\"</span>\n                         :currentIndex=<span class=\"hljs-string\">\"editIndex\"</span>\n                         :key=<span class=\"hljs-string\">\"appUi.content.code\"</span>&gt;\n                    &lt;/div&gt;\n                &lt;/el-tab-pane&gt;\n                &lt;el-tab-pane label=<span class=\"hljs-string\">\"样式设置\"</span> name=<span class=\"hljs-string\">\"second\"</span>&gt;\n                    //公共样式编辑\n                    &lt;el-collapse v-model=<span class=\"hljs-string\">\"colorPicker.name\"</span> class=<span class=\"hljs-string\">\"base-edit\"</span>  accordion&gt;\n                        &lt;el-collapse-item class=<span class=\"hljs-string\">\"tititt\"</span> :title=<span class=\"hljs-string\">\"colorPicker.type\"</span> :name=<span class=\"hljs-string\">\"colorPicker.type\"</span>&gt;\n                            &lt;el-form ref=<span class=\"hljs-string\">\"form\"</span> :model=<span class=\"hljs-string\">\"colorPicker\"</span> size=<span class=\"hljs-string\">\"mini\"</span>&gt;\n                                &lt;el-form-item class=<span class=\"hljs-string\">\"cui-inline-reset\"</span>\n                                    v-for=<span class=\"hljs-string\">\"(item,index) in colorPicker.content\"</span>\n                                    :label=<span class=\"hljs-string\">\"item.title\"</span>\n                                    :key=<span class=\"hljs-string\">\"item.style\"</span>&gt;\n                                    &lt;el-color-picker\n                                        //在element-ui框架中，有很多@change @active-change事件，直接写事件发现不能传入参数，\n                                        //当然，办法总比问题多，我们换成一下这种写法就行了，他的默然参数写在前面\n                                        //这里颜色拾取器 返回的是实时的颜色值\n                                        //我这里主要想传一个对应的style\n                                        @active-change=<span class=\"hljs-string\">\" (value) =&gt; setStyle(value,item.style)\"</span>\n                                        v-model=<span class=\"hljs-string\">\"sortApi[editIndex].style[item.style]\"</span>\n                                        show-alpha&gt;\n                                    &lt;/el-color-picker&gt;\n                                    &lt;span class=<span class=\"hljs-string\">\"black-text-shadow\"</span>\n                                        :style=<span class=\"hljs-string\">\"{color: sortApi[editIndex].style[item.style]}\"</span>&gt;\n                                        {{ sortApi[editIndex].style[item.style] }}\n                                    &lt;/span&gt;\n                                &lt;/el-form-item&gt;\n                            &lt;/el-form&gt;\n                        &lt;/el-collapse-item&gt;\n                    &lt;/el-collapse&gt;\n                &lt;/el-tab-pane&gt;\n            &lt;/el-tabs&gt;\n        &lt;/div&gt;\n    &lt;/transition&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    import { mapState,mapMutations } from <span class=\"hljs-string\">'vuex'</span>;\n    //这里我将组建特有的编辑栏，写成了一个组件，为什么不写在相应的组件一起了？\n    //这里必须说明一下，主要是我没有想到方法，让他在同一组件内分离出来，单独将dom结构放在编辑栏这里，如果有大神知道\n    //还望不吝赐教\n    import BtnEdit from <span class=\"hljs-string\">\"@/components/BtnEdit.vue\"</span>;\n    \n    <span class=\"hljs-built_in\">export</span> default{\n        name: <span class=\"hljs-string\">'BaseEdit'</span>,\n        components: {\n          BtnEdit\n        },\n        <span class=\"hljs-function\"><span class=\"hljs-title\">data</span></span>(){\n            <span class=\"hljs-built_in\">return</span>{\n                colorPicker: {\n                    <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'颜色设置'</span>,\n                    name: <span class=\"hljs-string\">'Picker'</span>,\n                    content:[\n                        {\n                            title: <span class=\"hljs-string\">'背景颜色'</span>,\n                            style: <span class=\"hljs-string\">'background'</span>\n                        },\n                        {\n                            title: <span class=\"hljs-string\">'字体颜色'</span>,\n                            style: <span class=\"hljs-string\">'color'</span>\n                        }\n                    ]\n                    \n                },\n                activeName: <span class=\"hljs-string\">'first'</span>\n            }\n        },\n        \n        computed:{\n            ...mapState([<span class=\"hljs-string\">'editIndex'</span>,<span class=\"hljs-string\">'sortApi'</span>,<span class=\"hljs-string\">'editShow'</span>])\n        },\n        methods:{\n            <span class=\"hljs-built_in\">set</span>Style(value,style){\n                //根据上面传入的style属性，实时改变现有的值\n                this.<span class=\"hljs-variable\">$set</span>(this.sortApi[this.editIndex].style,style,value);\n            }\n        }\n    }\n&lt;/script&gt;\n</code></pre><h4 class=\"heading\" data-id=\"heading-11\">-&gt; 选出一个组件来看看里面是怎么配置的</h4>\n<pre><code class=\"hljs html\" lang=\"html\">//按钮组件，其实里面很简单\n//组件的对应的编辑组件，里面内容和这个也差不多，下面就不写了\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn-box ui-sortable\"</span> <span class=\"hljs-attr\">:data-code</span>=<span class=\"hljs-string\">\"content.code\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"ui-btn\"</span>\n            <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"oStyle\"</span>&gt;</span>\n            {{ content.text }}\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-button</span>&gt;</span>\n        //因为每个组件都有删除功能，所以写成了一个组件\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DeleteCp</span> <span class=\"hljs-attr\">:aIndex</span>=<span class=\"hljs-string\">\"aIndex\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">DeleteCp</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> DeleteCp <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@/components/DeleteCp\"</span>;\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Btn'</span>,\n        <span class=\"hljs-attr\">props</span>: { <span class=\"hljs-comment\">//父组件传入的参数</span>\n            content: <span class=\"hljs-built_in\">Object</span>,\n            <span class=\"hljs-attr\">oStyle</span>: <span class=\"hljs-built_in\">Object</span>,\n            <span class=\"hljs-attr\">aIndex</span>: <span class=\"hljs-built_in\">Number</span>\n        },\n        <span class=\"hljs-attr\">components</span>: {\n            DeleteCp\n        },\n        data(){\n            <span class=\"hljs-keyword\">return</span>{\n                <span class=\"hljs-attr\">btnModel</span>: <span class=\"hljs-string\">'btn-model'</span>\n            }\n        }\n    }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n</code></pre><h4 class=\"heading\" data-id=\"heading-12\">-&gt;最后来看看删除组件吧</h4>\n<pre><code class=\"hljs bash\" lang=\"bash\">&lt;template&gt;\n    &lt;div class=<span class=\"hljs-string\">\"delete-compontent-box\"</span>&gt;\n        &lt;div class=<span class=\"hljs-string\">\"el-icon-delete remove-component\"</span> @click.stop=<span class=\"hljs-string\">\"dailogStatu\"</span>&gt;&lt;/div&gt;\n        &lt;el-dialog\n            title=<span class=\"hljs-string\">\"提示\"</span>\n            :visible.sync=<span class=\"hljs-string\">\"dialogVisible\"</span>\n            :append-to-body=<span class=\"hljs-string\">\"appendToBody\"</span>\n            width=<span class=\"hljs-string\">\"430px\"</span>&gt;\n            &lt;div class=<span class=\"hljs-string\">\"el-message-box__content\"</span>&gt;\n                &lt;div class=<span class=\"hljs-string\">\"el-message-box__status el-icon-warning\"</span>&gt;&lt;/div&gt;\n                &lt;div class=<span class=\"hljs-string\">\"el-message-box__message dialog-message\"</span>&gt;此操作将删除该模块, 是否继续?&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;span slot=<span class=\"hljs-string\">\"footer\"</span> class=<span class=\"hljs-string\">\"dialog-footer\"</span>&gt;\n                &lt;el-button @click=<span class=\"hljs-string\">\"dialogVisible = false\"</span> size=<span class=\"hljs-string\">\"small\"</span>&gt;取 消&lt;/el-button&gt;\n                &lt;el-button <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-string\">\"primary\"</span> @click=<span class=\"hljs-string\">\"onRemove(aIndex)\"</span> size=<span class=\"hljs-string\">\"small\"</span>&gt;确 定&lt;/el-button&gt;\n            &lt;/span&gt;\n        &lt;/el-dialog&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    import { mapMutations } from <span class=\"hljs-string\">\"vuex\"</span>;\n    <span class=\"hljs-built_in\">export</span> default {\n        name: <span class=\"hljs-string\">'oText'</span>,\n        props: {\n            aIndex: Number\n        },\n        <span class=\"hljs-function\"><span class=\"hljs-title\">data</span></span>(){\n            <span class=\"hljs-built_in\">return</span>{\n                //这两个参数是弹框的参数\n                dialogVisible: <span class=\"hljs-literal\">false</span>,\n                appendToBody: <span class=\"hljs-literal\">true</span> \n            }\n        },\n        methods:{\n            ...mapMutations([<span class=\"hljs-string\">'deleteCp'</span>,<span class=\"hljs-string\">'setCommon'</span>]),\n            <span class=\"hljs-function\"><span class=\"hljs-title\">dailogStatu</span></span>(){\n            //主要是控制弹窗出来，并且显示该组件对应的编辑栏\n              this.dialogVisible = <span class=\"hljs-literal\">true</span>;\n              this.setCommon({flag: <span class=\"hljs-literal\">true</span>,index: this.aIndex})\n            },\n            onRemove(index){\n                //点击确定删除对应的组件\n                <span class=\"hljs-built_in\">let</span> flag = <span class=\"hljs-literal\">false</span>;\n                this.deleteCp(index);\n                this.dialogVisible = <span class=\"hljs-literal\">false</span>;\n                this.<span class=\"hljs-variable\">$message</span>({\n                    message: <span class=\"hljs-string\">'该模块已删除 !'</span>,\n                    <span class=\"hljs-built_in\">type</span>: <span class=\"hljs-string\">'success'</span>\n                });\n                this.setCommon({flag: <span class=\"hljs-literal\">false</span>,index: 0})\n            }\n        }\n    }\n&lt;/script&gt;\n</code></pre><hr>\n<h4 class=\"heading\" data-id=\"heading-13\">-&gt; 来看看效果图吧</h4>\n<p></p><figure><img alt=\"效果图展示\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2018/1/31/1614b081bf7378d8?imageslim\" data-width=\"919\" data-height=\"608\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;919&quot; height=&quot;608&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-14\">结束语</h2>\n<p>好了，今天写了很多了，最后我们来梳理一下思路：</p>\n<p>1、首先配置左侧的拖拽组件<br>\n2、配置vuex中的数据<br>\n3、app.vue中配置<br>\n4、编辑组件的配置<br>\n5、各种数据的传递与依赖</p>\n<p>其实每个项目，都需要一个清晰的路线，这样才能很好的开发下去，所以我的建议是，在拿到项目的时候，千万不要一股脑的去写，一定要想好怎么做，以及突发事情的发生(比如突来的需求变更)，这样既方便了我们自己，也方便了后来维护的人，也阻止了不必要的麻烦</p>\n<p>谢谢大家的耐心的阅读，毕竟这只是一个大概的介绍，肯定存在很多不足，如果大家有建议，欢迎留言交流</p>\n<p>最后：欢迎大家关注我的个人公众号：<strong>大前端js</strong>，当然为了回馈大家关注，里面我放了一些学习资源，热烈欢迎大家关注交流前端方面但不局限前端方面的知识；</p>\n<blockquote>\n<p><strong>原创不易，转载时请注明出处与原文链接，谢谢！</strong></p>\n</blockquote>\n</div>"
}, {
  "title": "Vue 脱坑记 - 查漏补缺(汇总下群里高频询问的xxx及给出不靠谱的解决方案)",
  "content": "<div data-v-13f76525=\"\" data-v-3f216172=\"\" class=\"entry-content post-content juejin-image-viewer__container\"><h1 class=\"heading\" data-id=\"heading-0\">前言</h1><p>文章内容覆盖范围,<code>芝麻绿豆</code>的破问题都有,不止于<code>vue</code>;<br>给出的是方案,但不是手把手一字一句的给你说十万个为什么!</p>\n<p>有三类人不适合此篇文章:</p>\n<ul>\n<li>\"喜欢站在道德制高点的圣母婊\" -- 适合去教堂</li>\n<li>\"无理取闹的键盘侠\" -- 国际新闻版块欢迎你去</li>\n<li>\"有一定基础但又喜欢逼逼的人\"<ul>\n<li>得得得,老子知道你厉害了,你好牛逼,这些问题那么简单,都是小白看的</li>\n<li>这种傻瓜文,简直浪费老子的时间!</li>\n</ul>\n</li>\n</ul>\n<p>对于以上三类人,走吧,这里不是你来装逼的地方.<br>你们也不值得看老子花那么多时间去汇总的水文.</p>\n<p>学习一些新东西.若是有人给汇总那么多问题(指明方向和一定的解决法子).<br>不用让我去各种搜索,汇总,总结,学习时间起码可以节省一半!</p>\n<hr>\n<h1 class=\"heading\" data-id=\"heading-1\">问题汇总</h1><h2 class=\"heading\" data-id=\"heading-2\">Q:安装超时(<code>install timeout</code>)</h2><p>方案有这么些:</p>\n<ul>\n<li><strong><code>cnpm</code> : 国内对npm的镜像版本</strong></li>\n</ul>\n<pre><code class=\"hljs javascript\" lang=\"JavaScript\"><span class=\"hljs-comment\">/*\ncnpm website: https://npm.taobao.org/\n*/</span>\n\nnpm install -g cnpm --registry=https:<span class=\"hljs-comment\">//registry.npm.taobao.org</span>\n\n\n<span class=\"hljs-comment\">// cnpm 的大多命令跟 npm 的是一致的,比如安装,卸载这些</span></code></pre><ul>\n<li><p><strong><code>yarn</code> 和 <code>npm</code> 改源大法</strong></p>\n<ul>\n<li>使用 nrm 模块 : <a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fnrm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">www.npmjs.com/package/nrm</a></li>\n<li>npm config : <code>npm config set registry https://registry.npm.taobao.org</code></li>\n<li>yarn config : <code>yarn config set registry https://registry.npm.taobao.org</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-3\">Q:安装一些需要编译的包:提示没有安装<code>python</code>、build失败等</h2><p>因为一些 <code>npm</code> 的包安装需要编译的环境,<code>mac</code> 和 <code>linux</code> 都还好,大多都齐全<br>window 用户依赖 <code>visual studio 的一些库</code>和<code>python 2+</code>,</p>\n<p>windows的小伙伴都装上: </p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ffelixrieseberg%2Fwindows-build-tools\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">windows-build-tools</a></li>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.python.org%2Fdownloads%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">python 2.x</a></li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-4\">Q:<code>can't not find 'xxModule'</code> - 找不到某些依赖或者模块</h2><p>这种情况一般报错信息可以看到是哪个包抛出的信息.<br>一般卸载这个模块,安装重新安装下即可.</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-5\">Q:<code>data functions should return an object</code></h2><p>这个问题是 Vue 实例内,单组件的<code>data</code>必须返回一个对象;如下</p>\n<pre><code class=\"hljs javascript\" lang=\"JavaScript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'page-router-view'</span>,\n      data () {\n      <span class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\">tabs</span>: [\n          {\n            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'财务信息'</span>,\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'/userinfo'</span>\n          },\n          {\n            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'帐号信息'</span>,\n            <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'/userinfo/base'</span>\n          }\n        ]\n      }\n    }\n}</code></pre><p><strong>为什么要 return 一个数据对象呢?</strong></p>\n<p>官方解释如下:  data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！</p>\n<p>简言之,组件复用下,不会造成数据同时指向一处,造出牵一发而动全身的破问题...</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-6\">Q:我给组件内的原生控件添加事件,怎么不生效了!!!</h2><pre><code class=\"hljs html\" lang=\"html\">\n<span class=\"hljs-comment\">&lt;!--比如用了第三方框架,或者一些封装的内置组件; 然后想绑定事件--&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--// 错误例子1--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">el-input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"请输入特定消费金额 \"</span> @<span class=\"hljs-attr\">mouseover</span>=<span class=\"hljs-string\">\"test()\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">el-input</span>&gt;</span>\n\n\n<span class=\"hljs-comment\">&lt;!--// 错误例子2--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\">\"item.menuUrl\"</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"toggleName=''\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"['fzicon',item.menuIcon]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>{{item.menuName}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n\n\n<span class=\"hljs-comment\">&lt;!--上面的两个例子都没法触发事件!!!--&gt;</span>\n<span class=\"hljs-comment\">&lt;!--究其原因,少了一个修饰符 .native--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\">\"item.menuUrl\"</span> @<span class=\"hljs-attr\">click.native</span>=<span class=\"hljs-string\">\"toggleName=''\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">i</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"['fzicon',item.menuIcon]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">i</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>{{item.menuName}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!--明明官方文档有的,一堆人不愿意去看,,Fuck--&gt;</span>\n<span class=\"hljs-comment\">&lt;!--https://cn.vuejs.org/v2/guide/components.html#给组件绑定原生事件--&gt;</span></code></pre><hr>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-7\">Q:我用了 <code>axios</code> , 为什么 IE 浏览器不识别(IE9+)</h2><p>那是因为 IE 整个家族都不支持 promise, 解决方案:</p>\n<pre><code class=\"hljs javascript\" lang=\"JavaScript\">\nnpm install es6-promise\n\n<span class=\"hljs-comment\">// 在 main.js 引入即可</span>\n<span class=\"hljs-comment\">// ES6的polyfill</span>\n<span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"es6-promise\"</span>).polyfill();</code></pre><hr>\n<h2 class=\"heading\" data-id=\"heading-8\">Q:我在函数内用了<code>this.xxx=</code>,为什么抛出<code>Cannot set property 'xxx' of undefined;</code></h2><p>这又是<code>this</code>的套路了..<code>this</code>是和当前运行的上下文绑定的...</p>\n<p>一般你在<code>axios</code>或者其他 <code>promise</code> , 或者<code>setInterval</code> 这些默认都是指向最外层的全局钩子.</p>\n<p>简单点说:\"最外层的上下文就是 <code>window</code>,vue内则是 Vue 对象而不是实例!\";</p>\n<p>解决方案:</p>\n<ul>\n<li>暂存法: 函数内先缓存 <code>this</code> , let that = this;(let是 es6, es5用 var)</li>\n<li>箭头函数: 会强行关联当前运行区域为 this 的上下文;</li>\n</ul>\n<p><code>this</code>的知识, 读\"&lt;&lt;你不知道的 JS 系列&gt;&gt;\"最为合适了,里面讲的很清楚</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-9\">Q:我看一些Vue教程有这么些写法,是什么意思<code>@click.prevent</code>,<code>v-demo.a.b</code>;</h2><p>就拿这两个例子来说吧.</p>\n<ul>\n<li><code>@click.prevent</code> : 事件+修饰符 , 作用就是点击但又阻止默认行为</li>\n<li><code>v-demo.a.b</code>: 自定义指令+修饰符. 具体看你什么指令了,修饰符的作用大多是给事件增加一些确切的拓展功能</li>\n</ul>\n<p>比如阻止事件冒泡,阻止默认行为,访问到原生控件,结合键盘快捷键等等</p>\n<p>传送门:<a href=\"https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fevents.html%23%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">事件修饰符</a>;</p>\n<p>可以自定义修饰符么?也是可以的..</p>\n<p>可以通过全局 <code>config.keyCodes</code> 对象自定义键值修饰符别名：</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-10\">Q:为什么我的引入的小图片渲染出来却是 <code>data:image/png;base64xxxxxxxx</code></h2><p>这个是 webpack 里面的对应插件处理的.</p>\n<p>对于小于多少 K 以下的图片(规定的格式)直接转为 base64格式渲染;</p>\n<p>具体配置在<code>webpack.base.conf.js</code>里面的 rules里面的 <code>url-loader</code></p>\n<p>这样做的好处:在网速不好的时候先于内容加载和减少http的请求次数来减少网站服务器的负担。</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-11\">Q:<code>Component template shold contain exactly one root element.If you are useing  v-if on multiple elements , xxxxx</code></h2><p>大体就是说,单组件渲染 DOM 区域必须要有一个根元素,不能出现同级元素.<br>可以用<code>v-if</code>和<code>v-else-if</code>指令来控制其他元素达到并存的状态</p>\n<p>换个直白的解释,就是有一个唯一的父类,包裹者;</p>\n<p><strong>比如一个 div(父包含块) 内部多少个同级或者嵌套都行,但是最外层元素不能出现同级元素!!!!\n</strong></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-12\">Q:跨域问题怎么破!比如<code>No 'Access-Control-Allow-Origin' header is present on the requested resource.</code></h2><p>这种问题老生常谈了,我就不细说了..大体说一下;</p>\n<p>1: <code>CORS</code> , 前后端都要对应去配置,IE10+<br>2: <code>nginx</code> 反向代理,一劳永逸  &lt;-- 线上环境可以用这个</p>\n<p>线下开发模式,比如你用了<code>vue-cli</code>, 里面的 webpack 有引入了<code>proxyTable</code>这么个玩意,<br>也可以做接口反向代理</p>\n<pre><code class=\"hljs javascript\" lang=\"JavaScript\"><span class=\"hljs-comment\">// 在 config 目录下的index.js</span>\n\nproxyTable: {\n  <span class=\"hljs-string\">\"/bp-api\"</span>: {\n    <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">\"http://new.d.st.cn\"</span>,\n    <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-comment\">// pathRewrite: {</span>\n    <span class=\"hljs-comment\">//   \"^/bp-api\": \"/\"</span>\n    <span class=\"hljs-comment\">// }</span>\n  }\n}\n\n<span class=\"hljs-comment\">// target : 就是 api 的代理的实际路径</span>\n<span class=\"hljs-comment\">// changeOrigin: 就是是变源,必须是...</span>\n<span class=\"hljs-comment\">// pathRewrite : 就是路径重定向,一看就知道</span></code></pre><p>当然还有依旧坚挺的<code>jsonp</code>大法!不过局限性比较多,比较适合一些<strong>特殊</strong>的信息获取!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-13\">Q:我需要遍历的数组值更新了,值也赋值了,为什么视图不更新!!!</h2><p>那是因为有局限性啊,官方文档也说的很清楚,只有一些魔改的之后的方法提供跟原生一样的使用姿势(却又可以触发视图更新);</p>\n<p>一般我们更常用(除了魔改方法)的手段是使用:<code>this.$set(obj,item,value)</code>;</p>\n<p>传送门:<a href=\"https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Flist.html%23%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">数组更新检测(触发视图更新)</a></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-14\">Q:为什么我的组件间的样式不能继承或者覆写啊!!!</h2><p>单组件开发模式下,请确认是否开启了 <code>CSS</code>模块化功能!!</p>\n<p>也就是<code>scoped</code>(vue-cli 里面配置了,只要加入这个属性就自动启用)</p>\n<pre><code class=\"hljs html\" lang=\"html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"scss\"</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre><p>为什么不能继承或者覆写呢,那时因为每个类或者 id 乃至标签都会给自动在css后面添加hash!</p>\n<p>比如</p>\n<pre><code class=\"hljs css\" lang=\"css\">// 写的时候是这个\n.trangle{}\n\n// 编译过后,加上了 hash\n.trangle[data-v-1ec35ffc]{}</code></pre><p>这些都是在 css-loader 里面配置!!!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-15\">Q:路由模式改为<code>history</code>后,除了首次启动首页没报错,刷新访问路由都报错!</h2><p>必须给对应的服务端配置查询的主页面..也可以认为是主路由入口的引导</p>\n<p>官方文档也有,为毛总有人不喜欢去看文档,总喜欢做伸手党....FUCK</p>\n<p><strong>传送门</strong> : <a href=\"https://link.juejin.im?target=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fessentials%2Fhistory-mode.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Vue-Router history Mode</a></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-16\">Q:我想拦截页面,或者在页面进来之前做一些事情,可以么?</h2><p>Of course !!</p>\n<p>各种路由器的钩子!! 传送门: <a href=\"https://link.juejin.im?target=https%3A%2F%2Frouter.vuejs.org%2Fzh-cn%2Fadvanced%2Fnavigation-guards.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>导航守卫</strong></a>;</p>\n<p>当然,记忆滚动的位置也可以做到,详情翻翻里面的文档</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-17\">Q:<code>TypeError: xxx is not a function</code></h2><p>这种问题明显就是写法有问题...能不能动点脑子!!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-18\">Q:<code>Uncaught ReferenceError: xxx is not define</code></h2><ul>\n<li>实例内的 <code>data</code> 对应的变量没有声明</li>\n<li>你导入模块报这个错误,那绝逼是导出没写好</li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-19\">Q:<code>Error in render function:\"Type Error: Cannot read property 'xxx' of undefined\"</code></h2><p>这种问题大多都是初始化的姿势不对;</p>\n<p>比如引入<code>echart</code>这些...仔细去了解下生命周期,再来具体初始化;</p>\n<p>vue 组件有时候也会(嵌套组件或者 <code>props</code>传递初始化)..也是基本这个问题</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-20\">Q:<code>Unexpected token: operator xxxxx</code></h2><p>大佬,这个一看就是语法错误啊.<br>基本都是符号问题.<br>一般报错会给出哪一行或者哪个组件</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-21\">Q:<code>npm run build</code>之后不能直接访问</h2><p>大佬!你最起码得在本地搭个服务器才能访问好么!!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-22\">Q:CSS<code>background</code>引入图片打包后,访问路径错误</h2><p>因为打包后图片是在根目录下,你用相对路径肯定报错啊....<br>你可以魔改 webpack 的配置文件里面的<code>static</code>为<code>./static</code>...但是不建议</p>\n<p>你若是把图片什么丢到<code>assets</code>目录下,然后相对路径,打包后是正常的</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-23\">Q:安装模块时命令窗口输出<code>unsupported platform xxx</code></h2><p>一般两种情况,<code>node</code>版本不兼容,系统不兼容;</p>\n<p>解决方案: 要么不装,要么满足安装要求;</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-24\">Q:<code>Unexpected tab charater</code>这些</h2><p>一般是你用脚手架初始化的时候开了 eslint ;</p>\n<p>要么遵循规则,要么改变规则;</p>\n<p>要么直接把 webpack 里面的 eslint 检测给关闭了</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-25\">Q:<code>Failed to mount component: template or render function not defined</code></h2><p>组件挂载失败,问题只有这么几个</p>\n<p>组件没有正确引入; 挂载点顺序错了了;</p>\n<p>自行动手排查</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-26\">Q:<code>Unknown custom element: &lt;xxx&gt; - did you register the component correctly?</code></h2><p>组件没有正确引入或者正确使用,依次确认</p>\n<ol>\n<li>导入对应的组件</li>\n<li>在 components 内声明</li>\n<li>在 dom 区域声明标签</li>\n</ol>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-27\">Q: <code>axios</code>的 <code>post</code> 请求后台接受不到!</h2><p><code>axios</code>默认是 json 格式提交,确认后台是否做了对应的支持;</p>\n<p>若是只能接受传统的表单序列化,就需要自己写一个转义的方法...</p>\n<p>当然还有一个更加省事的方案,装一个小模块<code>qs</code></p>\n<pre><code class=\"hljs javascript\" lang=\"JavaScript\">\nnpm install qs -S\n\n\n<span class=\"hljs-comment\">// 然后在对应的地方转就行了..单一请求也行,拦截器也行...我是写在拦截器的.</span>\n<span class=\"hljs-comment\">// 具体可以看看我 axios 封装那篇文章</span>\n\n<span class=\"hljs-comment\">//POST传参序列化(添加请求拦截器)</span>\nAxios.interceptors.request.use(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">config</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// 在发送请求之前做某件事</span>\n    <span class=\"hljs-keyword\">if</span> (\n      config.method === <span class=\"hljs-string\">\"post\"</span>\n    ) {\n      <span class=\"hljs-comment\">// 序列化</span>\n      config.data = qs.stringify(config.data); <span class=\"hljs-comment\">// ***** 这里转义</span>\n    }\n\n    <span class=\"hljs-comment\">// 若是有做鉴权token , 就给头部带上token</span>\n    <span class=\"hljs-keyword\">if</span> (localStorage.token) {\n      config.headers.Authorization = localStorage.token;\n    }\n    <span class=\"hljs-keyword\">return</span> config;\n  },\n  error =&gt; {\n    Message({\n      <span class=\"hljs-comment\">//  饿了么的消息弹窗组件,类似toast</span>\n      showClose: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">message</span>: error,\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"error.data.error.message\"</span>\n    });\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.reject(error.data.error.message);\n  }\n);</code></pre><hr>\n<h2 class=\"heading\" data-id=\"heading-28\">Q:<code>Invalid prop: type check failed for prop \"xxx\". Expected Boolean, got String.</code></h2><p>这种问题一般就是组件内的 <code>props</code> 类型已经设置了接受的范围类型,<br>而你传递的值却又不是它需要的类型,写代码严谨些 OK?</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-29\">Q: 过滤器可以用于DOM区域结合指令么?</h2><pre><code class=\"hljs html\" lang=\"html\">// 不行,看下面的错误例子\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item,index) in range | sortByDesc | spliceText\"</span>&gt;</span>{{item}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n\n// `vue2+`的指令只能用语 mustache`{{}}` , 正确姿势如下:\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>{{ message | capitalize }}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre><hr>\n<h2 class=\"heading\" data-id=\"heading-30\">Q: <code>[...Array]</code>,<code>...mapState</code>,<code>[SOME_MUTATION] (state) {}</code>,<code>increment ({ commit }) {}</code>这种写法是什么鬼!</h2><p>出门左拐,ES6+(ES2015)的基础去过一遍..</p>\n<p>上面依次:数组解构,对象解构,对象风格函数,对象解构赋值传递</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-31\">Q: 我的 Vue 网站为什么 UC 访问一片空白亦或者<code>flex</code>布局错乱!!</h2><p>来来来,墙角走起.... <strong>UC 号称移动界的 IE 这称号不是白叫的</strong></p>\n<ul>\n<li><code>flexbox</code> 布局错乱,一般是你没有把兼容方案写上..就是带各种前缀,复合属性拆分<ul>\n<li>看看我这篇文章:<a href=\"https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fcrper%2Farticle%2Fdetails%2F51902681\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">移动端爬坑记 --- （1）布局与样式上的奇葩偶遇</a>, 最好就用插件来代替人力吧,,引入 <code>autoprefixer</code>, 写上兼容范围就好了.</li>\n</ul>\n</li>\n<li><code>UC访问空白</code>, 有一种情况绝对会造成,那就是 ES6的代码降级不够彻底. 其他情况可能就是路由配置问题(自己去排除)<ul>\n<li>现在的开发都推荐按需引入,靠<a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbabel%2Fbabel-preset-env\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>babel-preset-env</code></a> 来控制,以达到打包体积减小.</li>\n<li>但是这样做的后果,有些内核比较老的...嘿嘿..拜拜..</li>\n<li>所以最好把代码完全 ES5话!!记住有些特性不能乱使用,没有对应的 <code>polyfill</code>,比如 ES6 的<code>proxy</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-32\">Q:<code>this.$set | this.$xxx</code> 这个 <code>$</code> 是个什么意思?是 <code>jQuery</code>的么,会冲突么?</h2><p>且看我细细道来.</p>\n<p>Vue 的<code>$</code>和 jQuery 的<code>$</code>并没有半毛钱的关系,就跟<code>javascript</code>和<code>java</code>一样.</p>\n<p>Vue 的<code>$</code>是封装了一些 vue 的内建函数,然后导出以<code>$</code>开头...这显然并不是 <code>jQuery</code>的专利;</p>\n<p>jQuery 的<code>$</code>是选择器!!取得 DOM区域...两者的作用完全不一致!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-33\">Q:Module not found: Error : Can't resolve <code>xxx-loader</code> in xxxx</h2><p>这里问题一般就是webpack的配置文件你改动了或对应的 loader 没有装上</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-34\">Q: 父组件可以直接调用子组件的方法么!</h2><p>可以,通过<code>$refs</code>或者<code>$chilren</code>来拿到对应的实例,从而操作</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-35\">Q:<code>Error in event handler for \"click\":\"xxx\"</code></h2><p>这个问题大多都是你写的代码有问题.你的事件触发了.<br>但是组件内部缺少对应的实现或者变量,所以抛出事件错误.</p>\n<p>解决方案:看着报错慢慢排查</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-36\">Q: 组件的通讯有哪几种啊!!!</h2><p>基本最常用的是这三种;</p>\n<ol>\n<li>父传子: <code>props</code></li>\n<li>子传父: <code>emit</code></li>\n<li>兄弟通讯:<ul>\n<li><code>event bus</code>: 就是找一个中间组件来作为信息传递中介</li>\n<li><code>vuex</code>: 信息树</li>\n</ul>\n</li>\n</ol>\n<p>传送门:</p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">基本通讯</a></li>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh-cn%2Fintro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Vuex</a></li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-37\">Q:既然<code>localStorage</code>和<code>sessionStorage</code>能做到数据维护,为什么还要引入<code>vuex</code>!</h2><p>这个问题问得好,<code>Vuex</code>的目的用来维护同级组件间的数据通讯,拥有一个共同的状态树;</p>\n<p>仅仅活在<code>SPA</code>的里面的<strong>伪多页(路由)</strong>内, 这种东东明明然<code>localStorage</code>和<code>sessionStorage</code><br>也可以做到,还能做到跨页面数据维护..还不会被浏览器刷新干掉...</p>\n<p>为什么还要引入 <code>vuex</code>, 我个人觉得原因只有这么一个,\"可维护性\"和\"易用性\"及</p>\n<p>怎么理解呢?</p>\n<ul>\n<li>可维护性: 因为是单向数据流,所有状态是有迹可循的...数据的传递也可以及时分发响应</li>\n<li>易用性: 它使得我们组件间的通讯变得更强大,而不用借助中间件这类来实现不同组件间的通讯</li>\n</ul>\n<p>而且代码量不多,若是你要用 <code>ls</code>或者<code>ss</code>,你必须手动去跟踪维护你的状态表...<br>虽说可行,但是代码量会多很多,而且可读性很差...</p>\n<p>是不是每个项目都需要用到<code>vuex</code>?<br>答案是否定的,小型项目上这个反而是累赘..这东西一般是用在中型项目+的,<br>因为里面涉及需要维护的数据比较多,同级组件间的通讯比较频繁</p>\n<p>若是用到<code>vuex</code>的项目记得结合<code>ss</code>或者<code>ls</code>来达到某些状态持久化!!!为什么看下面!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-38\">Q:vuex的用户信息为什么还要存一遍在浏览器里(sessionStorage or localStorage)</h2><p>因为 <code>vuex</code>的 store 干不过刷新啊.<br>保存在浏览器的缓存内,若用户刷新的话,值再取一遍呗;</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-39\">Q:\"有 Vue + Vue Router + Vuex\"或什么\"express + vue + mongodb\"的项目学习么</h2><p>Github 一搜一大堆,提这些问题的人动动脑子!.传送门:<a href=\"https://link.juejin.im?target=http%3A%2F%2Fgithub.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>Github</strong></a></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-40\">Q:线上若是 nginx,如何部署?以及反向代理这些!!</h2><p>传送门:<a href=\"https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F58bfc412da2f60124db5999a\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">一篇不大靠谱的nginx 1.11.10配置文件</a></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-41\">Q:\"我会 Vue 我还需要学习 jQuery 或者原生 JS 么\"</h2><p><code>jQuery</code>还有很多公司在用,源码可以学习的地方很多;</p>\n<p>原生 js 是根本,不管是哪个前端框架,最终都是 js 实现的;<br>只有基础扎实,才能学的比较深...</p>\n<p>框架只是加快开发,提高效率,但不是你在这一行长期立足的根本;</p>\n<p>前端的人不仅需要宽度,也要深度...这样才能走的更远....</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-42\">Q: npm run dev 报端口错误!<code>Error: listen EADDRINUSE :::8080</code></h2><ul>\n<li>自己用 webpack搭脚手架的都不用我说了;</li>\n<li>Vue-cli 里面的 webpack 配置: config/index.js</li>\n</ul>\n<pre><code class=\"hljs javascript\" lang=\"JavaScript\">  dev: {\n    <span class=\"hljs-attr\">env</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./dev.env\"</span>),\n    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">8080</span>, <span class=\"hljs-comment\">//  这里这里,若是这个端口已经给系统的其他程序占用了.改我改我!!!!!!</span>\n    autoOpenBrowser: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">assetsSubDirectory</span>: <span class=\"hljs-string\">\"static\"</span>,\n    <span class=\"hljs-attr\">assetsPublicPath</span>: <span class=\"hljs-string\">\"/\"</span>,\n    <span class=\"hljs-attr\">proxyTable</span>: {\n      <span class=\"hljs-string\">\"/bp-api\"</span>: {\n        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">\"http://new.d.st.cn\"</span>,\n        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-comment\">// pathRewrite: {</span>\n        <span class=\"hljs-comment\">//   \"^/bp-api\": \"/\"</span>\n        <span class=\"hljs-comment\">// }</span>\n      }\n    },</code></pre><hr>\n<h2 class=\"heading\" data-id=\"heading-43\">Q: 什么时候用<code>v-if</code>,什么用 <code>v-show</code>!</h2><p>我们先来说说两者的核心差异;</p>\n<ul>\n<li><code>v-if</code> :  DOM 区域没有生成,没有插入文档..等条件成立的时候才动态插入到页面!<ul>\n<li>有些需要遍历的数组对象或者值,最好用这货控制,等到拿到值才处理遍历,不然一些操作过快的情况会报错,比如数据还没请求到!</li>\n</ul>\n</li>\n<li><code>v-show</code>: DOM 区域在组件渲染的时候同时渲染了,只是单纯用 css 隐藏了<ul>\n<li>对于下拉菜单,折叠菜单这些数据基本不怎么变动.用这个最合适了..而且可以改善用户体验,因为它不会导致页面的<strong>重绘</strong>,DOM 操作会! </li>\n</ul>\n</li>\n</ul>\n<p>简言之: DOM结构不怎么变化的用<code>v-show</code>, 数据需要改动很大或者布局改动的用<code>v-if</code></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-44\">Q: <code>&lt;template&gt;</code>是什么,html5的标签么?</h2><p>你猜对了..html5的标签还真有这么一个.传送门<a href=\"https://link.juejin.im?target=https%3A%2F%2Fcaniuse.com%2F%23search%3Dtemplate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Can I Use:template</a></p>\n<p>不过 Vue 的 template 有点不一样,不是去给浏览器解析的....<br>你可以理解为一个临时标签,用来方便你写循环,判断的....<br>因为最终 template 不会解析到浏览器的页面,他只是在 Vue 解析的过程充当一个包裹层!<br>最终我们看到的是内部处理后的组合的 DOM 结构!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-45\">Q:<code>the \"scope\" attribute for scoped slots …. replaced by \"slot-scope\" since 2.5</code></h2><p>这个问题只出现老项目升级到 vue2.5+的时候, 提示就是 scope 现在要用 slot-scope 来代替,<br>但是 scope 暂时可以用,以后会移除</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-46\">Q: <code>Uncaught ReferenceError : Vue is not defined!</code></h2><p>依次排除:</p>\n<ul>\n<li>Vue是否正确引入!</li>\n<li>Vue是否正确实例化!</li>\n<li>Vue 用的姿势是否正确(比如你直接一个 Vue 的变量!!!刚好又没定义,,具体问题具体分析吧)</li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-47\">Q: <code>ERROR in static/js/xxxxxxx.js from UglifyJs</code></h2><p>我知道其中一种情况会报这种情况,就是你引入的 js,是直接引入压缩版本后的 js(<code>xxx.min.js</code>);<br>然后 webpack 内又启用了 UglifyJs(压缩 JS的), 二重压缩大多都会报错!!</p>\n<p>解决方案:引入标准未压缩的 JS</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-48\">Q:<code>props</code>不使用<code>:(v-bind)</code>可以传递值么!</h2><p>可以,只是默认传递的类型会被解析成字符串!<br>若是要传递其他类型,该绑定还是绑定!!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-49\">Q: <code>Uncaught TypeError : Cannot set property xxx which has only a getter</code></h2><p>这个问题就是你要操作的属性只允许 <code>getter</code>,不允许 <code>setter</code>;</p>\n<p>解决方案? 用了别人的东西就要遵循别人的套路来,不然就只能自己动手丰衣足食了!!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-50\">Q: 单组件中里面的 <code>import xxx from '@/components/layout/xxx'</code>中的<code>@</code>是什么鬼!</h2><p>这是 webpack 方面的知识,看到了也说下吧...</p>\n<p>webpack可以配置<code>alias</code>(也就是路径别名),玩过 linux 或者 mac 都知道</p>\n<p>依旧如上,会自己搭脚手架的不用我说了...看看 vue-cli 里面的;</p>\n<p>文件名: build -&gt; webpack.base.conf.js</p>\n<pre><code class=\"hljs javascript\" lang=\"JavaScript\">\n resolve: {\n    <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-string\">\".js\"</span>, <span class=\"hljs-string\">\".vue\"</span>, <span class=\"hljs-string\">\".json\"</span>], <span class=\"hljs-comment\">// 可以导入的时候忽略的拓展名范围</span>\n    alias: {\n      <span class=\"hljs-attr\">vue$</span>: <span class=\"hljs-string\">\"vue/dist/vue.esm.js\"</span>,  \n      <span class=\"hljs-string\">\"@\"</span>: resolve(<span class=\"hljs-string\">\"src\"</span>),  <span class=\"hljs-comment\">// 这里就是别名了,比如@就代表直接从/src 下开始找起!!!</span>\n      <span class=\"hljs-string\">\"~\"</span>: resolve(<span class=\"hljs-string\">\"src/components\"</span>)\n    }\n  },</code></pre><hr>\n<h2 class=\"heading\" data-id=\"heading-51\">Q: <code>SCSS(SASS)</code> 还是 <code>less</code>,<code>stylus</code> 好!!</h2><p>三者都是预处理器;</p>\n<p>scss 出现最久,能做的功能比较多,但是若是普通的嵌套写法,继承,mixin 啊.</p>\n<p>这三个都差不多..会其中一个其他两个的粗浅用法基本也会了.不过!!!!</p>\n<p>写法有些差异:</p>\n<ul>\n<li>scss: 写法上是像 css 靠齐 </li>\n<li>sass : 其实也就是 scss , 只是写法不一样...靠的是缩进</li>\n<li>less : 跟 css 基本靠齐</li>\n<li>stylus : 一样,靠缩进..跟<code>pug(Jade)</code>一样</li>\n</ul>\n<p>使用环境的差异:</p>\n<ul>\n<li>scss 可以借助 ruby 或者 node-sass 编译</li>\n<li>less 可以用 less.js 或者对应的 loader 解析</li>\n<li>stylus 只能借助 loader 解析,它的出现就是基于 node 的</li>\n</ul>\n<p>也有一个后起之秀,主打解耦,插件化的!!! 那就是<code>PostCSS</code>,这个是后处理器!!!<br>有兴趣的可以自行去了解,上面的写法都能借助插件实现!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-52\">Q:<code>Failed to compile with x errors : This  dependency was not found !</code></h2><p>编译错误,对应的依赖没找到!!!</p>\n<p>解决如下:</p>\n<ul>\n<li>知道缺少对应的模块,直接装进去</li>\n<li>若是一个你已经安装的大模块(比如 axios)里面的子模块(依赖包)出了问题,卸载重装整个大模块.因为你补全不一定有用!</li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-53\">Q:SyntaxError: Unexpected identifier;</h2><p>语法错误,看错误信息去找到对应的页面排查!!!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-54\">Q: 为什么我的 <code>npm</code> 或者 <code>yarn</code> 安装依赖会生成 <code>lock</code>文件,有什么用!</h2><p>lock 文件的作用是统一版本号,这对团队协作有很大的作用;</p>\n<p>若是没有 lock 锁定,根据<code>package.json</code>里面的<code>^</code>,<code>~</code>这些..</p>\n<p>不同人,不同时间安装出来的版本号不一定一致;</p>\n<p>有些包甚至有一些<code>breaking change</code>(破坏性的更新),造成开发很难顺利进行!!!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-55\">Q: 组件可以缓存么?</h2><p>可以,用<code>keep-alive</code>;</p>\n<p>不过是有代价的..占有内存会多了...所以无脑的缓存所有组件!!!别说性能好了..切换几次,<br>有些硬件 hold不住的,浏览器直接崩溃或者卡死..</p>\n<p>所以<code>keep-alive</code>一般缓存都是一些列表页,不会有太多的操作,更多的只是结果集的更换..</p>\n<p>给路由的组件<code>meta</code>增加一个标志位,结合<code>v-if</code>就可以按需加上缓存了!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-56\">Q:<code>package.json</code>里面的<code>dependencies</code> 和<code>devDependencies</code>的差异!</h2><p>其实不严格的话,没有特别的差异;<br>若是严格,遵循官方的理解;</p>\n<ul>\n<li><code>dependencies</code> : 存放线上或者业务能访问的核心代码模块,比如 <code>vue</code>,<code>vue-router</code>;</li>\n<li><code>devDependencies</code>: 处于开发模式下所依赖的开发模块,也许只是用来解析代码,转义代码,但是不产生额外的代码到生产环境, 比如什么<code>babel-core</code>这些</li>\n</ul>\n<p>如何把包安装到对应的依赖下呢?</p>\n<pre><code class=\"hljs javascript\" lang=\"JavaScript\">\nnpm install --save xxxx <span class=\"hljs-comment\">// dependencies</span>\nnpm install --save-dev xxxx <span class=\"hljs-comment\">// devDependencies</span>\n\n<span class=\"hljs-comment\">//也能用简易的写法(i:install,-S:save,-D:save-dev)</span>\n\nnpm i -S xxxx <span class=\"hljs-comment\">// npm install --save xxxx</span>\nnpm i -D xxxx <span class=\"hljs-comment\">// npm install --save-dev xxxx</span></code></pre><hr>\n<h2 class=\"heading\" data-id=\"heading-57\">Q: 安装<code>chromedriver</code>报错!!姿势没错啊<code>npm i -D chromedriver</code></h2><p>恩,伟大的 GFW.....解决方案:指定国内的源安装就可以了</p>\n<p><code>npm install --save-dev chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver</code></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-58\">Q:Vue ,React, Angular学习哪个好?哪个工作比较好找!</h2><p>Vue属于渐进式开发,传统开发过渡 MVVM 模式的小伙伴,<code>Vue</code> 比较好上手,学习成本比较低<br>基础比较好的,有折腾精神的,可以选择<code>NG5</code>或者<code>React 16</code>;</p>\n<p>NG5需要学习<code>typescript</code>和<code>rxjs</code>,还用到比较多的新东西,比如装饰器,后端的注入概念.ng有自己的一整套 MVVM 流程;</p>\n<p>而<code>Vue</code>和<code>React</code>核心只是<code>view</code>,可以搭配自己喜欢的</p>\n<p><code>React</code>的写法偏向函数式写法,还有 jsx,官方自己有 <code>flow</code>,当然也能搭配<code>ts</code>,我也没怎么接触..所以也有一定的学习成本;</p>\n<p>至于哪个比较好找工作!!!告诉你..若是只会一个框架,那不是一个合格的前端;</p>\n<p>人家要的是动手能力,解决能力!!!!<strong>技术和待遇是成正比的</strong>!!</p>\n<p>颜值和背景,学历,口才可以加分..但是这些条件你必须要有的基础下才能考虑这些!!!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-59\">Q: 我有个复杂组件需要有新增和编辑的功能同时存在,但是字段要保持不变性怎么破</h2><p>字段保持不变性怎么理解呢? 就是说比如新增和编辑同时共享一份 <code>data</code>;</p>\n<p>有一种就是路由变了,组件渲染同一个(不引起组件的重新渲染和销毁!),但是功能却不同(新增和编译)..</p>\n<p>比如从编辑切到新增,<code>data</code>必须为空白没有赋值的,等待我们去赋值;</p>\n<p>这时候有个东西就特别适合了,那就是<a href=\"https://link.juejin.im?target=https%3A%2F%2Ffacebook.github.io%2Fimmutable-js%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">immutable-js</a>;</p>\n<p>这个东西可以模拟数据的唯一性!或者叫做不变性!</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-60\">Q:\"首屏加载比较慢!!怎么破!打包文件文件比较大\"</h2><p>依次排除和确认:</p>\n<ul>\n<li>减少第三方库的使用,比如<code>jquey</code>这些都可以不要了,很少操作 dom,而且原生基本满足开发</li>\n<li>若是引入<code>moment</code>这些,webpack 排除国际化语言包</li>\n<li>webpack 常规压缩js,css, 愿意折腾的还可以引入 dll 这些</li>\n<li>路由组件采用懒加载</li>\n<li>加入路由过渡和加载等待效果,虽然不能解决根本,但起码让人等的舒心一点不是么!!!</li>\n</ul>\n<p>整体下来,打包之后一般不会太大;</p>\n<p>但是倘若想要更快?那就只能采用服务端渲染(SSR)了,可以避免浏览器去解析模板和指令这些;<br>直接返回一个 html ....还能 SEO...</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-61\">Q: Vue SPA 没法做优化(SEO)!有解决方案么</h2><p>可以的,SSR(服务端渲染就能满足你的需求),因为请求回来就是一个处理完毕的 html</p>\n<p>现在 vue 的服务端开发框架有这么个比较流行,如下</p>\n<p>传送门:<a href=\"https://link.juejin.im?target=https%3A%2F%2Fzh.nuxtjs.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Nuxt.js</a></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-62\">Q: Vue可以写 hybird App 么!</h2><p>当然可以,两个方向.</p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fcordova.apache.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">codorva</a> + <a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Frigor789%2Fnativescript-vue\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nativescript</a></li>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fweex.apache.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Weex</a></li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-63\">Q: Vue 可以写桌面端么?</h2><p>当然可以,有<code>electron</code>和<code>node-webkit(nw)</code>;</p>\n<p>我只了解过<code>electron</code>;</p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Felectron.atom.io%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">electron</a></li>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSimulatedGREG%2Felectron-vue\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">electron-vue</a>: Vue-cli 针对 electron 的脚手架模板</li>\n</ul>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-64\">Q: Vue开发,项目中还需要 <code>jQuery</code>么</h2><p>分情况探讨:</p>\n<ol>\n<li>若是老项目,只是单纯引入 Vue 简化开发的,依旧用吧...</li>\n<li>重构项目?或者发起新项目的,真心没必要了.开发思路不一样,很多以前用 DOM 操作的现在基本可以数据驱动实现,而少量迫不得已的DOM 操作原生就能搞定...而且能减小打包体积,速度又快,何乐而不为!!!</li>\n</ol>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-65\">Q:Vue PC(桌面)端,M(mobile:移动)端,用什么 UI 框架好啊!!!</h2><p><strong>PC</strong></p>\n<p>我推荐的只有两个 <code>element UI</code>和<code>iview</code></p>\n<p><strong>Mobile</strong></p>\n<p><code>Vux</code></p>\n<p>当然还有很多,但是基本用户的认知度都不高,这三个比较流行</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-66\">Q: Vue可以写微信小程序么,怎么搞起</h2><p>可以的,社区也有人出了对应的解决方案,比如比较流行的方案<code>wepy</code>;<br><code>wepy</code>你也可以理解为一个脚手架,让你的写小程序的方式更贴近你用<code>vue-cli</code>写 vue 的感觉...</p>\n<p>传送门:<a href=\"https://link.juejin.im?target=https%3A%2F%2Fwepyjs.github.io%2Fwepy%2F%23%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">wepy</a></p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-67\">Q:想要 mock 数据,直接请求 <strong>json文件</strong> 为什么不行!</h2><p>当然不行,浏览器安全机制不允许,JS天生不能越权(NodeJS不能单纯说是JS)</p>\n<p>你要 mock 数据,一般都有比较成熟的方案...传送门:</p>\n<ul>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnuysoft%2FMock\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mock</a></li>\n<li><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Feasy-mock%2Feasy-mock\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Easy Mock</a></li>\n</ul>\n<hr>\n<h1 class=\"heading\" data-id=\"heading-68\">Vue 周边库汇总</h1><p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fawesome-vue\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>Awesome Vue</strong></a> : 里面收集了 Vue 方方面面的热门库!!</p>\n<hr>\n<h1 class=\"heading\" data-id=\"heading-69\">Vue 最近的动态</h1><ul>\n<li>据说 Vue 3 打算用<code>Proxy</code>拦截器来做数据拦截及响应..这样可以检测到更多数据类型的响应;不过 IE系列全军覆没,<code>polyfill</code> 都不行</li>\n<li>Vue 目前最新 2.5.3 核心库已适配 <code>typescript 2.6</code>; 但是周边库没跟上(比如第三方的 UI 框架,没有更新对应的 <code>d.ts</code>编译器会报错)..若是组件基本都是自己去写,用 <code>ts+vue</code>开发已经没什么特别的坑了...</li>\n</ul>\n<hr>\n<h1 class=\"heading\" data-id=\"heading-70\">结语</h1><p>问题就汇总了这么多...还有一些以前看到了.但是忘记了..想不起来了...后续有看到再补上.</p>\n<p>小伙伴们也可以留言补充,我会及时跟进....</p>\n<p>不过现在的新人好浮躁,一言不合就做伸手党...不愿花时间去折腾.无解.....</p>\n<p>希望该篇文章可以帮到一些小伙伴节省时间，加快开发。</p>\n<p></p><figure><img alt=\"\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2017/9/17/43d50d8fc75062e0abb632393d4cc579?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"800\" data-height=\"600\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n<p>最后送上一张我群里的提问图...!!!!</p>\n<p><strong>调试是不可能调试的，只能靠群聊天解决bug这个样子。超喜欢这个群，群里的人，又厉害说话又好听,O(∩_∩)O~</strong></p>\n<p></p><figure><img alt=\"\" class=\"lazyload inited\" data-src=\"https://user-gold-cdn.xitu.io/2017/11/29/1600700013f42a39?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" data-width=\"1280\" data-height=\"991\" src=\"data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;991&quot;&gt;&lt;/svg&gt;\"><figcaption></figcaption></figure><p></p>\n</div>"
}]